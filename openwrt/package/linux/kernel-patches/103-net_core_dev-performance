--- linux-mips-cvs-21012005/net/core/dev.c	2004-04-16 05:14:21.000000000 +0200
+++ linux-bridge/net/core/dev.c	2005-01-25 08:15:53.000000000 +0100
@@ -1289,6 +1289,19 @@
 	local_irq_save(flags);
 
 	netdev_rx_stat[this_cpu].total++;
+
+#if defined(CONFIG_BCM4710) && defined(CONFIG_BRIDGE) 
+	/* Optimisation for framebursting (allow interleaving of pkts by
+	   immediately processing the rx pkt instead of Qing the pkt and deferring
+	   the processing). Only optimise for bridging and guard against non
+	   TASKLET based netif_rx calls.
+  	 */
+	if (!in_irq() && skb->dev->br_port != NULL && br_handle_frame_hook != NULL){
+		local_irq_restore(flags);
+		return(netif_receive_skb(skb));
+	}
+#endif   
+
 	if (queue->input_pkt_queue.qlen <= netdev_max_backlog) {
 		if (queue->input_pkt_queue.qlen) {
 			if (queue->throttle)
@@ -2053,6 +2066,7 @@
 {
 	struct net_device *dev;
 	int err;
+	struct net_device_stats *stats;
 
 	if ((dev = __dev_get_by_name(ifr->ifr_name)) == NULL)
 		return -ENODEV;
@@ -2167,6 +2181,14 @@
 			ifr->ifr_ifindex = dev->ifindex;
 			return 0;
 
+#ifdef PERFORMANCE_SUPPORT                     
+		case SIOCGIFSTATS:
+			if (!dev->get_stats || !(stats = dev->get_stats(dev)))
+				return -ENODEV;
+			if (copy_to_user(ifr->ifr_data, stats, sizeof(struct net_device_stats)))
+				return -EFAULT;
+			return 0;
+#endif
 		case SIOCGIFTXQLEN:
 			ifr->ifr_qlen = dev->tx_queue_len;
 			return 0;
