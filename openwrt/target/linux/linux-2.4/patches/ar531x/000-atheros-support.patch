diff -urN linux-2.4.32/arch/mips/ar531x/ar531xdbg_io.c linux-2.4.32.new/arch/mips/ar531x/ar531xdbg_io.c
--- linux-2.4.32/arch/mips/ar531x/ar531xdbg_io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531xdbg_io.c	2005-12-24 20:29:42.102311328 +0000
@@ -0,0 +1,217 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright MontaVista Software Inc
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Basic support for polled character input/output
+ * using the AR531X's serial port.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/types.h>
+#include <linux/string.h>
+
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/serial.h>
+#include <asm/gdb-stub.h>
+
+#include "ar531xlnx.h"
+
+#if CONFIG_EARLY_PRINTK_HACK || CONFIG_KGDB
+/* base addr of uart and clock timing */
+#define         BASE                    0xbc000003
+
+/* distance in bytes between two serial registers */
+#define         REG_OFFSET              4
+
+/*
+ * 0 - we need to do serial init
+ * 1 - skip serial init
+ */
+static int serialPortInitialized = 0;
+
+/*
+ *  * the default baud rate *if* we do serial init
+ *   */
+#define         BAUD_DEFAULT            UART16550_BAUD_9600
+
+/* === END OF CONFIG === */
+
+#define         UART16550_BAUD_2400             2400
+#define         UART16550_BAUD_4800             4800
+#define         UART16550_BAUD_9600             9600
+#define         UART16550_BAUD_19200            19200
+#define         UART16550_BAUD_38400            38400
+#define         UART16550_BAUD_57600            57600
+#define         UART16550_BAUD_115200           115200
+
+#define         UART16550_PARITY_NONE           0
+#define         UART16550_PARITY_ODD            0x08
+#define         UART16550_PARITY_EVEN           0x18
+#define         UART16550_PARITY_MARK           0x28
+#define         UART16550_PARITY_SPACE          0x38
+
+#define         UART16550_DATA_5BIT             0x0
+#define         UART16550_DATA_6BIT             0x1
+#define         UART16550_DATA_7BIT             0x2
+#define         UART16550_DATA_8BIT             0x3
+
+#define         UART16550_STOP_1BIT             0x0
+#define         UART16550_STOP_2BIT             0x4
+
+/* register offset */
+#define         OFS_RCV_BUFFER          (0*REG_OFFSET)
+#define         OFS_TRANS_HOLD          (0*REG_OFFSET)
+#define         OFS_SEND_BUFFER         (0*REG_OFFSET)
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+
+/* memory-mapped read/write of the port */
+#define         UART16550_READ(y)    (*((volatile u8*)(BASE + y)))
+#define         UART16550_WRITE(y, z)  ((*((volatile u8*)(BASE + y))) = z)
+
+void
+debugPortInit(u32 baud, u8 data, u8 parity, u8 stop)
+{
+	/* Pull UART out of reset */
+	sysRegWrite(AR531X_RESET,
+		sysRegRead(AR531X_RESET) & ~(AR531X_RESET_UART0));
+
+	/* disable interrupts */
+        UART16550_WRITE(OFS_LINE_CONTROL, 0x0);
+	UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+	/* set up buad rate */
+	{ 
+		u32 divisor;
+		u32 uart_clock_rate = ar531x_cpu_frequency() / 4;
+		u32 base_baud = uart_clock_rate / 16;
+       
+		/* set DIAB bit */
+	        UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+        
+	        /* set divisor */
+	        divisor = base_baud / baud;
+        	UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);
+	        UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);
+
+        	/* clear DIAB bit */
+	        UART16550_WRITE(OFS_LINE_CONTROL, 0x0);
+	}
+
+	/* set data format */
+	UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);
+}
+
+u8
+getDebugChar(void)
+{
+        if (!serialPortInitialized) {
+                serialPortInitialized = 1;
+                debugPortInit(BAUD_DEFAULT,
+                              UART16550_DATA_8BIT,
+                              UART16550_PARITY_NONE, UART16550_STOP_1BIT);
+        }
+
+	while((UART16550_READ(OFS_LINE_STATUS) & 0x1) == 0);
+	return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+#if CONFIG_KGDB
+/*
+ * Peek at the most recently received character.
+ * Don't wait for a new character to be received.
+ */
+u8
+peekDebugChar(void)
+{
+	return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+static int kgdbInitialized = 0;
+
+void
+kgdbInit(void)
+{
+    sysRegWrite(AR531X_WD_CTRL, AR531X_WD_CTRL_IGNORE_EXPIRATION);
+
+    if (!kgdbInitialized) {
+        printk("Setting debug traps - please connect the remote debugger.\n");
+        set_debug_traps();
+        kgdbInitialized = 1;
+    }
+    breakpoint();
+}
+
+int
+kgdbEnabled(void)
+{
+    return kgdbInitialized;
+}
+
+#define DEBUG_CHAR '\001';
+
+int
+kgdbInterrupt(void)
+{
+    if (!kgdbInitialized) {
+        return 0;
+    }
+
+    /* 
+     * Try to avoid swallowing too much input: Only consume
+     * a character if nothing new has arrived.  Yes, there's
+     * still a small hole here, and we may lose an input
+     * character now and then.
+     */
+    if (UART16550_READ(OFS_LINE_STATUS) & 1) {
+        return 0;
+    } else {
+        return UART16550_READ(OFS_RCV_BUFFER) == DEBUG_CHAR;
+    }
+}
+#endif
+
+
+void
+putDebugChar(char byte)
+{
+        if (!serialPortInitialized) {
+                serialPortInitialized = 1;
+                debugPortInit(BAUD_DEFAULT,
+                              UART16550_DATA_8BIT,
+                              UART16550_PARITY_NONE, UART16550_STOP_1BIT);
+        }
+
+	while ((UART16550_READ(OFS_LINE_STATUS) &0x20) == 0);
+	UART16550_WRITE(OFS_SEND_BUFFER, byte);
+ }
+#endif /* CONFIG_EARLY_PRINTK_HACK || CONFIG_KGDB */
diff -urN linux-2.4.32/arch/mips/ar531x/ar531xgpio.c linux-2.4.32.new/arch/mips/ar531x/ar531xgpio.c
--- linux-2.4.32/arch/mips/ar531x/ar531xgpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531xgpio.c	2005-12-24 20:29:42.102311328 +0000
@@ -0,0 +1,141 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Support for GPIO -- General Purpose Input/Output Pins
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include "ar531xlnx.h"
+
+/* GPIO Interrupt Support */
+
+/* Turn on the specified AR531X_GPIO_IRQ interrupt */
+static unsigned int
+ar531x_gpio_intr_startup(unsigned int irq)
+{
+	ar531x_gpio_intr_enable(irq);
+	return 0;
+}
+
+/* Turn off the specified AR531X_GPIO_IRQ interrupt */
+static void
+ar531x_gpio_intr_shutdown(unsigned int irq)
+{
+	ar531x_gpio_intr_disable(irq);
+}
+
+u32 gpioIntMask = 0;
+
+/* Enable the specified AR531X_GPIO_IRQ interrupt */
+void
+ar531x_gpio_intr_enable(unsigned int irq)
+{
+    u32 reg;
+    int gpio;
+
+    gpio = irq - AR531X_GPIO_IRQ_BASE;
+    gpioIntMask |= gpio;
+
+    reg = sysRegRead(AR531X_GPIO_CR);
+    reg &= ~(GPIO_CR_M(gpio) | GPIO_CR_UART(gpio) | GPIO_CR_INT(gpio));
+    reg |= GPIO_CR_I(gpio);
+    reg |= GPIO_CR_INT(gpio);
+
+    sysRegWrite(AR531X_GPIO_CR, reg);
+    (void)sysRegRead(AR531X_GPIO_CR); /* flush to hardware */
+}
+
+/* Disable the specified AR531X_GPIO_IRQ interrupt */
+void
+ar531x_gpio_intr_disable(unsigned int irq)
+{
+    u32 reg;
+    int gpio;
+
+    gpio = irq - AR531X_GPIO_IRQ_BASE;
+
+    reg = sysRegRead(AR531X_GPIO_CR);
+    reg &= ~(GPIO_CR_M(gpio) | GPIO_CR_UART(gpio) | GPIO_CR_INT(gpio));
+    reg |= GPIO_CR_I(gpio);
+    /* No GPIO_CR_INT bit */
+
+    sysRegWrite(AR531X_GPIO_CR, reg);
+    (void)sysRegRead(AR531X_GPIO_CR); /* flush to hardware */
+
+    gpioIntMask &= ~gpio;
+}
+
+static void
+ar531x_gpio_intr_ack(unsigned int irq)
+{
+	ar531x_gpio_intr_disable(irq);
+}
+
+static void
+ar531x_gpio_intr_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		ar531x_gpio_intr_enable(irq);
+}
+
+static void
+ar531x_gpio_intr_set_affinity(unsigned int irq, unsigned long mask)
+{
+	/* Only 1 CPU; ignore affinity request */
+}
+
+int ar531x_gpio_irq_base;
+
+struct hw_interrupt_type ar531x_gpio_intr_controller = {
+	"AR531X GPIO",
+	ar531x_gpio_intr_startup,
+	ar531x_gpio_intr_shutdown,
+	ar531x_gpio_intr_enable,
+	ar531x_gpio_intr_disable,
+	ar531x_gpio_intr_ack,
+	ar531x_gpio_intr_end,
+	ar531x_gpio_intr_set_affinity,
+};
+
+void
+ar531x_gpio_intr_init(int irq_base)
+{
+	int i;
+
+	for (i = irq_base; i < irq_base + AR531X_GPIO_IRQ_COUNT; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &ar531x_gpio_intr_controller;
+	}
+
+	ar531x_gpio_irq_base = irq_base;
+}
+
+/* ARGSUSED */
+void
+spurious_gpio_handler(int cpl, void *dev_id, struct pt_regs *regs)
+{
+    u32 gpioDataIn;
+
+    gpioDataIn = sysRegRead(AR531X_GPIO_DI) & gpioIntMask;
+
+    printk("spurious_gpio_handler: 0x%x di=0x%8.8x gpioIntMask=0x%8.8x\n",
+           cpl, gpioDataIn, gpioIntMask);
+}
+
+struct irqaction spurious_gpio =
+	{spurious_gpio_handler, SA_INTERRUPT, 0, "spurious_gpio",
+            NULL, NULL};
+
diff -urN linux-2.4.32/arch/mips/ar531x/ar531x.h linux-2.4.32.new/arch/mips/ar531x/ar531x.h
--- linux-2.4.32/arch/mips/ar531x/ar531x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531x.h	2005-12-24 20:29:42.102311328 +0000
@@ -0,0 +1,280 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+#ifndef AR531X_H
+#define AR531X_H 1
+
+#include <asm/addrspace.h>
+
+/* Address Map */
+#define AR531X_WLAN0            0x18000000
+#define AR531X_WLAN1            0x18500000
+#define AR531X_ENET0            0x18100000
+#define AR531X_ENET1            0x18200000
+#define AR531X_SDRAMCTL         0x18300000
+#define AR531X_FLASHCTL         0x18400000
+#define AR531X_APBBASE		0x1c000000
+#define AR531X_FLASH            0x1e000000
+
+/*
+ * AR531X_NUM_ENET_MAC defines the number of ethernet MACs that
+ * should be considered available.  The AR5312 supports 2 enet MACS,
+ * even though many reference boards only actually use 1 of them
+ * (i.e. Only MAC 0 is actually connected to an enet PHY or PHY switch.
+ * The AR2312 supports 1 enet MAC.
+ */
+#define AR531X_NUM_ENET_MAC             2
+
+/*
+ * Need these defines to determine true number of ethernet MACs
+ */
+#define AR5212_AR5312_REV2      0x0052          /* AR5312 WMAC (AP31) */
+#define AR5212_AR5312_REV7      0x0057          /* AR5312 WMAC (AP30-040) */
+#define AR5212_AR2313_REV8      0x0058          /* AR2313 WMAC (AP43-030) */
+#define AR531X_RADIO_MASK_OFF  0xc8
+#define AR531X_RADIO0_MASK     0x0003
+#define AR531X_RADIO1_MASK     0x000c
+#define AR531X_RADIO1_S        2 
+
+/*
+ * AR531X_NUM_WMAC defines the number of Wireless MACs that\
+ * should be considered available.
+ */
+#define AR531X_NUM_WMAC                 2
+
+/* Reset/Timer Block Address Map */
+#define AR531X_RESETTMR		(AR531X_APBBASE  + 0x3000)
+#define AR531X_TIMER		(AR531X_RESETTMR + 0x0000) /* countdown timer */
+#define AR531X_WD_CTRL          (AR531X_RESETTMR + 0x0008) /* watchdog cntrl */
+#define AR531X_WD_TIMER         (AR531X_RESETTMR + 0x000c) /* watchdog timer */
+#define AR531X_ISR		(AR531X_RESETTMR + 0x0010) /* Intr Status Reg */
+#define AR531X_IMR		(AR531X_RESETTMR + 0x0014) /* Intr Mask Reg */
+#define AR531X_RESET		(AR531X_RESETTMR + 0x0020)
+#define AR5312_CLOCKCTL1	(AR531X_RESETTMR + 0x0064)
+#define AR5312_SCRATCH   	(AR531X_RESETTMR + 0x006c)
+#define AR531X_PROCADDR		(AR531X_RESETTMR + 0x0070)
+#define AR531X_PROC1		(AR531X_RESETTMR + 0x0074)
+#define AR531X_DMAADDR		(AR531X_RESETTMR + 0x0078)
+#define AR531X_DMA1		(AR531X_RESETTMR + 0x007c)
+#define AR531X_ENABLE           (AR531X_RESETTMR + 0x0080) /* interface enb */
+#define AR531X_REV		(AR531X_RESETTMR + 0x0090) /* revision */
+
+/* AR531X_WD_CTRL register bit field definitions */
+#define AR531X_WD_CTRL_IGNORE_EXPIRATION 0x0000
+#define AR531X_WD_CTRL_NMI               0x0001
+#define AR531X_WD_CTRL_RESET             0x0002
+
+/* AR531X_ISR register bit field definitions */
+#define AR531X_ISR_NONE		0x0000
+#define AR531X_ISR_TIMER	0x0001
+#define AR531X_ISR_AHBPROC	0x0002
+#define AR531X_ISR_AHBDMA	0x0004
+#define AR531X_ISR_GPIO		0x0008
+#define AR531X_ISR_UART0	0x0010
+#define AR531X_ISR_UART0DMA	0x0020
+#define AR531X_ISR_WD		0x0040
+#define AR531X_ISR_LOCAL	0x0080
+
+/* AR531X_RESET register bit field definitions */
+#define AR531X_RESET_SYSTEM     0x00000001  /* cold reset full system */
+#define AR531X_RESET_PROC       0x00000002  /* cold reset MIPS core */
+#define AR531X_RESET_WLAN0      0x00000004  /* cold reset WLAN MAC and BB */
+#define AR531X_RESET_EPHY0      0x00000008  /* cold reset ENET0 phy */
+#define AR531X_RESET_EPHY1      0x00000010  /* cold reset ENET1 phy */
+#define AR531X_RESET_ENET0      0x00000020  /* cold reset ENET0 mac */
+#define AR531X_RESET_ENET1      0x00000040  /* cold reset ENET1 mac */
+#define AR531X_RESET_UART0      0x00000100  /* cold reset UART0 (high speed) */
+#define AR531X_RESET_WLAN1      0x00000200  /* cold reset WLAN MAC/BB */
+#define AR531X_RESET_APB        0x00000400  /* cold reset APB (ar5312) */
+#define AR531X_RESET_WARM_PROC  0x00001000  /* warm reset MIPS core */
+#define AR531X_RESET_WARM_WLAN0_MAC 0x00002000  /* warm reset WLAN0 MAC */
+#define AR531X_RESET_WARM_WLAN0_BB  0x00004000  /* warm reset WLAN0 BaseBand */
+#define AR531X_RESET_NMI        0x00010000  /* send an NMI to the processor */
+#define AR531X_RESET_WARM_WLAN1_MAC 0x00020000  /* warm reset WLAN1 mac */
+#define AR531X_RESET_WARM_WLAN1_BB  0x00040000  /* warm reset WLAN1 baseband */
+#define AR531X_RESET_LOCAL_BUS  0x00080000  /* reset local bus */
+#define AR531X_RESET_WDOG       0x00100000  /* last reset was a watchdog */
+
+#define AR531X_RESET_WMAC0_BITS \
+        AR531X_RESET_WLAN0 |\
+        AR531X_RESET_WARM_WLAN0_MAC |\
+        AR531X_RESET_WARM_WLAN0_BB
+
+#define AR531X_RESERT_WMAC1_BITS \
+        AR531X_RESET_WLAN1 |\
+        AR531X_RESET_WARM_WLAN1_MAC |\
+        AR531X_RESET_WARM_WLAN1_BB
+
+/* AR5312_CLOCKCTL1 register bit field definitions */
+#define AR5312_CLOCKCTL1_PREDIVIDE_MASK    0x00000030
+#define AR5312_CLOCKCTL1_PREDIVIDE_SHIFT            4
+#define AR5312_CLOCKCTL1_MULTIPLIER_MASK   0x00001f00
+#define AR5312_CLOCKCTL1_MULTIPLIER_SHIFT           8
+#define AR5312_CLOCKCTL1_DOUBLER_MASK      0x00010000
+
+/* Valid for AR5312 and AR2312 */
+#define AR5312_CLOCKCTL1_PREDIVIDE_MASK    0x00000030
+#define AR5312_CLOCKCTL1_PREDIVIDE_SHIFT            4
+#define AR5312_CLOCKCTL1_MULTIPLIER_MASK   0x00001f00
+#define AR5312_CLOCKCTL1_MULTIPLIER_SHIFT           8
+#define AR5312_CLOCKCTL1_DOUBLER_MASK      0x00010000
+
+/* Valid for AR2313 */
+#define AR2313_CLOCKCTL1_PREDIVIDE_MASK    0x00003000
+#define AR2313_CLOCKCTL1_PREDIVIDE_SHIFT           12
+#define AR2313_CLOCKCTL1_MULTIPLIER_MASK   0x001f0000
+#define AR2313_CLOCKCTL1_MULTIPLIER_SHIFT          16
+#define AR2313_CLOCKCTL1_DOUBLER_MASK      0x00000000
+
+
+/* AR531X_ENABLE register bit field definitions */
+#define AR531X_ENABLE_WLAN0              0x0001
+#define AR531X_ENABLE_ENET0              0x0002
+#define AR531X_ENABLE_ENET1              0x0004
+#define AR531X_ENABLE_UART_AND_WLAN1_PIO 0x0008   /* UART, and WLAN1 PIOs */
+#define AR531X_ENABLE_WLAN1_DMA          0x0010   /* WLAN1 DMAs */
+#define AR531X_ENABLE_WLAN1 \
+            (AR531X_ENABLE_UART_AND_WLAN1_PIO | AR531X_ENABLE_WLAN1_DMA)
+
+/* AR531X_REV register bit field definitions */
+#define AR531X_REV_WMAC_MAJ    0xf000
+#define AR531X_REV_WMAC_MAJ_S  12
+#define AR531X_REV_WMAC_MIN    0x0f00
+#define AR531X_REV_WMAC_MIN_S  8
+#define AR531X_REV_MAJ         0x00f0
+#define AR531X_REV_MAJ_S       4
+#define AR531X_REV_MIN         0x000f
+#define AR531X_REV_MIN_S       0
+#define AR531X_REV_CHIP        (REV_MAJ|REV_MIN)
+
+/* Major revision numbers, bits 7..4 of Revision ID register */
+#define AR531X_REV_MAJ_AR5312          0x4
+#define AR531X_REV_MAJ_AR2313          0x5
+
+/* Minor revision numbers, bits 3..0 of Revision ID register */
+#define AR5312_REV_MIN_DUAL     0x0     /* Dual WLAN version */
+#define AR5312_REV_MIN_SINGLE   0x1     /* Single WLAN version */
+
+/* AR531X_FLASHCTL register bit field definitions */
+#define FLASHCTL_IDCY   0x0000000f      /* Idle cycle turn around time */
+#define FLASHCTL_IDCY_S 0
+#define FLASHCTL_WST1   0x000003e0      /* Wait state 1 */
+#define FLASHCTL_WST1_S 5
+#define FLASHCTL_RBLE   0x00000400      /* Read byte lane enable */
+#define FLASHCTL_WST2   0x0000f800      /* Wait state 2 */
+#define FLASHCTL_WST2_S 11
+#define FLASHCTL_AC     0x00070000      /* Flash address check (added) */
+#define FLASHCTL_AC_S   16
+#define FLASHCTL_AC_128K 0x00000000
+#define FLASHCTL_AC_256K 0x00010000
+#define FLASHCTL_AC_512K 0x00020000
+#define FLASHCTL_AC_1M   0x00030000
+#define FLASHCTL_AC_2M   0x00040000
+#define FLASHCTL_AC_4M   0x00050000
+#define FLASHCTL_AC_8M   0x00060000
+#define FLASHCTL_AC_RES  0x00070000     /* 16MB is not supported */
+#define FLASHCTL_E      0x00080000      /* Flash bank enable (added) */
+#define FLASHCTL_BUSERR 0x01000000      /* Bus transfer error status flag */
+#define FLASHCTL_WPERR  0x02000000      /* Write protect error status flag */
+#define FLASHCTL_WP     0x04000000      /* Write protect */
+#define FLASHCTL_BM     0x08000000      /* Burst mode */
+#define FLASHCTL_MW     0x30000000      /* Memory width */
+#define FLASHCTL_MWx8   0x00000000      /* Memory width x8 */
+#define FLASHCTL_MWx16  0x10000000      /* Memory width x16 */
+#define FLASHCTL_MWx32  0x20000000      /* Memory width x32 (not supported) */
+#define FLASHCTL_ATNR   0x00000000      /* Access type == no retry */
+#define FLASHCTL_ATR    0x80000000      /* Access type == retry every */
+#define FLASHCTL_ATR4   0xc0000000      /* Access type == retry every 4 */
+
+/* ARM Flash Controller -- 3 flash banks with either x8 or x16 devices.  */
+#define AR531X_FLASHCTL0        (AR531X_FLASHCTL + 0x00)
+#define AR531X_FLASHCTL1        (AR531X_FLASHCTL + 0x04)
+#define AR531X_FLASHCTL2        (AR531X_FLASHCTL + 0x08)
+
+/* ARM SDRAM Controller -- just enough to determine memory size */
+#define AR531X_MEM_CFG1 (AR531X_SDRAMCTL + 0x04)
+#define MEM_CFG1_AC0    0x00000700      /* bank 0: SDRAM addr check (added) */
+#define MEM_CFG1_AC0_S  8
+#define MEM_CFG1_AC1    0x00007000      /* bank 1: SDRAM addr check (added) */
+#define MEM_CFG1_AC1_S  12
+
+/* GPIO Address Map */
+#define AR531X_GPIO         (AR531X_APBBASE  + 0x2000)
+#define AR531X_GPIO_DO      (AR531X_GPIO + 0x00)        /* output register */
+#define AR531X_GPIO_DI      (AR531X_GPIO + 0x04)        /* intput register */
+#define AR531X_GPIO_CR      (AR531X_GPIO + 0x08)        /* control register */
+
+/* GPIO Control Register bit field definitions */
+#define GPIO_CR_M(x)    (1 << (x))                      /* mask for i/o */
+#define GPIO_CR_O(x)    (0 << (x))                      /* mask for output */
+#define GPIO_CR_I(x)    (1 << (x))                      /* mask for input */
+#define GPIO_CR_INT(x)  (1 << ((x)+8))                  /* mask for interrupt */
+#define GPIO_CR_UART(x) (1 << ((x)+16))                 /* uart multiplex */
+
+
+typedef unsigned int AR531X_REG;
+
+#define sysRegRead(phys)	\
+	(*(volatile AR531X_REG *)PHYS_TO_K1(phys))
+
+#define sysRegWrite(phys, val)	\
+	((*(volatile AR531X_REG *)PHYS_TO_K1(phys)) = (val))
+
+
+/*
+ * This is board-specific data that is stored in a "fixed" location in flash.
+ * It is shared across operating systems, so it should not be changed lightly.
+ * The main reason we need it is in order to extract the ethernet MAC
+ * address(es).
+ */
+struct ar531x_boarddata {
+    u32 magic;                       /* board data is valid */
+#define AR531X_BD_MAGIC 0x35333131   /* "5311", for all 531x platforms */
+    u16 cksum;                       /* checksum (starting with BD_REV 2) */
+    u16 rev;                         /* revision of this struct */
+#define BD_REV  4
+    char   boardName[64];            /* Name of board */
+    u16 major;                       /* Board major number */
+    u16 minor;                       /* Board minor number */
+    u32 config;                      /* Board configuration */
+#define BD_ENET0        0x00000001   /* ENET0 is stuffed */
+#define BD_ENET1        0x00000002   /* ENET1 is stuffed */
+#define BD_UART1        0x00000004   /* UART1 is stuffed */
+#define BD_UART0        0x00000008   /* UART0 is stuffed (dma) */
+#define BD_RSTFACTORY   0x00000010   /* Reset factory defaults stuffed */
+#define BD_SYSLED       0x00000020   /* System LED stuffed */
+#define BD_EXTUARTCLK   0x00000040   /* External UART clock */
+#define BD_CPUFREQ      0x00000080   /* cpu freq is valid in nvram */
+#define BD_SYSFREQ      0x00000100   /* sys freq is set in nvram */
+#define BD_WLAN0        0x00000200   /* Enable WLAN0 */
+#define BD_MEMCAP       0x00000400   /* CAP SDRAM @ memCap for testing */
+#define BD_DISWATCHDOG  0x00000800   /* disable system watchdog */
+#define BD_WLAN1        0x00001000   /* Enable WLAN1 (ar5212) */
+#define BD_ISCASPER     0x00002000   /* FLAG for AR2312 */
+#define BD_WLAN0_2G_EN  0x00004000   /* FLAG for radio0_2G */
+#define BD_WLAN0_5G_EN  0x00008000   /* FLAG for radio0_2G */
+#define BD_WLAN1_2G_EN  0x00020000   /* FLAG for radio0_2G */
+#define BD_WLAN1_5G_EN  0x00040000   /* FLAG for radio0_2G */
+    u16 resetConfigGpio;             /* Reset factory GPIO pin */
+    u16 sysLedGpio;                  /* System LED GPIO pin */
+
+    u32 cpuFreq;                     /* CPU core frequency in Hz */
+    u32 sysFreq;                     /* System frequency in Hz */
+    u32 cntFreq;                     /* Calculated C0_COUNT frequency */
+
+    u8  wlan0Mac[6];
+    u8  enet0Mac[6];
+    u8  enet1Mac[6];
+
+    u16 pciId;                       /* Pseudo PCIID for common code */
+    u16 memCap;                      /* cap bank1 in MB */
+
+    /* version 3 */
+    u8  wlan1Mac[6];                 /* (ar5212) */
+};
+#endif /* AR531X_H */
diff -urN linux-2.4.32/arch/mips/ar531x/ar531xintr.S linux-2.4.32.new/arch/mips/ar531x/ar531xintr.S
--- linux-2.4.32/arch/mips/ar531x/ar531xintr.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531xintr.S	2005-12-24 20:29:42.103311176 +0000
@@ -0,0 +1,30 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/*
+ * Glue code to save registers and get us to the interrupt dispatcher
+ */
+	.text
+	.set	noat
+	.align	5
+NESTED(ar531x_interrupt_receive, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+
+	move	a0, sp
+	jal	ar531x_irq_dispatch
+
+	j	ret_from_irq
+
+	END(ar531x_interrupt_receive)
diff -urN linux-2.4.32/arch/mips/ar531x/ar531xirq.c linux-2.4.32.new/arch/mips/ar531x/ar531xirq.c
--- linux-2.4.32/arch/mips/ar531x/ar531xirq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531xirq.c	2005-12-24 20:29:42.132306768 +0000
@@ -0,0 +1,292 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Interrupt support for AR531X WiSOC.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/gdb-stub.h>
+
+#include "ar531xlnx.h"
+#include <asm/irq_cpu.h>
+
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+
+static void ar531x_misc_intr_enable(unsigned int irq);
+static void ar531x_misc_intr_disable(unsigned int irq);
+
+/* Turn on the specified AR531X_MISC_IRQ interrupt */
+static unsigned int
+ar531x_misc_intr_startup(unsigned int irq)
+{
+	ar531x_misc_intr_enable(irq);
+	return 0;
+}
+
+/* Turn off the specified AR531X_MISC_IRQ interrupt */
+static void
+ar531x_misc_intr_shutdown(unsigned int irq)
+{
+	ar531x_misc_intr_disable(irq);
+}
+
+/* Enable the specified AR531X_MISC_IRQ interrupt */
+static void
+ar531x_misc_intr_enable(unsigned int irq)
+{
+	unsigned int imr;
+
+	imr = sysRegRead(AR531X_IMR);
+	imr |= (1 << (irq - AR531X_MISC_IRQ_BASE - 1));
+	sysRegWrite(AR531X_IMR, imr);
+	sysRegRead(AR531X_IMR); /* flush write buffer */
+}
+
+/* Disable the specified AR531X_MISC_IRQ interrupt */
+static void
+ar531x_misc_intr_disable(unsigned int irq)
+{
+	unsigned int imr;
+
+	imr = sysRegRead(AR531X_IMR);
+	imr &= ~(1 << (irq - AR531X_MISC_IRQ_BASE - 1));
+	sysRegWrite(AR531X_IMR, imr);
+	sysRegRead(AR531X_IMR); /* flush write buffer */
+}
+
+static void
+ar531x_misc_intr_ack(unsigned int irq)
+{
+	ar531x_misc_intr_disable(irq);
+}
+
+static void
+ar531x_misc_intr_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		ar531x_misc_intr_enable(irq);
+}
+
+static void
+ar531x_misc_intr_set_affinity(unsigned int irq, unsigned long mask)
+{
+	/* Only 1 CPU; ignore affinity request */
+}
+
+struct hw_interrupt_type ar531x_misc_intr_controller = {
+	"AR531X MISC",
+	ar531x_misc_intr_startup,
+	ar531x_misc_intr_shutdown,
+	ar531x_misc_intr_enable,
+	ar531x_misc_intr_disable,
+	ar531x_misc_intr_ack,
+	ar531x_misc_intr_end,
+	ar531x_misc_intr_set_affinity,
+};
+
+int ar531x_misc_irq_base;
+
+/*
+ * Determine interrupt source among interrupts that use IP6
+ */
+void
+ar531x_misc_intr_init(int irq_base)
+{
+	int i;
+
+	for (i = irq_base; i < irq_base + AR531X_MISC_IRQ_COUNT; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &ar531x_misc_intr_controller;
+	}
+
+	ar531x_misc_irq_base = irq_base;
+}
+
+/* ARGSUSED */
+void
+spurious_irq_handler(int cpl, void *dev_id, struct pt_regs *regs)
+{
+    /* 
+    printk("spurious_irq_handler: %d  cause=0x%8.8x  status=0x%8.8x\n",
+           cpl, cause_intrs, status_intrs); 
+    */
+}
+
+/* ARGSUSED */
+void
+spurious_misc_handler(int cpl, void *dev_id, struct pt_regs *regs)
+{
+    /*
+    printk("spurious_misc_handler: 0x%x isr=0x%8.8x imr=0x%8.8x\n",
+           cpl, ar531x_isr, ar531x_imr);
+    */
+}
+
+void
+ar531x_timer_handler(int cpl, void *dev_id, struct pt_regs *regs)
+{
+	(void)sysRegRead(AR531X_TIMER); /* clear interrupt */
+}
+
+void
+ar531x_ahb_proc_handler(int cpl, void *dev_id, struct pt_regs *regs)
+{
+    u32 procAddr;
+    u32 proc1;
+    u32 dmaAddr;
+    u32 dma1;
+
+    proc1 = sysRegRead(AR531X_PROC1);
+    procAddr = sysRegRead(AR531X_PROCADDR); /* clears error state */
+    dma1 = sysRegRead(AR531X_DMA1);
+    dmaAddr = sysRegRead(AR531X_DMAADDR);   /* clears error state */
+
+    printk("AHB interrupt: PROCADDR=0x%8.8x  PROC1=0x%8.8x  DMAADDR=0x%8.8x  DMA1=0x%8.8x\n",
+        procAddr, proc1, dmaAddr, dma1);
+        
+    machine_restart("AHB error"); /* Catastrophic failure */
+}
+
+static struct irqaction cascade  =
+	{no_action, SA_INTERRUPT, 0, "cascade",
+            NULL, NULL};
+
+static struct irqaction spurious_irq =
+	{spurious_irq_handler, SA_INTERRUPT, 0, "spurious_irq",
+            NULL, NULL};
+
+static struct irqaction spurious_misc =
+	{spurious_misc_handler, SA_INTERRUPT, 0, "spurious_misc",
+            NULL, NULL};
+
+static struct irqaction ar531x_timer_interrupt =
+	{ar531x_timer_handler, SA_INTERRUPT, 0, "ar531x_timer_interrupt",
+            NULL, NULL};
+
+static struct irqaction ar531x_ahb_proc_interrupt =
+	{ar531x_ahb_proc_handler, SA_INTERRUPT, 0, "ar531x_ahb_proc_interrupt",
+            NULL, NULL};
+
+extern asmlinkage void ar531x_interrupt_receive(void);
+
+/*
+ * Called when an interrupt is received, this function
+ * determines exactly which interrupt it was, and it
+ * invokes the appropriate handler.
+ *
+ * Implicitly, we also define interrupt priority by
+ * choosing which to dispatch first.
+ */
+void
+ar531x_irq_dispatch(struct pt_regs *regs)
+{
+	int cause_intrs = regs->cp0_cause;
+	int status_intrs = regs->cp0_status;
+	int pending = cause_intrs & status_intrs;
+
+	if (pending & CAUSEF_IP2) {
+		do_IRQ(AR531X_IRQ_WLAN0_INTRS, regs);
+	}		
+	else if (pending & CAUSEF_IP3) {
+		do_IRQ(AR531X_IRQ_ENET0_INTRS, regs);
+	}
+	else if (pending & CAUSEF_IP4) {
+		do_IRQ(AR531X_IRQ_ENET1_INTRS, regs);
+	}
+	else if (pending & CAUSEF_IP5) {
+		do_IRQ(AR531X_IRQ_WLAN1_INTRS, regs);
+	}
+	else if (pending & CAUSEF_IP6) {
+		AR531X_REG ar531x_isr = sysRegRead(AR531X_ISR);
+		AR531X_REG ar531x_imr = sysRegRead(AR531X_IMR);
+		unsigned int ar531x_misc_intrs = ar531x_isr & ar531x_imr;
+
+		if (ar531x_misc_intrs & AR531X_ISR_TIMER)
+			do_IRQ(AR531X_MISC_IRQ_TIMER, regs);
+		else if (ar531x_misc_intrs & AR531X_ISR_AHBPROC)
+			do_IRQ(AR531X_MISC_IRQ_AHB_PROC, regs);
+		else if (ar531x_misc_intrs & AR531X_ISR_AHBDMA)
+			do_IRQ(AR531X_MISC_IRQ_AHB_DMA, regs);
+		else if (ar531x_misc_intrs & AR531X_ISR_GPIO)
+                {
+                    int i;
+                    u32 gpioIntPending;
+
+                    gpioIntPending = sysRegRead(AR531X_GPIO_DI) & gpioIntMask;
+                    for (i=0; i<AR531X_GPIO_IRQ_COUNT; i++) {
+                        if (gpioIntPending & (1 << i))
+                            do_IRQ(AR531X_GPIO_IRQ(i), regs);
+                    }
+                }
+		else if ((ar531x_misc_intrs & AR531X_ISR_UART0) ||
+		         (ar531x_misc_intrs & AR531X_ISR_UART0DMA)) {
+			do_IRQ(AR531X_MISC_IRQ_UART0, regs);
+#if CONFIG_KGDB
+                        if (kgdbInterrupt()) {
+                                if (!user_mode(regs))
+		                    set_async_breakpoint((unsigned long *)&regs->cp0_epc);
+                        }
+#endif 	/* CONFIG_KGDB */
+                }
+		else if (ar531x_misc_intrs & AR531X_ISR_WD)
+			do_IRQ(AR531X_MISC_IRQ_WATCHDOG, regs);
+		else if (ar531x_misc_intrs & AR531X_ISR_LOCAL)
+			do_IRQ(AR531X_MISC_IRQ_LOCAL, regs);
+		else
+			do_IRQ(AR531X_MISC_IRQ_NONE, regs);
+	} else if (pending & CAUSEF_IP7)
+		do_IRQ(AR531X_IRQ_CPU_CLOCK, regs);
+	else
+		do_IRQ(AR531X_IRQ_NONE, regs);
+}
+
+void __init init_IRQ(void)
+{
+	init_generic_irq();
+	set_except_vector(0, ar531x_interrupt_receive);
+
+	/* Initialize interrupt controllers */
+	mips_cpu_irq_init(MIPS_CPU_IRQ_BASE);
+	ar531x_misc_intr_init(AR531X_MISC_IRQ_BASE);
+        ar531x_gpio_intr_init(AR531X_GPIO_IRQ_BASE);
+	setup_irq(AR531X_IRQ_MISC_INTRS, &cascade);
+	/*
+         * AR531X_IRQ_CPU_CLOCK is setup by ar531x_timer_setup.
+         */
+
+	/* Default "spurious interrupt" handlers */
+	setup_irq(AR531X_IRQ_NONE, &spurious_irq);
+	setup_irq(AR531X_MISC_IRQ_NONE, &spurious_misc);
+	setup_irq(AR531X_GPIO_IRQ_NONE, &spurious_gpio);
+
+	setup_irq(AR531X_MISC_IRQ_TIMER, &ar531x_timer_interrupt);
+	setup_irq(AR531X_MISC_IRQ_AHB_PROC, &ar531x_ahb_proc_interrupt);
+        setup_irq(AR531X_MISC_IRQ_GPIO, &cascade);
+
+#ifdef CONFIG_KGDB
+#if CONFIG_EARLY_STOP
+        kgdbInit();
+#endif
+#endif
+}
diff -urN linux-2.4.32/arch/mips/ar531x/ar531xksyms.c linux-2.4.32.new/arch/mips/ar531x/ar531xksyms.c
--- linux-2.4.32/arch/mips/ar531x/ar531xksyms.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531xksyms.c	2005-12-24 20:29:42.132306768 +0000
@@ -0,0 +1,16 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+#include <linux/module.h>
+#include "asm/atheros/ar531xbsp.h"
+
+#if CONFIG_KGDB
+EXPORT_SYMBOL(kgdbInit);
+EXPORT_SYMBOL(kgdbEnabled);
+#endif
+EXPORT_SYMBOL(ar531x_sys_frequency);
diff -urN linux-2.4.32/arch/mips/ar531x/ar531xlnx.h linux-2.4.32.new/arch/mips/ar531x/ar531xlnx.h
--- linux-2.4.32/arch/mips/ar531x/ar531xlnx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531xlnx.h	2005-12-24 20:29:42.133306616 +0000
@@ -0,0 +1,122 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * This file contains definitions needed in order to compile
+ * AR531X products for linux.  Definitions that are largely
+ * AR531X-specific and independent of operating system belong
+ * in ar531x.h rather than this file.
+ */
+#include "ar531x.h"
+
+#define MIPS_CPU_IRQ_BASE		0x00
+#define AR531X_HIGH_PRIO                0x10
+#define AR531X_MISC_IRQ_BASE		0x20
+#define AR531X_GPIO_IRQ_BASE            0x30
+
+/* Software's idea of interrupts handled by "CPU Interrupt Controller" */
+#define AR531X_IRQ_NONE		MIPS_CPU_IRQ_BASE+0
+#define AR531X_IRQ_WLAN0_INTRS	MIPS_CPU_IRQ_BASE+2 /* C0_CAUSE: 0x0400 */
+#define AR531X_IRQ_ENET0_INTRS	MIPS_CPU_IRQ_BASE+3 /* C0_CAUSE: 0x0800 */
+#define AR531X_IRQ_ENET1_INTRS	MIPS_CPU_IRQ_BASE+4 /* C0_CAUSE: 0x1000 */
+#define AR531X_IRQ_WLAN1_INTRS	MIPS_CPU_IRQ_BASE+5 /* C0_CAUSE: 0x2000 */
+#define AR531X_IRQ_MISC_INTRS	MIPS_CPU_IRQ_BASE+6 /* C0_CAUSE: 0x4000 */
+#define AR531X_IRQ_CPU_CLOCK	MIPS_CPU_IRQ_BASE+7 /* C0_CAUSE: 0x8000 */
+
+/* Miscellaneous interrupts, which share IP6 */
+#define AR531X_MISC_IRQ_NONE		AR531X_MISC_IRQ_BASE+0
+#define AR531X_MISC_IRQ_TIMER		AR531X_MISC_IRQ_BASE+1
+#define AR531X_MISC_IRQ_AHB_PROC	AR531X_MISC_IRQ_BASE+2
+#define AR531X_MISC_IRQ_AHB_DMA		AR531X_MISC_IRQ_BASE+3
+#define AR531X_MISC_IRQ_GPIO		AR531X_MISC_IRQ_BASE+4
+#define AR531X_MISC_IRQ_UART0		AR531X_MISC_IRQ_BASE+5
+#define AR531X_MISC_IRQ_UART0_DMA	AR531X_MISC_IRQ_BASE+6
+#define AR531X_MISC_IRQ_WATCHDOG	AR531X_MISC_IRQ_BASE+7
+#define AR531X_MISC_IRQ_LOCAL		AR531X_MISC_IRQ_BASE+8
+#define AR531X_MISC_IRQ_COUNT		9
+
+/* GPIO Interrupts [0..7], share AR531X_MISC_IRQ_GPIO */
+#define AR531X_GPIO_IRQ_NONE            AR531X_MISC_IRQ_BASE+0
+#define AR531X_GPIO_IRQ(n)              AR531X_MISC_IRQ_BASE+(n)+1
+#define AR531X_GPIO_IRQ_COUNT           9
+
+#define PHYS_TO_K1(physaddr) KSEG1ADDR(physaddr)
+#define PHYS_TO_K0(physaddr) KSEG0ADDR(physaddr)
+#define UNMAPPED_TO_PHYS(vaddr)  PHYSADDR(vaddr)
+#define IS_UNMAPPED_VADDR(vaddr) \
+    ((KSEGX(vaddr) == KSEG0) || (KSEGX(vaddr) == KSEG1))
+
+/* IOCTL commands for /proc/ar531x */
+#define AR531X_CTRL_DO_BREAKPOINT       1
+#define AR531X_CTRL_DO_MADWIFI          2
+
+/*
+ * Definitions for operating system portability.
+ * These are vxWorks-->Linux translations.
+ */
+#define LOCAL static
+#define BOOL int
+#define TRUE 1
+#define FALSE 0
+#define UINT8 u8
+#define UINT16 u16
+#define UINT32 u32
+#define PRINTF printk
+#if /* DEBUG */ 1
+#define DEBUG_PRINTF printk
+#define INLINE
+#else
+DEBUG_PRINTF while (0) printk
+#define INLINE inline
+#endif
+#define sysUDelay(usecs) udelay(usecs)
+#define sysMsDelay(msecs) mdelay(msecs)
+typedef volatile UINT8 *VIRT_ADDR;
+#define MALLOC(sz) kmalloc(sz, GFP_KERNEL)
+#define MALLOC_NOSLEEP(sz) kmalloc(sz, GFP_ATOMIC)
+#define FREE(ptr) kfree((void *)ptr)
+#define BSP_BUG() do { printk("kernel BSP BUG at %s:%d!\n", __FILE__, __LINE__); *(int *)0=0; } while (0)
+#define BSP_BUG_ON(condition) do { if (unlikely((condition)!=0)) BSP_BUG(); } while(0)
+#define ASSERT(x) BSP_BUG_ON(!(x))
+
+extern struct ar531x_boarddata *ar531x_board_configuration;
+extern char *ar531x_radio_configuration;
+extern char *enet_mac_address_get(int MACUnit);
+
+extern void kgdbInit(void);
+extern int kgdbEnabled(void);
+extern void breakpoint(void);
+extern int kgdbInterrupt(void);
+extern unsigned int ar531x_cpu_frequency(void);
+extern unsigned int ar531x_sys_frequency(void);
+
+/* GPIO support */
+extern struct irqaction spurious_gpio;
+extern unsigned int gpioIntMask;
+extern void ar531x_gpio_intr_init(int irq_base);
+extern void ar531x_gpio_ctrl_output(int gpio);
+extern void ar531x_gpio_ctrl_input(int gpio);
+extern void ar531x_gpio_set(int gpio, int val);
+extern int  ar531x_gpio_get(int gpio);
+extern void ar531x_gpio_intr_enable(unsigned int irq);
+extern void ar531x_gpio_intr_disable(unsigned int irq);
+
+/* Watchdog Timer support */
+extern int watchdog_start(unsigned int milliseconds);
+extern int watchdog_stop(void);
+extern int watchdog_is_enabled(void);
+extern unsigned int watchdog_min_timer_reached(void);
+extern void watchdog_notify_alive(void);
+
+#define A_DATA_CACHE_INVAL(start, length) \
+        dma_cache_inv((UINT32)(start),(length))
+
+#define sysWbFlush() mb()
+
+#define intDisable(x) cli()
+#define intEnable(x) sti()
diff -urN linux-2.4.32/arch/mips/ar531x/ar531xprom.c linux-2.4.32.new/arch/mips/ar531x/ar531xprom.c
--- linux-2.4.32/arch/mips/ar531x/ar531xprom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531xprom.c	2005-12-24 20:29:42.133306616 +0000
@@ -0,0 +1,84 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright MontaVista Software Inc
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Prom setup file for ar531x
+ */
+
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+
+#include "ar531xlnx.h"
+
+#define COMMAND_LINE_SIZE 512
+
+char arcs_cmdline[COMMAND_LINE_SIZE];
+
+void __init prom_init(int argc, char *argv[])
+{
+    int i;
+    unsigned int memcfg1;
+    int bank0AC, bank1AC;
+    int memsz_in_mb;
+
+    strcpy(arcs_cmdline, "console=ttyS0,9600");
+    for (i=0; i<argc; i++) {
+        strcat(arcs_cmdline, " ");
+        strcat(arcs_cmdline, argv[i]);
+    }
+
+    mips_machgroup = MACH_GROUP_AR531X;
+#ifdef CONFIG_APUNUSED
+    mips_machtype = MACH_ATHEROS_UNUSED;
+#endif
+#ifdef CONFIG_AP30
+    mips_machtype = MACH_ATHEROS_AP30;
+#endif
+#ifdef CONFIG_AP33
+    mips_machtype = MACH_ATHEROS_AP33;
+#endif
+#ifdef CONFIG_AP38
+    mips_machtype = MACH_ATHEROS_AP38;
+#endif
+#ifdef CONFIG_AP43
+    mips_machtype = MACH_ATHEROS_AP43;
+#endif
+#ifdef CONFIG_AP48
+    mips_machtype = MACH_ATHEROS_AP48;
+#endif
+#ifdef CONFIG_PB32
+    mips_machtype = MACH_ATHEROS_PB32;
+#endif
+
+
+    /* Determine SDRAM size based on Address Checks done at startup */
+    memcfg1 = sysRegRead(AR531X_MEM_CFG1);
+    bank0AC = (memcfg1 & MEM_CFG1_AC0) >> MEM_CFG1_AC0_S;
+    bank1AC = (memcfg1 & MEM_CFG1_AC1) >> MEM_CFG1_AC1_S;
+    memsz_in_mb = (bank0AC ? (1 << (bank0AC+1)) : 0)
+                + (bank1AC ? (1 << (bank1AC+1)) : 0);
+
+    /*
+     * By default, use all available memory.  You can override this
+     * to use, say, 8MB by specifying "mem=8M" as an argument on the
+     * linux bootup command line.
+     */
+    add_memory_region(0, memsz_in_mb << 20, BOOT_MEM_RAM);
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
diff -urN linux-2.4.32/arch/mips/ar531x/ar531xsetup.c linux-2.4.32.new/arch/mips/ar531x/ar531xsetup.c
--- linux-2.4.32/arch/mips/ar531x/ar531xsetup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/ar531xsetup.c	2005-12-24 20:29:42.133306616 +0000
@@ -0,0 +1,240 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Initialization for ar531x SOC.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/types.h>
+#include <linux/string.h>
+
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/serial.h>
+
+#include "ar531xlnx.h"
+
+void
+ar531x_restart(char *command)
+{
+    for(;;) {
+        sysRegWrite(AR531X_RESET, AR531X_RESET_SYSTEM);
+    }
+}
+
+void
+ar531x_halt(void)
+{
+        printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+        while (1);
+}
+
+void
+ar531x_power_off(void)
+{
+        ar531x_halt();
+}
+
+const char *
+get_system_type(void)
+{
+	return "Atheros AR531X";
+}
+
+/*
+ * This table is indexed by bits 5..4 of the CLOCKCTL1 register
+ * to determine the predevisor value.
+ */
+static int CLOCKCTL1_PREDIVIDE_TABLE[4] = {
+    1,
+    2,
+    4,
+    5
+};
+
+unsigned int
+ar531x_cpu_frequency(void)
+{
+	static unsigned int ar531x_calculated_cpu_freq;
+        unsigned int clockctl1_predivide_mask;
+        unsigned int clockctl1_predivide_shift;
+        unsigned int clockctl1_multiplier_mask;
+        unsigned int clockctl1_multiplier_shift;
+        unsigned int clockctl1_doubler_mask;
+        int wisoc_revision;
+
+        /*
+         * Trust the bootrom's idea of cpu frequency.
+         */
+        ar531x_calculated_cpu_freq = sysRegRead(AR5312_SCRATCH);
+        if (ar531x_calculated_cpu_freq)
+	    return ar531x_calculated_cpu_freq;
+
+        wisoc_revision = (sysRegRead(AR531X_REV) & AR531X_REV_MAJ) >> AR531X_REV_MAJ_S;
+        if (wisoc_revision == AR531X_REV_MAJ_AR2313) {
+            clockctl1_predivide_mask = AR2313_CLOCKCTL1_PREDIVIDE_MASK;
+            clockctl1_predivide_shift = AR2313_CLOCKCTL1_PREDIVIDE_SHIFT;
+            clockctl1_multiplier_mask = AR2313_CLOCKCTL1_MULTIPLIER_MASK;
+            clockctl1_multiplier_shift = AR2313_CLOCKCTL1_MULTIPLIER_SHIFT;
+            clockctl1_doubler_mask = AR2313_CLOCKCTL1_DOUBLER_MASK;
+        } else { /* AR5312 and AR2312 */
+            clockctl1_predivide_mask = AR5312_CLOCKCTL1_PREDIVIDE_MASK;
+            clockctl1_predivide_shift = AR5312_CLOCKCTL1_PREDIVIDE_SHIFT;
+            clockctl1_multiplier_mask = AR5312_CLOCKCTL1_MULTIPLIER_MASK;
+            clockctl1_multiplier_shift = AR5312_CLOCKCTL1_MULTIPLIER_SHIFT;
+            clockctl1_doubler_mask = AR5312_CLOCKCTL1_DOUBLER_MASK;
+        }
+
+        /*
+         * Clocking is derived from a fixed 40MHz input clock.
+         *  cpuFreq = InputClock * MULT (where MULT is PLL multiplier)
+         *
+         *  sysFreq = cpuFreq / 4       (used for APB clock, serial,
+         *                               flash, Timer, Watchdog Timer)
+         *
+         *  cntFreq = cpuFreq / 2       (use for CPU count/compare)
+         *
+         * So, for example, with a PLL multiplier of 5, we have
+         *  cpuFrez = 200MHz
+         *  sysFreq = 50MHz
+         *  cntFreq = 100MHz
+         *
+         * We compute the CPU frequency, based on PLL settings.
+         */
+	if (ar531x_calculated_cpu_freq == 0) {
+            unsigned int clockCtl1 = sysRegRead(AR5312_CLOCKCTL1);
+
+            int preDivideSelect = (clockCtl1 & clockctl1_predivide_mask) >>
+                                   clockctl1_predivide_shift;
+
+            int preDivisor = CLOCKCTL1_PREDIVIDE_TABLE[preDivideSelect];
+
+            int multiplier = (clockCtl1 & clockctl1_multiplier_mask) >>
+                              clockctl1_multiplier_shift;
+
+            if (clockCtl1 & clockctl1_doubler_mask) {
+                multiplier = multiplier << 1;
+            }
+
+            ar531x_calculated_cpu_freq = (40000000 / preDivisor) * multiplier;
+        }
+
+	return ar531x_calculated_cpu_freq;
+}
+
+unsigned int
+ar531x_sys_frequency(void)
+{
+	static unsigned int ar531x_calculated_sys_freq = 0;
+
+	if (ar531x_calculated_sys_freq == 0) {
+		ar531x_calculated_sys_freq = ar531x_cpu_frequency() / 4;
+	}
+
+	return ar531x_calculated_sys_freq;
+}
+
+static void __init
+flash_setup(void)
+{
+    UINT32 flash_ctl;
+
+    /* Configure flash bank 0 */
+    flash_ctl = FLASHCTL_E |
+                FLASHCTL_AC_8M |
+                FLASHCTL_RBLE |
+                (0x01 << FLASHCTL_IDCY_S) |
+                (0x07 << FLASHCTL_WST1_S) |
+                (0x07 << FLASHCTL_WST2_S) |
+                (sysRegRead(AR531X_FLASHCTL0) & FLASHCTL_MW);
+
+    sysRegWrite(AR531X_FLASHCTL0, flash_ctl);
+
+    /* Disable other flash banks */
+    sysRegWrite(AR531X_FLASHCTL1,
+                sysRegRead(AR531X_FLASHCTL1) & ~(FLASHCTL_E | FLASHCTL_AC));
+
+    sysRegWrite(AR531X_FLASHCTL2,
+                sysRegRead(AR531X_FLASHCTL2) & ~(FLASHCTL_E | FLASHCTL_AC));
+}
+
+
+
+void __init
+serial_setup(void)
+{
+	struct serial_struct s;
+
+	memset(&s, 0, sizeof(s));
+
+	s.flags = STD_COM_FLAGS;
+	s.io_type = SERIAL_IO_MEM;
+	s.baud_base = ar531x_sys_frequency()/16;
+	s.irq = AR531X_MISC_IRQ_UART0;
+	s.iomem_reg_shift = 2;
+	s.iomem_base = (u8 *)0xbc000003;
+
+	if (early_serial_setup(&s) != 0)
+		printk(KERN_ERR "early_serial_setup failed\n");
+}
+
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+static void __init
+ar531x_timer_setup(struct irqaction *irq)
+{
+        unsigned int count;
+
+	/* Usually irq is timer_irqaction (timer_interrupt) */
+      	setup_irq(AR531X_IRQ_CPU_CLOCK, irq);
+
+        /* to generate the first CPU timer interrupt */
+        count = read_c0_count();
+        write_c0_compare(count + 1000);
+}
+
+extern void (*board_time_init)(void);
+
+static void __init
+ar531x_time_init(void)
+{
+	mips_hpt_frequency = ar531x_cpu_frequency() / 2;
+}
+
+void __init
+ar531x_setup(void)
+{
+	/* Clear any lingering AHB errors */
+	sysRegRead(AR531X_PROCADDR);
+	sysRegRead(AR531X_DMAADDR);
+
+	sysRegWrite(AR531X_WD_CTRL, AR531X_WD_CTRL_IGNORE_EXPIRATION);
+
+        /* Disable data watchpoints */
+        write_c0_watchlo0(0);
+
+	board_time_init = ar531x_time_init;
+        board_timer_setup = ar531x_timer_setup;
+
+        _machine_restart = ar531x_restart;
+        _machine_halt = ar531x_halt;
+        _machine_power_off = ar531x_power_off;
+
+        flash_setup();
+        serial_setup();
+}
diff -urN linux-2.4.32/arch/mips/ar531x/Makefile linux-2.4.32.new/arch/mips/ar531x/Makefile
--- linux-2.4.32/arch/mips/ar531x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/Makefile	2005-12-24 20:29:42.010325312 +0000
@@ -0,0 +1,33 @@
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright © 2003 Atheros Communications, Inc.,  All Rights Reserved.
+#
+
+# Makefile for Atheros ar531x boards
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+.S.s:
+	$(CPP) $(CFLAGS) $< -o $*.s
+.S.o:
+	$(CC) $(CFLAGS) -D__ASSEMBLY__ -c $< -o $*.o
+
+O_TARGET:= ar531x.o
+
+export-objs = ar531xksyms.o
+
+obj-y    := ar531xdbg_io.o	\
+	ar531xsetup.o	\
+	ar531xprom.o	\
+	ar531xirq.o	\
+	ar531xintr.o	\
+	ar531xgpio.o	\
+	ar531xksyms.o
+
+include $(TOPDIR)/Rules.make
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/backup-busybox.links linux-2.4.32.new/arch/mips/ar531x/RAMDISK/backup-busybox.links
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/backup-busybox.links	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/backup-busybox.links	2005-12-24 20:29:42.011325160 +0000
@@ -0,0 +1,33 @@
+/usr/bin/[
+/sbin/brctl
+/bin/cat
+/bin/chmod
+/bin/cp
+/bin/df
+/bin/echo
+/bin/false
+/sbin/ifconfig
+/sbin/init
+/sbin/insmod
+/bin/kill
+/bin/ls
+/sbin/lsmod
+/bin/mkdir
+/sbin/modprobe
+/bin/mount
+/bin/msh
+/bin/mv
+/bin/ping
+/bin/ps
+/bin/pwd
+/sbin/reboot
+/bin/rm
+/bin/rmdir
+/sbin/rmmod
+/sbin/route
+/bin/sh
+/usr/bin/test
+/usr/bin/top
+/bin/true
+/bin/umount
+/usr/bin/wget
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/busybox.links linux-2.4.32.new/arch/mips/ar531x/RAMDISK/busybox.links
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/busybox.links	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/busybox.links	2005-12-24 20:29:42.011325160 +0000
@@ -0,0 +1,33 @@
+/usr/bin/[
+/sbin/brctl
+/bin/cat
+/bin/chmod
+/bin/cp
+/bin/df
+/bin/echo
+/bin/false
+/sbin/ifconfig
+/sbin/init
+/sbin/insmod
+/bin/kill
+/bin/ls
+/sbin/lsmod
+/bin/mkdir
+/sbin/modprobe
+/bin/mount
+/bin/msh
+/bin/mv
+/bin/ping
+/bin/ps
+/bin/pwd
+/sbin/reboot
+/bin/rm
+/bin/rmdir
+/sbin/rmmod
+/sbin/route
+/bin/sh
+/usr/bin/test
+/bin/true
+/bin/umount
+/bin/uname
+/usr/bin/wget
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/Makefile linux-2.4.32.new/arch/mips/ar531x/RAMDISK/Makefile
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/Makefile	2005-12-24 20:29:42.011325160 +0000
@@ -0,0 +1,53 @@
+KERNEL_SOURCE=../../../..
+
+# The value for INITRDSIZE is extracted from linux/.config,
+# if it exists; otherwise, a default value is used.
+
+CONFIG_FILE = $(KERNEL_SOURCE)/.config
+
+ifeq ($(CONFIG_FILE),$(wildcard $(CONFIG_FILE)))
+
+include $(CONFIG_FILE)
+ifdef CONFIG_BLK_DEV_RAM_SIZE
+INITRDSIZE  := $(shell echo $(CONFIG_BLK_DEV_RAM_SIZE))
+else
+INITRDSIZE := 8192
+endif
+
+else
+INITRDSIZE := 8192
+endif
+
+MOUNTPT = /mnt/xtmp
+
+ramdisk.gz: ramdisk
+	gzip -f ramdisk
+
+ramdisk:
+	./makelinks  
+	@echo "CREATING RAMDISK OF SIZE $(INITRDSIZE) on $@"
+	dd if=/dev/zero of=$@ bs=1k count=$(INITRDSIZE)
+	/sbin/mke2fs -vFm0 $@ $(INITRDSIZE)
+	if [ \! -e $(MOUNTPT) ]; then mkdir -p $(MOUNTPT) ; fi
+	mount -o loop $@ $(MOUNTPT)
+	@df $(MOUNTPT)
+	(cd rootdir; tar cf - . ) | (cd $(MOUNTPT) && tar xf - )
+	(cd $(MOUNTPT) ; chown -R root.root . )
+	@df $(MOUNTPT)
+	umount $(MOUNTPT)
+
+install:
+	@(if [ -d $(KERNEL_SOURCE)/arch/mips/ramdisk ]; \
+	then \
+		if [ -f ramdisk.gz ]; \
+		then \
+			cp ramdisk.gz $(KERNEL_SOURCE)/arch/mips/ramdisk/; \
+		else \
+			echo "No ramdisk.gz image"; \
+		fi; \
+	else \
+		echo "No ramdisk directory.  Check KERNEL_SOURCE variable."; \
+	fi)
+
+clean:	
+	rm -f ramdisk.gz ramdisk
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/makelinks linux-2.4.32.new/arch/mips/ar531x/RAMDISK/makelinks
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/makelinks	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/makelinks	2005-12-24 20:29:42.012325008 +0000
@@ -0,0 +1,65 @@
+#!/bin/sh
+
+if [ -f busybox.links ]
+then
+    cat busybox.links | sed 's/\//ln -s -f \/bin\/busybox rootdir\//' | /bin/sh
+fi
+
+cons="  root tty    622"
+disk="  root disk   660"
+mtd="  root root   640"
+makedev () {    # usage: makedev name [bcu] major minor owner group mode
+        if [ "$opt_v" ]
+        then    if [ "$opt_d" ]
+                then    echo "rm -f $1"
+                else    echo "$1        = $2 $3 $4 $5:$6 $7"
+                fi
+        fi
+        [ ! "$opt_n" ] && rm -f $1 &&
+        [ ! "$opt_d" ] && mknod $1 $2 $3 $4 &&
+                chown $5:$6 $1 &&
+                chmod $7 $1
+}  
+
+makedev rootdir/dev/console c 5 1 $cons
+makedev rootdir/dev/ram  b 1 1 $disk 
+makedev rootdir/dev/ram0 b 1 0 $disk
+makedev rootdir/dev/ram1 b 1 1 $disk 
+makedev rootdir/dev/ram2 b 1 2 $disk
+makedev rootdir/dev/ram3 b 1 3 $disk
+makedev rootdir/dev/ram4 b 1 4 $disk
+makedev rootdir/dev/ram5 b 1 5 $disk
+makedev rootdir/dev/ram6 b 1 6 $disk
+makedev rootdir/dev/ram7 b 1 7 $disk
+makedev rootdir/dev/ram8 b 1 8 $disk
+makedev rootdir/dev/ram9 b 1 9 $disk
+makedev rootdir/dev/ram10 b 1 10 $disk
+makedev rootdir/dev/ram11 b 1 11 $disk
+makedev rootdir/dev/ram12 b 1 12 $disk
+makedev rootdir/dev/ram13 b 1 13 $disk
+makedev rootdir/dev/ram14 b 1 14 $disk
+makedev rootdir/dev/ram15 b 1 15 $disk
+
+makedev rootdir/dev/mtd0 c 90 0 $mtd
+makedev rootdir/dev/mtd1 c 90 2 $mtd
+makedev rootdir/dev/mtd2 c 90 4 $mtd
+makedev rootdir/dev/mtd3 c 90 6 $mtd
+makedev rootdir/dev/mtd4 c 90 8 $mtd
+makedev rootdir/dev/mtd5 c 90 10 $mtd
+makedev rootdir/dev/mtd6 c 90 12 $mtd
+makedev rootdir/dev/mtdblock0 b 31 0 $mtd
+makedev rootdir/dev/mtdblock1 b 31 1 $mtd
+makedev rootdir/dev/mtdblock2 b 31 2 $mtd
+makedev rootdir/dev/mtdblock3 b 31 3 $mtd
+makedev rootdir/dev/mtdblock4 b 31 4 $mtd
+makedev rootdir/dev/mtdblock5 b 31 5 $mtd
+makedev rootdir/dev/mtdblock6 b 31 6 $mtd
+makedev rootdir/dev/mtdr0 c 90 1 $mtd
+makedev rootdir/dev/mtdr1 c 90 3 $mtd
+makedev rootdir/dev/mtdr2 c 90 5 $mtd
+makedev rootdir/dev/mtdr3 c 90 7 $mtd
+makedev rootdir/dev/mtdr4 c 90 9 $mtd
+makedev rootdir/dev/mtdr5 c 90 11 $mtd
+makedev rootdir/dev/mtdr6 c 90 13 $mtd
+
+cd rootdir/dev;ln -sf ram1 ram
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/README linux-2.4.32.new/arch/mips/ar531x/RAMDISK/README
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/README	2005-12-24 20:29:42.011325160 +0000
@@ -0,0 +1,40 @@
+How to build a ramdisk image for use as a root filesystem with AR531X
+
+Overview:
+In order to boot from a ramdisk root file system image, you will
+first create a root directory structure in the "rootdir" directory.
+Then run "make" to create a compressed root file system image in
+ramdisk.gz.  Finally, copy this image into your kernel source tree
+and remake the kernel.  The ramdisk image is then built into the
+kernel.  When the kernel starts, it is uncompressed into RAM, and
+used as a root file system.
+
+If you'd like to use a pre-built ramdisk.gz rather than build
+one yourself:
+  cp arch/mips/ar531x/RAMDISK/ramdisk.gz arch/mips/ramdisk/ramdisk.gz
+
+Here are the detailed steps to build your own:
+
+1) Modify Makefile to point KERNEL_SOURCE at your linux source tree.
+
+2) Copy whatever additional files/directories/links you'd like to
+   under rootdir.  Note that you're limited to CONFIG_BLK_DEV_RAM_SIZE
+   1KB blocks, as specified in your linux/.config file.
+   Examples:
+	Copy busybox to rootdir/bin/
+        [NOTE: Copy busybox.links to this directory to
+        cause the makelinks script to automatically
+        set up all of the necessary busybox command links
+        in the rootdir/bin directory].
+
+	Copy any wireless driver modules into rootdir tree
+
+   You might want to make a copy of the rootdir directory
+   before you modify it, just in case you want to get back
+   to the original.
+
+3) LOGIN AS ROOT (e.g. "su") and type "make"
+
+4) Copy the resulting ramdisk.gz to your linux source tree under
+       arch/mips/ramdisk/ramdisk.gz
+   (or "make install" will do this step for you)
Binary files linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/bin/busybox and linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/bin/busybox differ
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/fstab linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/fstab
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/fstab	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/fstab	2005-12-24 20:29:42.063317256 +0000
@@ -0,0 +1 @@
+/proc /proc proc defaults 0 0
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/group linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/group
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/group	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/group	2005-12-24 20:29:42.064317104 +0000
@@ -0,0 +1,18 @@
+root:x:0:
+wheel:x:10:
+bin:x:1:bin,daemon
+daemon:x:2:bin,daemon
+sys:x:3:bin,adm
+adm:x:4:adm,daemon
+tty:x:5:
+disk:x:6:
+lp:x:7:daemon,lp
+mem:x:8:
+kmem:x:9:
+operator:x:11:
+uucp:x:14:uucp
+dip:x:40:
+utmp:x:45:
+www:x:63:
+nobody:x:65534:
+users:x:100:
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/host.conf linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/host.conf
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/host.conf	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/host.conf	2005-12-24 20:29:42.064317104 +0000
@@ -0,0 +1,2 @@
+order hosts,bind
+multi on
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/inittab linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/inittab
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/inittab	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/inittab	2005-12-24 20:29:42.064317104 +0000
@@ -0,0 +1,2 @@
+::sysinit:/etc/rc.d/rcS
+::respawn:/bin/sh
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/nsswitch.conf linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/nsswitch.conf
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/nsswitch.conf	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/nsswitch.conf	2005-12-24 20:29:42.065316952 +0000
@@ -0,0 +1,16 @@
+# /etc/nsswitch.conf
+#
+# Name Service Switch configuration file.
+#
+
+passwd:		compat
+shadow:		compat
+group:		compat
+
+hosts:		files dns
+networks:	files dns
+
+ethers:		files
+protocols:	files
+rpc:		files
+services:	files
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/passwd linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/passwd
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/passwd	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/passwd	2005-12-24 20:29:42.065316952 +0000
@@ -0,0 +1,11 @@
+root:x:0:0:root:/root:/bin/ash
+bin:x:1:1:bin:/bin:/bin/sh
+daemon:x:2:2:daemon:/usr/sbin:/bin/sh
+adm:x:3:4:adm:/adm:/bin/sh
+lp:x:4:7:lp:/var/spool/lpd:/bin/sh
+sync:x:5:0:sync:/bin:/bin/sync
+shutdown:x:6:11:shutdown:/sbin:/sbin/shutdown
+halt:x:7:0:halt:/sbin:/sbin/halt
+uucp:x:10:14:uucp:/var/spool/uucp:/bin/sh
+operator:x:11:0:Operator:/var:/bin/sh
+nobody:x:65534:65534:nobody:/home:/bin/sh
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/rc.d/rcS linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/rc.d/rcS
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/rc.d/rcS	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/rc.d/rcS	2005-12-24 20:29:42.066316800 +0000
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+mount -a
+mount -t jffs2 -o remount +w /
+# mount -t ramfs /dev/ram /ramdisk
+
+echo Load MADWiFi wlan module
+insmod ../../lib/modules/2.4.25/net/wlan.o
+
+echo Load MADWiFi Atheros HAL module
+insmod ../../lib/modules/2.4.25/net/ath_hal.o
+
+echo Load MADWiFi Atheros Driver module
+insmod ../../lib/modules/2.4.25/net/ath_lbus.o
+
+exit
+
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/resolv.conf linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/resolv.conf
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/resolv.conf	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/resolv.conf	2005-12-24 20:29:42.066316800 +0000
@@ -0,0 +1,18 @@
+# /etc/resolv.conf - DNS setup file
+#
+# possible entries are:
+#
+#       domain <domain>                 Local domain name. If not present, the
+#                                       gethostbyname syscall is used to
+#                                       determine the local domain name.
+#
+#       search <list_of_domains>        Search list for hostname lookup.
+#                                       The search list is normally determined
+#                                       from the local domain name but it
+#                                       can be set to a list of domains.
+#
+#       nameserver <ip_addr>            Define which server to contact
+#                                       for DNS lookups. If there are
+#                                       multiple nameserver lines (Max=3),
+#                                       they are queried in the listed order.
+#
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/securetty linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/securetty
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/securetty	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/securetty	2005-12-24 20:29:42.066316800 +0000
@@ -0,0 +1,12 @@
+tty1
+tty2
+tty3
+tty4
+tty5
+tty6
+tty7
+tty8
+ttyS0
+ttyS1
+ttyS2
+ttyS3
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/services linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/services
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/services	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/services	2005-12-24 20:29:42.066316800 +0000
@@ -0,0 +1,193 @@
+#	$NetBSD: services,v 1.18 1996/03/26 00:07:58 mrg Exp $
+#
+# Network services, Internet style
+#
+# Note that it is presently the policy of IANA to assign a single well-known
+# port number for both TCP and UDP; hence, most entries here have two entries
+# even if the protocol doesn't support UDP operations.
+# Updated from RFC 1340, ``Assigned Numbers'' (July 1992).  Not all ports
+# are included, only the more common ones.
+#
+#	from: @(#)services	5.8 (Berkeley) 5/9/91
+#
+tcpmux		1/tcp		# TCP port service multiplexer
+echo		7/tcp
+echo		7/udp
+discard		9/tcp		sink null
+discard		9/udp		sink null
+systat		11/tcp		users
+daytime		13/tcp
+daytime		13/udp
+netstat		15/tcp
+qotd		17/tcp		quote
+msp		18/tcp		# message send protocol
+msp		18/udp		# message send protocol
+chargen		19/tcp		ttytst source
+chargen		19/udp		ttytst source
+ftp-data	20/tcp		# default ftp data port
+ftp		21/tcp
+ssh		22/tcp
+ssh		22/udp
+telnet		23/tcp
+# 24 - private
+smtp		25/tcp		mail
+# 26 - unassigned
+time		37/tcp		timserver
+time		37/udp		timserver
+rlp		39/udp		resource	# resource location
+nameserver	42/tcp		name		# IEN 116
+whois		43/tcp		nicname
+domain		53/tcp		nameserver	# name-domain server
+domain		53/udp		nameserver
+mtp		57/tcp				# deprecated
+bootps		67/tcp		# BOOTP server
+bootps		67/udp
+bootpc		68/tcp		# BOOTP client
+bootpc		68/udp
+tftp		69/udp
+gopher		70/tcp		# Internet Gopher
+gopher		70/udp
+rje		77/tcp		netrjs
+finger		79/tcp
+www		80/tcp		http	# WorldWideWeb HTTP
+www		80/udp			# HyperText Transfer Protocol
+link		87/tcp		ttylink
+kerberos	88/tcp		krb5	# Kerberos v5
+kerberos	88/udp
+supdup		95/tcp
+# 100 - reserved
+hostnames	101/tcp		hostname	# usually from sri-nic
+iso-tsap	102/tcp		tsap		# part of ISODE.
+csnet-ns	105/tcp		cso-ns	# also used by CSO name server
+csnet-ns	105/udp		cso-ns
+rtelnet		107/tcp		# Remote Telnet
+rtelnet		107/udp
+pop2		109/tcp		pop-2 postoffice	# POP version 2
+pop2		109/udp
+pop3		110/tcp		pop-3 # POP version 3
+pop3		110/udp
+sunrpc		111/tcp
+sunrpc		111/udp
+auth		113/tcp		authentication tap ident
+sftp		115/tcp
+uucp-path	117/tcp
+nntp		119/tcp		readnews untp	# USENET News Transfer Protocol
+ntp		123/tcp
+ntp		123/udp				# Network Time Protocol
+netbios-ns	137/tcp				# NETBIOS Name Service
+netbios-ns	137/udp
+netbios-dgm	138/tcp				# NETBIOS Datagram Service
+netbios-dgm	138/udp
+netbios-ssn	139/tcp				# NETBIOS session service
+netbios-ssn	139/udp
+imap2		143/tcp		imap		# Interim Mail Access Proto v2
+imap2		143/udp
+snmp		161/udp				# Simple Net Mgmt Proto
+snmp-trap	162/udp		snmptrap	# Traps for SNMP
+cmip-man	163/tcp				# ISO mgmt over IP (CMOT)
+cmip-man	163/udp
+cmip-agent	164/tcp
+cmip-agent	164/udp
+xdmcp		177/tcp				# X Display Mgr. Control Proto
+xdmcp		177/udp
+nextstep	178/tcp		NeXTStep NextStep	# NeXTStep window
+nextstep	178/udp		NeXTStep NextStep	# server
+bgp		179/tcp				# Border Gateway Proto.
+bgp		179/udp
+prospero	191/tcp				# Cliff Neuman's Prospero
+prospero	191/udp
+irc		194/tcp				# Internet Relay Chat
+irc		194/udp
+smux		199/tcp				# SNMP Unix Multiplexer
+smux		199/udp
+at-rtmp		201/tcp				# AppleTalk routing
+at-rtmp		201/udp
+at-nbp		202/tcp				# AppleTalk name binding
+at-nbp		202/udp
+at-echo		204/tcp				# AppleTalk echo
+at-echo		204/udp
+at-zis		206/tcp				# AppleTalk zone information
+at-zis		206/udp
+z3950		210/tcp		wais		# NISO Z39.50 database
+z3950		210/udp		wais
+ipx		213/tcp				# IPX
+ipx		213/udp
+imap3		220/tcp				# Interactive Mail Access
+imap3		220/udp				# Protocol v3
+ulistserv	372/tcp				# UNIX Listserv
+ulistserv	372/udp
+#
+# UNIX specific services
+#
+exec		512/tcp
+biff		512/udp		comsat
+login		513/tcp
+who		513/udp		whod
+shell		514/tcp		cmd		# no passwords used
+syslog		514/udp
+printer		515/tcp		spooler		# line printer spooler
+talk		517/udp
+ntalk		518/udp
+route		520/udp		router routed	# RIP
+timed		525/udp		timeserver
+tempo		526/tcp		newdate
+courier		530/tcp		rpc
+conference	531/tcp		chat
+netnews		532/tcp		readnews
+netwall		533/udp				# -for emergency broadcasts
+uucp		540/tcp		uucpd		# uucp daemon
+remotefs	556/tcp		rfs_server rfs	# Brunhoff remote filesystem
+#
+webster		765/tcp				# Network dictionary
+webster		765/udp
+# temporary entry (not officially registered by the Samba Team!)
+swat		901/tcp		# Samba Web Administration Tool
+#
+# From ``Assigned Numbers'':
+#
+#> The Registered Ports are not controlled by the IANA and on most systems
+#> can be used by ordinary user processes or programs executed by ordinary
+#> users.
+#
+#> Ports are used in the TCP [45,106] to name the ends of logical
+#> connections which carry long term conversations.  For the purpose of
+#> providing services to unknown callers, a service contact port is
+#> defined.  This list specifies the port used by the server process as its
+#> contact port.  While the IANA can not control uses of these ports it
+#> does register or list uses of these ports as a convienence to the
+#> community.
+#
+ingreslock	1524/tcp
+ingreslock	1524/udp
+prospero-np	1525/tcp		# Prospero non-privileged
+prospero-np	1525/udp
+rfe		5002/tcp		# Radio Free Ethernet
+rfe		5002/udp		# Actually uses UDP only
+#
+#
+# Kerberos (Project Athena/MIT) services
+# Note that these are for Kerberos v4, and are unofficial.
+#
+klogin		543/tcp			# Kerberos `rlogin'
+kshell		544/tcp		krcmd	# Kerberos `rsh'
+kerberos-adm	749/tcp			# Kerberos `kadmin' (v5)
+kerberos4	750/udp		kdc	# Kerberos (server) udp
+kerberos4	750/tcp		kdc	# Kerberos (server) tcp
+kerberos-master	751/udp			# Kerberos admin server udp
+kerberos-master	751/tcp			# Kerberos admin server tcp
+krbupdate	760/tcp		kreg	# BSD Kerberos registration
+kpasswd		761/tcp		kpwd	# BSD Kerberos `passwd'
+eklogin		2105/tcp		# Kerberos encrypted `rlogin'
+#
+# Unofficial but necessary (for NetBSD) services
+#
+supfilesrv	871/tcp			# SUP server
+supfiledbg	1127/tcp		# SUP debugging
+#
+# AppleTalk DDP entries (DDP: Datagram Delivery Protocol)
+#
+rtmp		1/ddp			# Routing Table Maintenance Protocol
+nbp		2/ddp			# Name Binding Protocol
+echo		4/ddp			# AppleTalk Echo Protocol
+zip		6/ddp			# Zone Information Protocol
+
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/shadow linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/shadow
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/etc/shadow	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/etc/shadow	2005-12-24 20:29:42.067316648 +0000
@@ -0,0 +1,11 @@
+root::10933:0:99999:7:::
+bin:*:10933:0:99999:7:::
+daemon:*:10933:0:99999:7:::
+adm:*:10933:0:99999:7:::
+lp:*:10933:0:99999:7:::
+sync:*:10933:0:99999:7:::
+shutdown:*:10933:0:99999:7:::
+halt:*:10933:0:99999:7:::
+uucp:*:10933:0:99999:7:::
+operator:*:10933:0:99999:7:::
+nobody:*:10933:0:99999:7:::
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.generic_string linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.generic_string
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.generic_string	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.generic_string	2005-12-24 20:29:42.071316040 +0000
@@ -0,0 +1 @@
+# module             id=string
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.ieee1394map linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.ieee1394map
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.ieee1394map	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.ieee1394map	2005-12-24 20:29:42.071316040 +0000
@@ -0,0 +1 @@
+# ieee1394 module    match_flags vendor_id model_id specifier_id version
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.isapnpmap linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.isapnpmap
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.isapnpmap	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.isapnpmap	2005-12-24 20:29:42.079314824 +0000
@@ -0,0 +1 @@
+# isapnp module      cardvendor carddevice driver_data vendor     function   ...
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.parportmap linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.parportmap
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.parportmap	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.parportmap	2005-12-24 20:29:42.079314824 +0000
@@ -0,0 +1 @@
+# module             pattern
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.pcimap linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.pcimap
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.pcimap	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.pcimap	2005-12-24 20:29:42.080314672 +0000
@@ -0,0 +1 @@
+# pci module         vendor     device     subvendor  subdevice  class      class_mask driver_data
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.pnpbiosmap linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.pnpbiosmap
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.pnpbiosmap	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.pnpbiosmap	2005-12-24 20:29:42.080314672 +0000
@@ -0,0 +1 @@
+# module             id
diff -urN linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.usbmap linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.usbmap
--- linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.usbmap	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/lib/modules/2.4.25/modules.usbmap	2005-12-24 20:29:42.080314672 +0000
@@ -0,0 +1 @@
+# usb module         match_flags idVendor idProduct bcdDevice_lo bcdDevice_hi bDeviceClass bDeviceSubClass bDeviceProtocol bInterfaceClass bInterfaceSubClass bInterfaceProtocol driver_info
Binary files linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/sbin/iwconfig and linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/sbin/iwconfig differ
Binary files linux-2.4.32/arch/mips/ar531x/RAMDISK/rootdir/sbin/iwpriv and linux-2.4.32.new/arch/mips/ar531x/RAMDISK/rootdir/sbin/iwpriv differ
diff -urN linux-2.4.32/arch/mips/ar531x/README linux-2.4.32.new/arch/mips/ar531x/README
--- linux-2.4.32/arch/mips/ar531x/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/README	2005-12-24 20:29:42.101311480 +0000
@@ -0,0 +1,68 @@
+Basic information for the AR531X Board Support Package
+
+This directory contains the "LBSP" -- Linux Board Support Package --
+for Linux on the Atheros AR531X Wireless System-On-a-Chip.  It is intended
+primarily as a building block for wireless products.  At this time, the
+AR531X Linux BSP is experimental code, and is actively UNDER CONSTRUCTION.
+
+Some components that are supported by this LBSP along with a standard 2.4
+Linux MIPS kernel include
+  R4Kc CPU
+  instruction and data caches
+  SDRAM
+  flash (Macronix, AMD, STS, etc.)
+  16550 serial port
+  ethernet MACs
+  ethernet PHY or PHY Switch (RealTek, Kendin, Marvell)
+  General-Purpose I/O pins
+  kernel debugging with kgdb
+
+This LBSP code does NOT include drivers for the wireless components of the
+chip/boards!  Drivers for those components may be distributed separately.
+In particular, the MADWiFi project under SourceForge supports (not yet!)
+wireless functions on the AR531X chipset.  See
+   http://www.sourceforge.net/projects/madwifi
+
+Files included in this BSP:
+ae531xlnx.c      - Linux-specific portions of the ethernet driver
+ae531xmac.c      - OS-independent AR531X ethernet MAC code
+ae531xmac.h      - OS-independent AR531X ethernet MAC software definitions
+ae531xreg.h      - OS-independent AR531X ethernet MAC hardware definitions
+ar531x.h         - OS-independent AR531X system hardware definitions
+ar531xlnx.h      - Linux-specific AR531X system definitions and externs
+defconfig-ar531x - Default Linux configuration file
+intr_recv.S      - Linux interrupt "glue" code
+ar531xirq.c      - Linux Interrupt Request management
+Makefile         - Linux makefile
+mvPhy.c          - OS-independent ethernet PHY code for Marvell Switch
+mvPhy.h          - OS-independent ethernet PHY definitions for Marvell Switch
+ar531xprom.c     - Linux prom "glue" code
+ar531xsetup.c    - Linux startup code
+ar531xdbg_io.c   - Support for kgdb-based debugging and for EARLY_PRINTK_HACK
+ar531xproc.c     - Pseudo-device driver for /proc/ar531x device
+ar531xgpio.c     - Support for General Purpose I/O pins
+ar531xwmacsl.c   - Wireless MAC Support Layer
+
+Additional files, distributed with the BSP:
+README           - This file
+README.BUILD     - Instructions for building a linux kernel from source
+README.EXECUTE   - Instructions for testing your linux kernel
+README.RAMDISK   - Instructions for building a root ramdisk image
+
+ramdisk.gz       - A binary ramdisk image, suitable for use with AR531X.
+DIFFS            - Directory that contains "patch" files (See README.BUILD)
+
+
+There are several ways to boot a vmlinux image on an AR531X board:
+  -You can boot in over ethernet from the vxWorks bootrom, which is preloaded
+   on all Atheros boards
+  -You can use an ICE (e.g. VisionICE) to load the vmlinux image.  You will
+   need appropriate register initialization (e.g. AP30.ini file)
+  -You can use the eCos RedBoot bootrom loader.  This is a full-featured
+   bootrom which as been ported to AR531x.  It can boot vmlinux over ethernet
+   or from flash.  Source code is available from Atheros.
+
+Please send comments, corrections, complaints, criticisms, suggestions,
+enhancements, requests, or any other reasonable communications regarding
+this effort, to "linux@atheros.com".  Your email will be received by a
+couple of engineers, and redirected as appropriate.
diff -urN linux-2.4.32/arch/mips/ar531x/README.BUILD linux-2.4.32.new/arch/mips/ar531x/README.BUILD
--- linux-2.4.32/arch/mips/ar531x/README.BUILD	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/README.BUILD	2005-12-24 20:29:42.101311480 +0000
@@ -0,0 +1,47 @@
+       How to BUILD a linux kernel for an AR531X system
+
+It is expected that you will build Linux on an existing Linux system, which 
+has all of the standard Linux tools.
+
+01) Obtain a MIPS BigEndian ELF gcc-compatible toolchain.  For example,
+    if you're cross-compiling on a x86 Linux system, you could use:
+    ftp://ftp.mips.com/pub/tools/software/sde-for-linux/sdelinux-5.01-4eb.i386.rpm
+
+02) Obtain the latest working MIPS Linux kernel
+    cvs -d :pserver:cvs@ftp.linux-mips.org:/home/cvs login    (password "cvs")
+    cvs -d :pserver:cvs@ftp.linux-mips.org:/home/cvs co -r linux_2_4 linux
+
+    Now "cd linux".  The remainder of these instructions assume
+    that you are in the linux directory.
+
+03) Place the contents of this directory at arch/mips/ar531x.
+
+04) Use the patch command to patch generic linux files according
+    to the DIFFS directory
+    for i in arch/mips/ar531x/DIFFS/*.diff
+    do
+       patch -p1 < $i
+    done
+    NOTE: This version of the AR531X Linux BSP was tested with
+    MIPS Linux 2.4.22 as of 11/14/03.  If you use a different
+    (e.g. more recent) version of Linux source, you may need to
+    resolve some minor patch and compilation issues.
+
+05) Set up a RAMDISK image.
+    See the instructions in README.RAMDISK.
+
+06) Set up a linux configuration using ar531x/defconfig-ar531x.
+    cp arch/mips/ar531x/defconfig-ar531x .config
+    make oldconfig       (answer all questions that are asked)
+    NOTE: For development/debug purposes, you may want to
+    enable CONFIG_RUNTIME_DEBUG and CONFIG_KGDB.
+
+07) Make dependencies.
+    make dep
+
+08) Build the linux kernel
+    make
+
+09) The linux image you just built is in vmlinux.
+    See instructions in README.EXECUTE to run your vmlinux
+    image on an AP531X-based board.
diff -urN linux-2.4.32/arch/mips/ar531x/README.EXECUTE linux-2.4.32.new/arch/mips/ar531x/README.EXECUTE
--- linux-2.4.32/arch/mips/ar531x/README.EXECUTE	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/README.EXECUTE	2005-12-24 20:29:42.101311480 +0000
@@ -0,0 +1,23 @@
+      How to EXECUTE a linux image on an AR531X system
+
+There are currently three ways to run you vmlinux image:
+  1) Load it using the vxWorks bootrom that is supplied with the board.
+     You can load it over ethernet or from the TFFS file system, if you
+     have sufficient flash to store the image.
+  2) Load it using an ICE (e.g. VisionICE).
+  3) Use a bootrom loader, such as eCos RedBoot.
+
+After you have booted linux:
+  By default, the root filesystem on ramdisk is read-only.
+  To make it writable, use "mount -o remount w /".
+
+  The user-level commands are slightly non-standard, as they
+  are based on "busybox".
+
+  The "wget" command is included.  You can use wget to fetch
+  files from any ftp server.  So, for instance, you can fetch
+  a kernel module and then "insmod" it.
+
+Note that the standard source-level kernel debugger, kgdb, works well
+over the serial line with this port.  We use kgdb and the kgdb_demux perl
+script -- available over the www -- for debugging.
diff -urN linux-2.4.32/arch/mips/ar531x/README.VERSION linux-2.4.32.new/arch/mips/ar531x/README.VERSION
--- linux-2.4.32/arch/mips/ar531x/README.VERSION	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/arch/mips/ar531x/README.VERSION	2005-12-24 20:29:42.101311480 +0000
@@ -0,0 +1 @@
+Source release last modified: 12/16/03
diff -urN linux-2.4.32/arch/mips/config-shared.in linux-2.4.32.new/arch/mips/config-shared.in
--- linux-2.4.32/arch/mips/config-shared.in	2005-12-24 16:11:21.000000000 +0000
+++ linux-2.4.32.new/arch/mips/config-shared.in	2005-12-24 21:33:42.804435856 +0000
@@ -31,6 +31,7 @@
 dep_bool 'Support for Alchemy PB1000 board' CONFIG_MIPS_PB1000 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1100 board' CONFIG_MIPS_PB1100 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1500 board' CONFIG_MIPS_PB1500 $CONFIG_MIPS32
+dep_bool 'Support for Atheros AR5312/AR2312 WiSoC (EXPERIMENTAL)' CONFIG_AR531X $CONFIG_AR531X $CONFIG_EXPERIMENTAL
 dep_bool 'Support for Alchemy PB1550 board' CONFIG_MIPS_PB1550 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1200 board' CONFIG_MIPS_PB1200 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Hydrogen3 board' CONFIG_MIPS_HYDROGEN3 $CONFIG_MIPS32
@@ -196,7 +197,7 @@
    bool '   Support for ZBbus profiling' CONFIG_SIBYTE_TBPROF
 
    if [ "$CONFIG_SIBYTE_SWARM" = "y" -o \
-        "$CONFIG_SIBYTE_LITTLESUR" = "y" -o \
+O5B        "$CONFIG_SIBYTE_LITTLESUR" = "y" -o \
         "$CONFIG_SIBYTE_PTSWARM" = "y" -o \
         "$CONFIG_SIBYTE_CARMEL" = "y" ]; then
       define_bool CONFIG_SIBYTE_GENBUS_IDE y
@@ -239,6 +240,43 @@
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
+if [ "$CONFIG_AR531X" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_CPU_VR4100 y
+   define_bool CONFIG_SERIAL y
+   define_bool CONFIG_NEW_IRQ y
+   define_bool CONFIG_NEW_TIME_C y
+   define_bool CONFIG_AR5312
+   define_bool CONFIG_NONCOHERENT_IO y
+   bool 'Enable early printk hack' CONFIG_EARLY_PRINTK_HACK
+   define_bool CONFIG_SCSI n
+   mainmenu_option next_comment
+   comment 'Board selection'
+      choice 'Board type' \
+         "UNKNOWN CONFIG_APUNKNOWN \
+	  AP30 CONFIG_AP30 \
+          AP31 CONFIG_AP31 \
+	  AP33 CONFIG_AP33 \
+    	  AP38 CONFIG_AP38 \
+	  AP43 CONFIG_AP43 \
+	  AP48 CONFIG_AP48" AP30
+   if [ "$CONFIG_AP30" = "y" ]; then
+	define_int CONFIG_MTD_PHYSMAP_BUSWIDTH 2
+   fi
+   if [ "$CONFIG_AP33" = "y" ]; then
+	define_int CONFIG_MTD_PHYSMAP_BUSWIDTH 1
+   fi
+   if [ "$CONFIG_AP38" = "y" ]; then
+	define_int CONFIG_MTD_PHYSMAP_BUSWIDTH 1
+   fi
+   if [ "$CONFIG_AP43" = "y" ]; then
+	define_int CONFIG_MTD_PHYSMAP_BUSWIDTH 1
+   fi
+   if [ "$CONFIG_AP48" = "y" ]; then
+	define_int CONFIG_MTD_PHYSMAP_BUSWIDTH 1
+   fi
+   endmenu
+fi
 if [ "$CONFIG_CASIO_E55" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
    define_bool CONFIG_NONCOHERENT_IO y
diff -urN linux-2.4.32/arch/mips/kernel/setup.c linux-2.4.32.new/arch/mips/kernel/setup.c
--- linux-2.4.32/arch/mips/kernel/setup.c	2005-12-24 16:08:53.000000000 +0000
+++ linux-2.4.32.new/arch/mips/kernel/setup.c	2005-12-24 21:28:51.779678344 +0000
@@ -494,6 +494,7 @@
 	void hp_setup(void);
 	void au1x00_setup(void);
 	void frame_info_init(void);
+	void ar531x_setup(void);
 
 	frame_info_init();
 #if defined(CONFIG_BLK_DEV_FD) || defined(CONFIG_BLK_DEV_FD_MODULE)
@@ -691,6 +692,12 @@
                 pmc_yosemite_setup();
                 break;
 #endif
+
+#ifdef CONFIG_AR531X
+	case MACH_GROUP_AR531X:
+		ar531x_setup();
+		break;
+#endif
 	default:
 		panic("Unsupported architecture");
 	}
diff -urN linux-2.4.32/arch/mips/Makefile linux-2.4.32.new/arch/mips/Makefile
--- linux-2.4.32/arch/mips/Makefile	2005-12-24 16:09:51.000000000 +0000
+++ linux-2.4.32.new/arch/mips/Makefile	2005-12-24 21:28:51.780678192 +0000
@@ -725,6 +725,12 @@
 LOADADDR      += 0x80020000
 endif
 
+ifdef CONFIG_AR531X
+SUBDIRS       += arch/mips/ar531x
+LIBS          += arch/mips/ar531x/ar531x.o
+LOADADDR      += 0x80002000
+endif
+
 #
 # Choosing incompatible machines durings configuration will result in
 # error messages during linking.  Select a default linkscript if
diff -urN linux-2.4.32/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.4.32.new/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.4.32/drivers/mtd/chips/cfi_cmdset_0002.c	2004-11-17 11:54:21.000000000 +0000
+++ linux-2.4.32.new/drivers/mtd/chips/cfi_cmdset_0002.c	2005-12-24 21:28:51.795675912 +0000
@@ -510,7 +510,7 @@
 	   or tells us why it failed. */        
 	dq6 = CMD(1<<6);
 	dq5 = CMD(1<<5);
-	timeo = jiffies + (HZ/1000); /* setting timeout to 1ms for now */
+	timeo = jiffies + (HZ/1000) + 1; /* setting timeout to 1ms for now */
 		
 	oldstatus = cfi_read(map, adr);
 	status = cfi_read(map, adr);
@@ -535,12 +535,14 @@
 		if( (status & dq5) == dq5 ) {
 			/* When DQ5 raises, we must check once again
 			   if DQ6 is toggling.  If not, the erase has been
-			   completed OK.  If not, reset chip. */
+			   completed OK.  But if so, reset chip. */
 			oldstatus = cfi_read(map, adr);
 			status = cfi_read(map, adr);
 		    
 			if ( (oldstatus & 0x00FF) == (status & 0x00FF) ) {
+#if 0
 				printk(KERN_WARNING "Warning: DQ5 raised while program operation was in progress, however operation completed OK\n" );
+#endif
 			} else { 
 				/* DQ5 is active so we can do a reset and stop the erase */
 				cfi_write(map, CMD(0xF0), chip->start);
diff -urN linux-2.4.32/drivers/mtd/chips/jedec_probe.c linux-2.4.32.new/drivers/mtd/chips/jedec_probe.c
--- linux-2.4.32/drivers/mtd/chips/jedec_probe.c	2003-06-13 15:51:34.000000000 +0100
+++ linux-2.4.32.new/drivers/mtd/chips/jedec_probe.c	2005-12-24 21:28:51.797675608 +0000
@@ -900,7 +900,16 @@
 		NumEraseRegions: 1,
 		regions: {ERASEINFO(0x01000,256),
 		}
-	} 
+	}, {
+		mfr_id: MANUFACTURER_SST,
+		dev_id: SST39LF160,
+		name: "SST 39LF160",
+		DevSize: SIZE_2MiB,
+		CmdSet: P_ID_AMD_STD,
+		NumEraseRegions: 1,
+		regions: {ERASEINFO(0x01000,512),
+		}
+        }
 };
 
 
diff -urN linux-2.4.32/drivers/mtd/Config.in linux-2.4.32.new/drivers/mtd/Config.in
--- linux-2.4.32/drivers/mtd/Config.in	2003-06-13 15:51:34.000000000 +0100
+++ linux-2.4.32.new/drivers/mtd/Config.in	2005-12-24 21:28:51.803674696 +0000
@@ -14,6 +14,9 @@
    dep_tristate '  MTD partitioning support' CONFIG_MTD_PARTITIONS $CONFIG_MTD
    dep_tristate '  MTD concatenating support' CONFIG_MTD_CONCAT $CONFIG_MTD
    dep_tristate '  RedBoot partition table parsing' CONFIG_MTD_REDBOOT_PARTS $CONFIG_MTD_PARTITIONS
+   if [ "$CONFIG_MTD_END_RESERVED" != "" ]; then
+      define_int CONFIG_MTD_END_RESERVED $CONFIG_MTD_END_RESERVED
+   fi
    dep_tristate '  Command line partition table parsing' CONFIG_MTD_CMDLINE_PARTS $CONFIG_MTD_PARTITIONS
    if [ "$CONFIG_ARM" = "y" ]; then
       dep_tristate '  ARM Firmware Suite partition parsing' CONFIG_MTD_AFS_PARTS $CONFIG_MTD_PARTITIONS
diff -urN linux-2.4.32/drivers/mtd/maps/physmap.c linux-2.4.32.new/drivers/mtd/maps/physmap.c
--- linux-2.4.32/drivers/mtd/maps/physmap.c	2003-06-13 15:51:34.000000000 +0100
+++ linux-2.4.32.new/drivers/mtd/maps/physmap.c	2005-12-24 21:28:51.811673480 +0000
@@ -80,12 +80,18 @@
 };
 
 #ifdef CONFIG_MTD_PARTITIONS
-#ifdef CONFIG_MTD_CMDLINE_PARTS
+#if defined(CONFIG_MTD_CMDLINE_PARTS) || defined(CONFIG_MTD_REDBOOT_PARTS)
 static struct mtd_partition *mtd_parts = 0;
 static int                   mtd_parts_nb = 0;
 #else
 static struct mtd_partition physmap_partitions[] = {
 /* Put your own partition definitions here */
+    {
+        name:   "rootfs",
+        size:   0x000e0000,
+        offset: 0x000f0000,
+        /* Allow file system to be mounted for writing */
+    }
 #if 0
 	{
 		name:		"bootROM",
@@ -138,6 +144,22 @@
 
 		add_mtd_device(mymtd);
 #ifdef CONFIG_MTD_PARTITIONS
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+                {
+                    extern int parse_redboot_partitions(struct mtd_info *master,
+                                        struct mtd_partition **pparts);
+
+                    struct mtd_partition *rb_parts = 0;
+                    int rb_parts_nb = 0;
+
+		    rb_parts_nb = parse_redboot_partitions(mymtd, &rb_parts);
+		    if (rb_parts_nb > 0) {
+                        printk(KERN_NOTICE
+                               "Using redboot flash partitioning");
+			add_mtd_partitions (mymtd, rb_parts, rb_parts_nb);
+		    }
+                }
+#endif
 #ifdef CONFIG_MTD_CMDLINE_PARTS
 		mtd_parts_nb = parse_cmdline_partitions(mymtd, &mtd_parts, 
 							"phys");
@@ -147,7 +169,8 @@
 			       "Using command line partition definition\n");
 			add_mtd_partitions (mymtd, mtd_parts, mtd_parts_nb);
 		}
-#else
+#endif
+#if !defined(CONFIG_MTD_CMDLINE_PARTS) && !defined(CONFIG_MTD_REDBOOT_PARTS)
 		if (NUM_PARTITIONS != 0) 
 		{
 			printk(KERN_NOTICE 
diff -urN linux-2.4.32/drivers/mtd/redboot.c linux-2.4.32.new/drivers/mtd/redboot.c
--- linux-2.4.32/drivers/mtd/redboot.c	2001-11-09 22:01:22.000000000 +0000
+++ linux-2.4.32.new/drivers/mtd/redboot.c	2005-12-24 21:28:51.821671960 +0000
@@ -51,8 +51,14 @@
 		return -ENOMEM;
 
 	/* Read the start of the last erase block */
-	ret = master->read(master, master->size - master->erasesize,
+        {
+        u_int32_t part_table_start = master->size - master->erasesize;
+#if defined(CONFIG_MTD_END_RESERVED)
+        part_table_start -= CONFIG_MTD_END_RESERVED;
+#endif
+	ret = master->read(master, part_table_start,
 			   PAGE_SIZE, &retlen, (void *)buf);
+        }
 
 	if (ret)
 		goto out;
diff -urN linux-2.4.32/drivers/net/Config.in linux-2.4.32.new/drivers/net/Config.in
--- linux-2.4.32/drivers/net/Config.in	2005-12-24 16:16:53.000000000 +0000
+++ linux-2.4.32.new/drivers/net/Config.in	2005-12-24 21:28:51.856666640 +0000
@@ -30,6 +30,8 @@
 comment 'Ethernet (10 or 100Mbit)'
 bool 'Ethernet (10 or 100Mbit)' CONFIG_NET_ETHERNET
 if [ "$CONFIG_NET_ETHERNET" = "y" ]; then
+   define_bool CONFIG_VENETDEV n
+   define_bool CONFIG_MARVELL_ENET_PHY y
    if [ "$CONFIG_ARM" = "y" ]; then  
       dep_bool '  ARM EBSA110 AM79C961A support' CONFIG_ARM_AM79C961A $CONFIG_ARCH_EBSA110
       tristate '  Cirrus Logic CS8900A support' CONFIG_ARM_CIRRUS
diff -urN linux-2.4.32/drivers/net/wireless/Config.in linux-2.4.32.new/drivers/net/wireless/Config.in
--- linux-2.4.32/drivers/net/wireless/Config.in	2004-11-17 11:54:21.000000000 +0000
+++ linux-2.4.32.new/drivers/net/wireless/Config.in	2005-12-24 21:28:51.898660256 +0000
@@ -38,7 +38,8 @@
 
 # yes, this works even when no drivers are selected
 if [ "$CONFIG_ISA" = "y" -o "$CONFIG_PCI" = "y" -o \
-     "$CONFIG_ALL_PPC" = "y" -o "$CONFIG_PCMCIA" != "n" ]; then
+     "$CONFIG_ALL_PPC" = "y" -o "$CONFIG_PCMCIA" != "n" -o \
+     "$CONFIG_NET_WIRELESS" = "y" ]; then
    define_bool CONFIG_NET_WIRELESS y
 else
    define_bool CONFIG_NET_WIRELESS n
diff -urN linux-2.4.32/include/asm-mips/atheros/ar531xbsp.h linux-2.4.32.new/include/asm-mips/atheros/ar531xbsp.h
--- linux-2.4.32/include/asm-mips/atheros/ar531xbsp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32.new/include/asm-mips/atheros/ar531xbsp.h	2005-12-24 20:29:06.898663096 +0000
@@ -0,0 +1,16 @@
+#ifndef __ASM_ATHEROS_BSP_SUPPORT_H
+#define __ASM_ATHEROS_BSP_SUPPORT_H
+/*
+ * These are definitions and functions provided by the bsp to support the
+ * AR5312 WiSoC running LSDK.  For different BSP implementations, different
+ * BSP functions will be needed.
+ */
+
+extern unsigned int ar531x_sys_frequency(void);
+
+#ifdef CONFIG_KGDB
+extern  void kgdbInit(void);
+extern int kgdbEnabled(void);
+#endif
+
+#endif /* __ASM_ATHEROS_BSP_SUPPORT_H */
diff -urN linux-2.4.32/include/asm-mips/bootinfo.h linux-2.4.32.new/include/asm-mips/bootinfo.h
--- linux-2.4.32/include/asm-mips/bootinfo.h	2005-12-24 16:08:53.000000000 +0000
+++ linux-2.4.32.new/include/asm-mips/bootinfo.h	2005-12-24 21:28:51.899660104 +0000
@@ -37,6 +37,7 @@
 #define MACH_GROUP_HP_LJ       20 /* Hewlett Packard LaserJet               */
 #define MACH_GROUP_LASAT       21
 #define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
+#define MACH_GROUP_AR531X      23 /* Atheros AR531X                         */
 
 /*
  * Valid machtype values for group unknown (low order halfword of mips_machtype)
@@ -201,6 +202,17 @@
  */
 #define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
 
+/*
+ * Valid machtype for group MACH_GROUP_AR5312
+ */
+#define MACH_ATHEROS_UNUSED     0
+#define MACH_ATHEROS_AP30       1       /* AP30 */
+#define MACH_ATHEROS_AP33	2       /* AP33 */
+#define MACH_ATHEROS_AP38       3       /* AP38 */
+#define MACH_ATHEROS_AP43       4       /* AP43 */
+#define MACH_ATHEROS_AP48       5       /* AP48 */
+#define MACH_ATHEROS_PB32       6       /* PB32 */
+
 #define CL_SIZE			(256)
 
 const char *get_system_type(void);
diff -urN linux-2.4.32/include/asm-mips/serial.h linux-2.4.32.new/include/asm-mips/serial.h
--- linux-2.4.32/include/asm-mips/serial.h	2005-01-19 14:10:12.000000000 +0000
+++ linux-2.4.32.new/include/asm-mips/serial.h	2005-12-24 21:28:51.901659800 +0000
@@ -467,6 +467,11 @@
 #define DDB5477_SERIAL_PORT_DEFNS
 #endif
 
+#if defined(CONFIG_AR531X)
+#undef RS_TABLE_SIZE
+#define RS_TABLE_SIZE 1
+#endif
+
 #define SERIAL_PORT_DFNS			\
 	ATLAS_SERIAL_PORT_DEFNS			\
 	AU1000_SERIAL_PORT_DEFNS		\
diff -urN linux-2.4.32/kernel/printk.c linux-2.4.32.new/kernel/printk.c
--- linux-2.4.32/kernel/printk.c	2004-11-17 11:54:22.000000000 +0000
+++ linux-2.4.32.new/kernel/printk.c	2005-12-24 21:28:51.929655544 +0000
@@ -384,6 +384,18 @@
 	_call_console_drivers(start_print, end, msg_level);
 }
 
+#if CONFIG_EARLY_PRINTK_HACK
+void putDebugChar(char byte);
+static void emit_log_char(char c)
+{
+	if (c == '\n') {
+		putDebugChar('\r');
+		putDebugChar('\n');
+	} else {
+		putDebugChar(c);
+	}
+}
+#else
 static void emit_log_char(char c)
 {
 	LOG_BUF(log_end) = c;
@@ -395,6 +407,7 @@
 	if (logged_chars < LOG_BUF_LEN)
 		logged_chars++;
 }
+#endif
 
 /*
  * This is printk.  It can be called from any context.  We want it to work.
@@ -700,3 +713,4 @@
 		tty->driver.write(tty, 0, msg, strlen(msg));
 	return;
 }
+
