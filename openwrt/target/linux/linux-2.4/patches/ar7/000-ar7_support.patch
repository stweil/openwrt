diff -urN kernel-base/arch/mips/ar7/ar7/ar7_jump.S kernel-tmp2/arch/mips/ar7/ar7/ar7_jump.S
--- kernel-base/arch/mips/ar7/ar7/ar7_jump.S	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/ar7/ar7_jump.S	2005-07-10 06:40:39.582267168 +0200
@@ -0,0 +1,89 @@
+/*
+ * $Id$
+ * Copyright (C) $Date$  $Author$
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/threads.h>
+
+#include <asm/asm.h>
+#include <asm/cacheops.h>
+#include <asm/current.h>
+#include <asm/offset.h>
+#include <asm/processor.h>
+#include <asm/regdef.h>
+#include <asm/cachectl.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+
+.text
+
+.set noreorder
+.set noat
+
+/* TLB Miss Vector */
+
+LEAF(jump_tlb_miss)
+	.set mips2
+	lui     k0,0x9400
+	ori     k0,0
+	jr	k0
+	nop       
+END(jump_tlb_miss)
+
+	/* Unused TLB Miss Vector */
+
+LEAF(jump_tlb_miss_unused)
+	.set mips2
+	lui     k0,0x9400
+	ori     k0,0x80
+	jr	k0
+	nop       
+END(jump_tlb_miss_unused)
+
+	/* Cache Error Vector */
+
+LEAF(jump_cache_error)
+	.set mips2
+	lui     k0,0x9400
+	ori     k0,0x100
+	jr	k0
+	nop       
+END(jump_cache_error)
+
+	/* General Exception */
+
+LEAF(jump_general_exception)
+	.set mips2
+	lui     k0,0x9400
+	ori     k0,0x180
+	jr	k0
+	nop
+END(jump_general_exception)
+
+	/* Dedicated Interrupt */
+
+LEAF(jump_dedicated_interrupt)
+	.set mips2
+	lui     k0,0x9400
+	ori     k0,0x200
+	jr	k0
+	nop       
+END(jump_dedicated_interrupt)
+
+	.set at
diff -urN kernel-base/arch/mips/ar7/ar7/ar7_paging.c kernel-tmp2/arch/mips/ar7/ar7/ar7_paging.c
--- kernel-base/arch/mips/ar7/ar7/ar7_paging.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/ar7/ar7_paging.c	2005-07-10 07:08:33.725758672 +0200
@@ -0,0 +1,314 @@
+/*
+ *  -*- linux-c -*-
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002 by Jeff Harrell (jharrell@ti.com)
+ * Copyright (C) 2002 Texas Instruments, Inc.
+ *
+ */
+
+/*
+ * This file takes care of the "memory hole" issue that exists with the standard
+ * linux kernel and the TI Avalanche ASIC.  The Avalanche ASIC requires an offset
+ * of 0x14000000 due to the ASIC's memory map constraints.  This file corrects the
+ * paging tables so that the only reflect valid memory (i.e. > 0x14000000)
+ * 
+ *  -JAH
+ */
+#include <linux/config.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#ifdef CONFIG_BLK_DEV_INITRD
+#include <linux/blk.h>
+#endif /* CONFIG_BLK_DEV_INITRD */
+#include <linux/highmem.h>
+#include <linux/bootmem.h>
+
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/mmu_context.h>
+#include <asm/io.h>
+#include <asm/tlb.h>
+#include <asm/cpu.h>
+
+#define __MEMORY_START CONFIG_AR7_MEMORY
+
+#ifdef CONFIG_DISCONTIGMEM
+pg_data_t discontig_page_data[NR_NODES];
+bootmem_data_t discontig_node_bdata[NR_NODES];
+#endif
+
+static unsigned long totalram_pages;
+/* static unsigned long totalhigh_pages; */
+
+#define START_PFN (NODE_DATA(0)->bdata->node_boot_start >> PAGE_SHIFT)
+#define MAX_LOW_PFN (NODE_DATA(0)->bdata->node_low_pfn)
+
+#define PFN_UP(x)  (((x) + PAGE_SIZE - 1) >> PAGE_SHIFT)
+#define PFN_DOWN(x)        ((x) >> PAGE_SHIFT)
+#define PFN_PHYS(x)        ((x) << PAGE_SHIFT)
+
+unsigned long bootmap_size;
+
+extern char *prom_getenv(char *envname);
+
+/*
+ * We have upto 8 empty zeroed pages so we can map one of the right colour
+ * when needed.  This is necessary only on R4000 / R4400 SC and MC versions
+ * where we have to avoid VCED / VECI exceptions for good performance at
+ * any price.  Since page is never written to after the initialization we
+ * don't have to care about aliases on other CPUs.
+ */
+
+static inline unsigned long setup_zero_pages(void)
+{
+	unsigned long order, size;
+	struct page *page;
+	if(current_cpu_data.options & MIPS_CPU_VCE) 
+		order = 3;
+	else 
+		order = 0;
+
+	empty_zero_page = __get_free_pages(GFP_KERNEL, order);
+
+	if (!empty_zero_page)
+		panic("Oh boy, that early out of memory?");
+
+	page = virt_to_page(empty_zero_page);
+
+	while (page < virt_to_page(empty_zero_page + (PAGE_SIZE << order))) {
+		set_bit(PG_reserved, &page->flags);
+		set_page_count(page, 0);
+		page++;
+	}
+
+	size = PAGE_SIZE << order;
+	zero_page_mask = (size - 1) & PAGE_MASK;
+	memset((void *)empty_zero_page, 0, size);
+
+	return 1UL << order;
+}
+
+/*
+ * paging_init() sets up the page tables
+ *
+ * This routines also unmaps the page at virtual kernel address 0, so
+ * that we can trap those pesky NULL-reference errors in the kernel.
+ */
+void __init paging_init(void)
+{
+	unsigned long zones_size[MAX_NR_ZONES] = {0, 0, 0};
+	unsigned long low, start_pfn;
+
+	/* Initialize the entire pgd.  */
+	pgd_init((unsigned long)swapper_pg_dir);
+	pgd_init((unsigned long)swapper_pg_dir + PAGE_SIZE / 2);
+
+
+	start_pfn = START_PFN;
+	// max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
+	low = MAX_LOW_PFN;
+
+	/* Avalanche DMA-able memory 0x14000000+memsize */
+
+	zones_size[ZONE_DMA] = low - start_pfn;
+
+	free_area_init_node(0, NODE_DATA(0), 0, zones_size, __MEMORY_START, 0);
+
+#ifdef CONFIG_DISCONTIGMEM
+	zones_size[ZONE_DMA] = __MEMORY_SIZE_2ND >> PAGE_SHIFT;
+	zones_size[ZONE_NORMAL] = 0;
+	free_area_init_node(1, NODE_DATA(1), 0, zones_size, __MEMORY_START_2ND, 0);
+#endif /* CONFIG_DISCONTIGMEM */
+
+}
+
+extern char _ftext, _etext, _fdata, _edata, _end;
+extern char __init_begin, __init_end;
+
+void __init mem_init(void)
+{
+	int codesize, reservedpages, datasize, initsize;
+	int tmp;
+	
+	max_mapnr = num_physpages = MAX_LOW_PFN - START_PFN;
+	high_memory = (void *)__va(MAX_LOW_PFN * PAGE_SIZE);
+
+	/* free up the memory associated with Adam2 -
+	 * that is the, after the first page that is 
+	 * reserved all the way up to the start of the kernel
+	 */
+	free_bootmem_node(NODE_DATA(0), (__MEMORY_START+PAGE_SIZE),
+			(__pa(&_ftext))-(__MEMORY_START+PAGE_SIZE) );
+
+	/* this will put all low memory onto the freelists */
+	totalram_pages += free_all_bootmem_node(NODE_DATA(0));
+
+	/* Setup zeroed pages */
+	totalram_pages -= setup_zero_pages();	
+
+
+#ifdef CONFIG_DISCONTIGMEM
+	totalram_pages += free_all_bootmem_node(NODE_DATA(1));
+#endif
+	reservedpages = 0;
+	for (tmp = 0; tmp < num_physpages; tmp++)
+		/*
+		 * Only count reserved RAM pages
+		 */
+		if (PageReserved(mem_map+tmp))
+			reservedpages++;
+
+	codesize =  (unsigned long) &_etext - (unsigned long) &_ftext;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_fdata;
+	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
+
+	printk("Memory: %luk/%luk available (%dk kernel code, %dk reserved, %dk data, %dk init)\n",
+			(unsigned long) nr_free_pages() << (PAGE_SHIFT-10),
+			max_mapnr << (PAGE_SHIFT-10),
+			codesize >> 10,
+			reservedpages << (PAGE_SHIFT-10),
+			datasize >> 10,
+			initsize >> 10);
+
+}
+
+/* fixes paging routines for avalanche  (utilized in /arch/mips/kernel/setup.c) */
+
+void avalanche_bootmem_init(void)
+{
+	unsigned long start_pfn, max_pfn;
+	unsigned long max_low_pfn;
+	unsigned int memsize,memory_end,memory_start;
+	char *memsize_str;
+
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x02000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+
+
+	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
+	memory_end = memory_start + memsize;
+
+	/*
+	 * Find the highest memory page fram number we have available 
+	 */
+
+	max_pfn = PFN_DOWN(__pa(memory_end));
+
+	/*
+	 * Determine the low and high memory ranges 
+	 */
+
+	max_low_pfn = max_pfn;
+
+	/*
+	 * Partially used pages are not usable - thus we are
+	 * rounding upwards:
+	 */
+
+	start_pfn = PFN_UP(__pa(&_end));
+
+	/*
+	 * Find a proper area for the bootmem bitmap. After this
+	 * bootstrap step all allocations (until the page allocator is
+	 * intact)  must be done via bootmem_alloc().
+	 */
+
+	bootmap_size = init_bootmem_node(NODE_DATA(0), start_pfn,
+			__MEMORY_START>>PAGE_SHIFT, max_low_pfn);
+
+
+	/* 
+	 * Register fully available low RAM pages with the bootmem allocator.
+	 */
+
+	{
+		unsigned long curr_pfn, last_pfn, pages;
+
+		/*
+		 * We are rounding up the start address of usable memory:
+		 */
+		curr_pfn = PFN_UP(__MEMORY_START);
+
+		/*
+		 * ... and at the end of the usable range downwards:
+		 */
+		last_pfn = PFN_DOWN(__pa(memory_end));
+
+		if (last_pfn > max_low_pfn)
+			last_pfn = max_low_pfn;
+
+		pages = last_pfn - curr_pfn;
+
+
+		free_bootmem_node(NODE_DATA(0), PFN_PHYS(curr_pfn),
+				PFN_PHYS(pages));
+	}
+
+	/*
+	 * Reserve the kernel text and
+	 * Reserve the bootmem bitmap. We do this in two steps (first step
+	 * was init_bootmem()), because this catches the (definitely buggy)
+	 * case of us accidentally initializing the bootmem allocator with
+	 * an invalid RAM area.
+	 */
+	reserve_bootmem_node(NODE_DATA(0), __MEMORY_START+PAGE_SIZE,
+			(PFN_PHYS(start_pfn)+bootmap_size+PAGE_SIZE-1)-__MEMORY_START);
+
+	/*
+	 * reserve physical page 0 - it's a special BIOS page on many boxes,
+	 * enabling clean reboots, SMP operation, laptop functions.
+	 */
+	reserve_bootmem_node(NODE_DATA(0), __MEMORY_START, PAGE_SIZE);
+}
+
+extern char __init_begin, __init_end;
+
+void free_initmem(void)
+{
+	unsigned long addr;
+	//	prom_free_prom_memory ();
+
+	addr = (unsigned long) &__init_begin;
+	while (addr < (unsigned long) &__init_end) {
+		ClearPageReserved(virt_to_page(addr));
+		set_page_count(virt_to_page(addr), 1);
+		free_page(addr);
+		totalram_pages++;
+		addr += PAGE_SIZE;
+	}
+	printk("Freeing unused kernel memory: %dk freed\n",
+			(&__init_end - &__init_begin) >> 10);
+}
+
+void si_meminfo(struct sysinfo *val)
+{
+	val->totalram = totalram_pages;
+	val->sharedram = 0;
+	val->freeram = nr_free_pages();
+	val->bufferram = atomic_read(&buffermem_pages);
+	val->totalhigh = 0;
+	val->freehigh = nr_free_highpages();
+	val->mem_unit = PAGE_SIZE;
+
+	return;
+}
diff -urN kernel-base/arch/mips/ar7/ar7/Makefile kernel-tmp2/arch/mips/ar7/ar7/Makefile
--- kernel-base/arch/mips/ar7/ar7/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/ar7/Makefile	2005-07-10 06:40:39.583267016 +0200
@@ -0,0 +1,30 @@
+# $Id$
+# Copyright (C) $Date$  $Author$
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+.S.s:
+	$(CPP) $(AFLAGS) $< -o $*.s
+
+.S.o:
+	$(CC) $(AFLAGS) -c $< -o $*.o
+
+EXTRA_CFLAGS := -DLITTLE_ENDIAN -D_LINK_KSEG0_
+
+O_TARGET := ar7.o
+
+obj-y += ar7_paging.o ar7_jump.o
+
+include $(TOPDIR)/Rules.make
diff -urN kernel-base/arch/mips/ar7/cmdline.c kernel-tmp2/arch/mips/ar7/cmdline.c
--- kernel-base/arch/mips/ar7/cmdline.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/cmdline.c	2005-07-10 06:40:39.584266864 +0200
@@ -0,0 +1,64 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Kernel command line creation using the prom monitor (YAMON) argc/argv.
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+
+extern int prom_argc;
+extern int *_prom_argv;
+
+/*
+ * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+ * This macro take care of sign extension.
+ */
+#define prom_argv(index) ((char *)(((int *)(int)_prom_argv)[(index)]))
+
+char arcs_cmdline[CL_SIZE];
+
+char * __init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+
+void  __init prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+#ifdef CONFIG_CMDLINE_BOOL
+	strcpy(cp, CONFIG_CMDLINE);
+	cp += strlen(CONFIG_CMDLINE);
+	*cp++ = ' ';
+#endif
+	while(actr < prom_argc) {
+		strcpy(cp, prom_argv(actr));
+		cp += strlen(prom_argv(actr));
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	*cp = '\0';
+}
diff -urN kernel-base/arch/mips/ar7/init.c kernel-tmp2/arch/mips/ar7/init.c
--- kernel-base/arch/mips/ar7/init.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/init.c	2005-07-10 06:40:39.584266864 +0200
@@ -0,0 +1,146 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * PROM library initialisation code.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/mips-boards/prom.h>
+#include <asm/mips-boards/generic.h>
+
+/* Environment variable */
+typedef struct {
+	char *name;
+	char *val;
+} t_env_var;
+
+int prom_argc;
+int *_prom_argv, *_prom_envp;
+
+/* max # of Adam2 environment variables */
+#define MAX_ENV_ENTRY 80
+
+static t_env_var local_envp[MAX_ENV_ENTRY];
+int init_debug = 0;
+
+char *prom_getenv(char *envname)
+{
+	/*
+	 * Return a pointer to the given environment variable.
+	 * In 64-bit mode: we're using 64-bit pointers, but all pointers
+	 * in the PROM structures are only 32-bit, so we need some
+	 * workarounds, if we are running in 64-bit mode.
+	 */
+	int i, index=0;
+	t_env_var *env = (t_env_var *) local_envp;
+
+	i = strlen(envname);
+	while (env->name) {
+		if(strncmp(envname, env->name, i) == 0) {
+			return(env->val);
+		}
+		env++;
+	}
+
+	return NULL;
+}
+
+static inline unsigned char str2hexnum(unsigned char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	return 0; /* foo */
+}
+
+static inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+	char *ethaddr_str;
+
+	ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+		printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+
+	if (init_debug > 1) {
+		int i;
+		printk("get_ethernet_addr: ");
+		for (i=0; i<5; i++)
+			printk("%02x:", (unsigned char)*(ethernet_addr+i));
+		printk("%02x\n", *(ethernet_addr+i));
+	}
+
+	return 0;
+}
+
+int __init prom_init(int argc, char **argv, char **envp)
+{
+	int i;
+	t_env_var *env = (t_env_var *) envp;
+
+	prom_argc = argc;
+	_prom_argv = (int *)argv;
+	_prom_envp = (int *)envp;
+
+	/* Copy what we need locally so we are not dependent on
+	 * bootloader RAM.  In Adam2, the environment parameters
+	 * are in flash but the table that references them is in
+	 * RAM
+	 */
+	for(i=0; i < MAX_ENV_ENTRY; i++, env++) {
+		if (env->name) {
+			local_envp[i].name = env->name;
+			local_envp[i].val = env->val;
+		} else {
+			local_envp[i].name = NULL;
+			local_envp[i].val = NULL;
+		}
+	}
+
+	set_io_port_base(0);
+
+	prom_printf("\nLINUX started...\n");
+	prom_init_cmdline();
+	prom_meminit();
+
+	return 0;
+}
+
+EXPORT_SYMBOL(prom_getenv);
diff -urN kernel-base/arch/mips/ar7/irq.c kernel-tmp2/arch/mips/ar7/irq.c
--- kernel-base/arch/mips/ar7/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/irq.c	2005-07-10 06:40:39.585266712 +0200
@@ -0,0 +1,664 @@
+/*
+ * Nitin Dhingra, iamnd@ti.com
+ * Copyright (C) 2002 Texas Instruments, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Routines for generic manipulation of the interrupts found on the Texas
+ * Instruments avalanche board
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/proc_fs.h>
+#include <asm/irq.h>
+#include <asm/mips-boards/prom.h>
+#include <asm/ar7/ar7.h>
+#include <asm/ar7/avalanche_intc.h>
+#include <asm/gdb-stub.h>
+
+
+#define shutdown_avalanche_irq	disable_avalanche_irq
+#define mask_and_ack_avalanche_irq   disable_avalanche_irq
+
+static unsigned int startup_avalanche_irq(unsigned int irq);
+static void end_avalanche_irq(unsigned int irq);
+void enable_avalanche_irq(unsigned int irq_nr);
+void disable_avalanche_irq(unsigned int irq_nr);
+
+static struct hw_interrupt_type avalanche_irq_type = {
+	"TI AVALANCHE",
+	startup_avalanche_irq,
+	shutdown_avalanche_irq,
+	enable_avalanche_irq,
+	disable_avalanche_irq,
+	mask_and_ack_avalanche_irq,
+	end_avalanche_irq,
+	NULL
+};
+
+irq_desc_t irq_desc_ti[AVALANCHE_INT_END+1] __cacheline_aligned =
+{ [0 ... AVALANCHE_INT_END] = { 0, &avalanche_irq_type, NULL, 0, SPIN_LOCK_UNLOCKED}};
+
+
+unsigned long spurious_count = 0;
+
+struct avalanche_ictrl_regs         *avalanche_hw0_icregs;  /* Interrupt control regs (primary)   */
+struct avalanche_exctrl_regs        *avalanche_hw0_ecregs;  /* Exception control regs (secondary) */
+struct avalanche_ipace_regs         *avalanche_hw0_ipaceregs;
+struct avalanche_channel_int_number *avalanche_hw0_chregs;  /* Channel control registers          */
+
+extern asmlinkage void mipsIRQ(void);
+
+
+/*
+ *   The avalanche/MIPS interrupt line numbers are used to represent the
+ *   interrupts within the irqaction arrays.  The index notation is
+ *   is as follows:
+ *
+ *           0-7    MIPS CPU Exceptions  (HW/SW)
+ *           8-47   Primary Interrupts   (Avalanche)
+ *           48-79  Secondary Interrupts (Avalanche)
+ *
+ */
+
+
+static struct irqaction *hw0_irq_action_primary[AVINTNUM(AVALANCHE_INT_END_PRIMARY)] =
+{
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL
+};
+
+static struct irqaction *hw0_irq_action_secondary[AVINTNUM(AVALANCHE_INT_END_SECONDARY)] =
+{
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL
+};
+
+/*
+   This remaps interrupts to exist on other channels than the default
+   channels.  essentially we can use the line # as the index for this
+   array
+ */
+
+
+static unsigned long line_to_channel[AVINTNUM(AVALANCHE_INT_END_PRIMARY)];
+unsigned long uni_secondary_interrupt = 0;
+
+static struct irqaction r4ktimer_action = {
+	NULL, 0, 0, "R4000 timer/counter", NULL, NULL,
+};
+
+static struct irqaction *irq_action[8] = {
+	NULL,              /* SW int 0 */
+	NULL,              /* SW int 1 */
+	NULL,              /* HW int 0 */
+	NULL,
+	NULL,
+	NULL,              /* HW int 3 */
+	NULL,              /* HW int 4 */
+	&r4ktimer_action   /* HW int 5 */
+};
+
+static void end_avalanche_irq(unsigned int irq)
+{
+	if (!(irq_desc_ti[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_avalanche_irq(irq);
+}
+
+void disable_avalanche_irq(unsigned int irq_nr)
+{
+	unsigned long flags;
+	unsigned long chan_nr=0;
+	unsigned long int_bit=0;
+
+	if(irq_nr >= AVALANCHE_INT_END)
+	{
+		printk("whee, invalid irq_nr %d\n", irq_nr);
+		panic("IRQ, you lose...");
+	}
+
+	save_and_cli(flags);
+
+
+	if(irq_nr <  MIPS_EXCEPTION_OFFSET)
+	{
+		/* disable mips exception */
+
+		int_bit = read_c0_status() & ~(1 << (8+irq_nr));
+		change_c0_status(ST0_IM,int_bit);
+		restore_flags(flags);
+		return;
+	}
+
+	/* irq_nr represents the line number for the interrupt.  We must
+	 *  disable the channel number associated with that line number.
+	 */
+
+	if(irq_nr > AVALANCHE_INT_END_PRIMARY_REG2)
+		chan_nr = AVINTNUM(irq_nr);                 /*CHECK THIS ALSO*/
+	else
+		chan_nr = line_to_channel[AVINTNUM(irq_nr)];/* WE NEED A LINE TO CHANNEL MAPPING FUNCTION HERE*/
+
+	/* disable the interrupt channel bit */
+
+	/* primary interrupt #'s 0-31 */
+
+	if(chan_nr <= AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG1))
+		avalanche_hw0_icregs->intecr1 = (1 << chan_nr);
+
+	/* primary interrupt #'s 32-39 */
+
+	else if ((chan_nr <= AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG2)) &&
+			(chan_nr > AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG1)))
+		avalanche_hw0_icregs->intecr2 = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_SECONDARY)));
+
+	else  /* secondary interrupt #'s 0-31 */
+		avalanche_hw0_ecregs->exiecr = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_PRIMARY)));
+
+	restore_flags(flags);
+}
+
+void enable_avalanche_irq(unsigned int irq_nr)
+{
+	unsigned long flags;
+	unsigned long chan_nr=0;
+	unsigned long int_bit=0;
+
+	if(irq_nr > AVALANCHE_INT_END) {
+		printk("whee, invalid irq_nr %d\n", irq_nr);
+		panic("IRQ, you lose...");
+	}
+
+	save_and_cli(flags);
+
+
+	if(irq_nr <  MIPS_EXCEPTION_OFFSET)
+	{
+		/* Enable MIPS exceptions */
+		int_bit = read_c0_status();
+		change_c0_status(ST0_IM,int_bit | (1<<(8+irq_nr)));
+		restore_flags(flags);
+		return;
+	}
+
+	/* irq_nr represents the line number for the interrupt.  We must
+	 *  disable the channel number associated with that line number.
+	 */
+
+	if(irq_nr > AVALANCHE_INT_END_PRIMARY_REG2)
+		chan_nr = AVINTNUM(irq_nr);
+	else
+		chan_nr = line_to_channel[AVINTNUM(irq_nr)];
+
+	/* enable the interrupt channel  bit */
+
+	/* primary interrupt #'s 0-31 */
+	if(chan_nr <= AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG1))
+		avalanche_hw0_icregs->intesr1 = (1 << chan_nr);
+
+	/* primary interrupt #'s 32 throuth 39 */
+	else if ((chan_nr <= AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG2)) &&
+			(chan_nr > AVINTNUM(AVALANCHE_INT_END_PRIMARY_REG1)))
+		avalanche_hw0_icregs->intesr2 = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_SECONDARY)));
+
+	else    /* secondary interrupt #'s 0-31 */
+		avalanche_hw0_ecregs->exiesr = (1 << (chan_nr - AVINTNUM(AVALANCHE_INT_END_PRIMARY)));
+
+	restore_flags(flags);
+}
+
+static unsigned int startup_avalanche_irq(unsigned int irq)
+{
+	enable_avalanche_irq(irq);
+	return 0; /* never anything pending */
+}
+
+
+int get_irq_list(char *buf)
+{
+	int i, len = 0;
+	int num = 0;
+	struct irqaction *action;
+
+	for (i = 0; i < MIPS_EXCEPTION_OFFSET; i++, num++)
+	{
+		action = irq_action[i];
+		if (!action)
+			continue;
+		len += sprintf(buf+len, "%2d: %8d %c %s",
+				num, kstat.irqs[0][num],
+				(action->flags & SA_INTERRUPT) ? '+' : ' ',
+				action->name);
+		for (action=action->next; action; action = action->next) {
+			len += sprintf(buf+len, ",%s %s",
+					(action->flags & SA_INTERRUPT) ? " +" : "",
+					action->name);
+		}
+		len += sprintf(buf+len, " [MIPS interrupt]\n");
+	}
+
+
+	for (i = 0; i < AVINTNUM(AVALANCHE_INT_END); i++,num++)
+	{
+		if(i < AVINTNUM(AVALANCHE_INT_END_PRIMARY))
+			action = hw0_irq_action_primary[i];
+		else
+			action = hw0_irq_action_secondary[i-AVINTNUM(AVALANCHE_INT_END_PRIMARY)];
+		if (!action)
+			continue;
+		len += sprintf(buf+len, "%2d: %8d %c %s",
+				num, kstat.irqs[0][ LNXINTNUM(i) ],
+				(action->flags & SA_INTERRUPT) ? '+' : ' ',
+				action->name);
+
+		for (action=action->next; action; action = action->next)
+		{
+			len += sprintf(buf+len, ",%s %s",
+					(action->flags & SA_INTERRUPT) ? " +" : "",
+					action->name);
+		}
+
+		if(i < AVINTNUM(AVALANCHE_INT_END_PRIMARY))
+			len += sprintf(buf+len, " [hw0 (Avalanche Primary)]\n");
+		else
+			len += sprintf(buf+len, " [hw0 (Avalanche Secondary)]\n");
+
+	}
+
+	return len;
+}
+
+int request_irq(unsigned int irq,
+		void (*handler)(int, void *, struct pt_regs *),
+		unsigned long irqflags,
+		const char * devname,
+		void *dev_id)
+{
+	struct irqaction *action;
+
+	if (irq >  AVALANCHE_INT_END)
+		return -EINVAL;
+	if (!handler)
+		return -EINVAL;
+
+	action = (struct irqaction *)kmalloc(sizeof(struct irqaction), GFP_KERNEL);
+	if(!action)
+		return -ENOMEM;
+
+	action->handler = handler;
+	action->flags = irqflags;
+	action->mask = 0;
+	action->name = devname;
+	irq_desc_ti[irq].action = action;
+	action->dev_id = dev_id;
+
+	action->next = 0;
+
+	if(irq <  MIPS_EXCEPTION_OFFSET)
+	{
+		irq_action[irq] = action;
+		enable_avalanche_irq(irq);
+		return 0;
+	}
+
+	if(irq < AVALANCHE_INT_END_PRIMARY)
+		hw0_irq_action_primary[line_to_channel[AVINTNUM(irq)]] = action;
+	else
+		hw0_irq_action_secondary[irq - AVALANCHE_INT_END_PRIMARY] = action;
+
+	enable_avalanche_irq(irq);
+
+	return 0;
+}
+
+void free_irq(unsigned int irq, void *dev_id)
+{
+	struct irqaction *action;
+
+	if (irq > AVALANCHE_INT_END) {
+		printk("Trying to free IRQ%d\n",irq);
+		return;
+	}
+
+	if(irq <  MIPS_EXCEPTION_OFFSET)
+	{
+		action = irq_action[irq];
+		irq_action[irq] = NULL;
+		irq_desc_ti[irq].action = NULL;
+		disable_avalanche_irq(irq);
+		kfree(action);
+		return;
+	}
+
+	if(irq < AVALANCHE_INT_END_PRIMARY) {
+		action = hw0_irq_action_primary[line_to_channel[AVINTNUM(irq)]];
+		hw0_irq_action_primary[line_to_channel[AVINTNUM(irq)]] = NULL;
+		irq_desc_ti[irq].action = NULL;
+	}
+	else {
+		action = hw0_irq_action_secondary[irq - AVALANCHE_INT_END_PRIMARY];
+		hw0_irq_action_secondary[irq - AVALANCHE_INT_END_PRIMARY] = NULL;
+		irq_desc_ti[irq].action = NULL;
+	}
+
+	disable_avalanche_irq(irq);
+	kfree(action);
+}
+
+#ifdef CONFIG_KGDB
+extern void breakpoint(void);
+extern int remote_debug;
+#endif
+
+//void init_IRQ(void) __init;
+void __init init_IRQ(void)
+{
+	int i;
+
+	avalanche_hw0_icregs = (struct avalanche_ictrl_regs *)AVALANCHE_ICTRL_REGS_BASE;
+	avalanche_hw0_ecregs = (struct avalanche_exctrl_regs *)AVALANCHE_ECTRL_REGS_BASE;
+	avalanche_hw0_ipaceregs = (struct avalanche_ipace_regs *)AVALANCHE_IPACE_REGS_BASE;
+	avalanche_hw0_chregs = (struct avalanche_channel_int_number *)AVALANCHE_CHCTRL_REGS_BASE;
+
+	/*  Disable interrupts and clear pending
+	 */
+
+	avalanche_hw0_icregs->intecr1 = 0xffffffff;    /* disable interrupts 0:31  */
+	avalanche_hw0_icregs->intcr1 = 0xffffffff;     /* clear interrupts 0:31    */
+	avalanche_hw0_icregs->intecr2 = 0xff;          /* disable interrupts 32:39 */
+	avalanche_hw0_icregs->intcr2 = 0xff;           /* clear interrupts 32:39   */
+	avalanche_hw0_ecregs->exiecr = 0xffffffff;     /* disable secondary interrupts 0:31 */
+	avalanche_hw0_ecregs->excr = 0xffffffff;       /* clear secondary interrupts 0:31 */
+
+
+	/* Channel to line mapping, Line to Channel mapping */
+
+	for(i = 0; i < 40; i++)
+		avalanche_int_set(i,i);
+
+	/* Now safe to set the exception vector. */
+	set_except_vector(0, mipsIRQ);
+
+	/* Setup the IRQ description array.  These will be mapped
+	 *  as flat interrupts numbers.  The mapping is as follows
+	 *
+	 *           0-7    MIPS CPU Exceptions  (HW/SW)
+	 *           8-46   Primary Interrupts   (Avalanche)
+	 *           47-78  Secondary Interrupts (Avalanche)
+	 */
+
+	for (i = 0; i <= AVALANCHE_INT_END; i++)
+	{
+		irq_desc_ti[i].status	= IRQ_DISABLED;
+		irq_desc_ti[i].action	= 0;
+		irq_desc_ti[i].depth	= 1;
+		irq_desc_ti[i].handler	= &avalanche_irq_type;
+	}
+
+#ifdef CONFIG_KGDB
+	if (remote_debug)
+	{
+		set_debug_traps();
+		breakpoint();
+	}
+#endif
+}
+
+
+void avalanche_hw0_irqdispatch(struct pt_regs *regs)
+{
+	struct irqaction *action;
+	int irq, cpu = smp_processor_id();
+	unsigned long int_line_number,status;
+	int i,secondary = 0;
+	int chan_nr=0;
+
+	int_line_number = ((avalanche_hw0_icregs->pintir >> 16) & 0x3F);
+	chan_nr = ((avalanche_hw0_icregs->pintir) & 0x3F);
+
+
+	if(chan_nr < 32)
+	{
+		if( chan_nr != uni_secondary_interrupt)
+			avalanche_hw0_icregs->intcr1 = (1<<chan_nr);
+
+	}
+
+	if((chan_nr < 40) && (chan_nr > 31))
+	{
+		avalanche_hw0_icregs->intcr2 = (1<<(chan_nr-AVINTNUM(AVALANCHE_INT_END_SECONDARY)));
+	}
+
+
+	/* If the Priority Interrupt Index Register returns 40  then no
+	 * interrupts are pending
+	 */
+
+	if(chan_nr == 40)
+		return;
+
+	if(chan_nr == uni_secondary_interrupt)
+	{
+		status = avalanche_hw0_ecregs->exsr;
+		for(i=0; i < AVINTNUM(AVALANCHE_INT_END_SECONDARY); i++)
+		{
+			if (status & 1<<i)
+			{
+				/* clear secondary interrupt */
+				avalanche_hw0_ecregs->excr = 1 << i;
+				break;
+			}
+		}
+		irq = i;
+		secondary = 1;
+
+		/* clear the universal secondary interrupt */
+		avalanche_hw0_icregs->intcr1 = 1 << uni_secondary_interrupt;
+
+	}
+	else
+		irq = chan_nr;
+
+	/* Suraj Add code to clear secondary interrupt */
+
+	if(secondary)
+		action = hw0_irq_action_secondary[irq];
+	else
+		action = hw0_irq_action_primary[irq];
+
+	/* if action == NULL, then we don't have a handler for the irq */
+
+	if ( action == NULL ) {
+		printk("No handler for hw0 irq: %i\n", irq);
+		return;
+	}
+
+	irq_enter(cpu,irq);
+	if(secondary)
+	{
+		kstat.irqs[0][(irq + AVINTNUM(AVALANCHE_INT_END_PRIMARY)) + 8]++;
+		action->handler((irq + AVALANCHE_INT_END_PRIMARY), action->dev_id, regs);
+	}
+	else
+	{
+		kstat.irqs[0][irq + 8]++;
+		action->handler(LNXINTNUM(irq), action->dev_id, regs);
+	}
+
+	irq_exit(cpu,irq);
+
+	if(softirq_pending(cpu))
+		do_softirq();
+
+	return;
+}
+
+void avalanche_int_set(int channel, int line)
+{
+	switch(channel)
+	{
+		case(0):
+			avalanche_hw0_chregs->cintnr0 =  line;
+			break;
+		case(1):
+			avalanche_hw0_chregs->cintnr1 =  line;
+			break;
+		case(2):
+			avalanche_hw0_chregs->cintnr2 =  line;
+			break;
+		case(3):
+			avalanche_hw0_chregs->cintnr3 =  line;
+			break;
+		case(4):
+			avalanche_hw0_chregs->cintnr4 =  line;
+			break;
+		case(5):
+			avalanche_hw0_chregs->cintnr5 =  line;
+			break;
+		case(6):
+			avalanche_hw0_chregs->cintnr6 =  line;
+			break;
+		case(7):
+			avalanche_hw0_chregs->cintnr7 =  line;
+			break;
+		case(8):
+			avalanche_hw0_chregs->cintnr8 =  line;
+			break;
+		case(9):
+			avalanche_hw0_chregs->cintnr9 =  line;
+			break;
+		case(10):
+			avalanche_hw0_chregs->cintnr10 = line;
+			break;
+		case(11):
+			avalanche_hw0_chregs->cintnr11 = line;
+			break;
+		case(12):
+			avalanche_hw0_chregs->cintnr12 = line;
+			break;
+		case(13):
+			avalanche_hw0_chregs->cintnr13 = line;
+			break;
+		case(14):
+			avalanche_hw0_chregs->cintnr14 = line;
+			break;
+		case(15):
+			avalanche_hw0_chregs->cintnr15 = line;
+			break;
+		case(16):
+			avalanche_hw0_chregs->cintnr16 = line;
+			break;
+		case(17):
+			avalanche_hw0_chregs->cintnr17 = line;
+			break;
+		case(18):
+			avalanche_hw0_chregs->cintnr18 = line;
+			break;
+		case(19):
+			avalanche_hw0_chregs->cintnr19 = line;
+			break;
+		case(20):
+			avalanche_hw0_chregs->cintnr20 = line;
+			break;
+		case(21):
+			avalanche_hw0_chregs->cintnr21 = line;
+			break;
+		case(22):
+			avalanche_hw0_chregs->cintnr22 = line;
+			break;
+		case(23):
+			avalanche_hw0_chregs->cintnr23 = line;
+			break;
+		case(24):
+			avalanche_hw0_chregs->cintnr24 = line;
+			break;
+		case(25):
+			avalanche_hw0_chregs->cintnr25 = line;
+			break;
+		case(26):
+			avalanche_hw0_chregs->cintnr26 = line;
+			break;
+		case(27):
+			avalanche_hw0_chregs->cintnr27 = line;
+			break;
+		case(28):
+			avalanche_hw0_chregs->cintnr28 = line;
+			break;
+		case(29):
+			avalanche_hw0_chregs->cintnr29 = line;
+			break;
+		case(30):
+			avalanche_hw0_chregs->cintnr30 = line;
+			break;
+		case(31):
+			avalanche_hw0_chregs->cintnr31 = line;
+			break;
+		case(32):
+			avalanche_hw0_chregs->cintnr32 = line;
+			break;
+		case(33):
+			avalanche_hw0_chregs->cintnr33 = line;
+			break;
+		case(34):
+			avalanche_hw0_chregs->cintnr34 = line;
+			break;
+		case(35):
+			avalanche_hw0_chregs->cintnr35 = line;
+			break;
+		case(36):
+			avalanche_hw0_chregs->cintnr36 = line;
+			break;
+		case(37):
+			avalanche_hw0_chregs->cintnr37 = line;
+			break;
+		case(38):
+			avalanche_hw0_chregs->cintnr38 = line;
+			break;
+		case(39):
+			avalanche_hw0_chregs->cintnr39 = line;
+			break;
+		default:
+			printk("Error: Unknown Avalanche interrupt channel\n");
+	}
+
+	line_to_channel[line] = channel; /* Suraj check */
+
+	if (channel == UNIFIED_SECONDARY_INTERRUPT)
+		uni_secondary_interrupt = line;
+
+}
diff -urN kernel-base/arch/mips/ar7/Makefile kernel-tmp2/arch/mips/ar7/Makefile
--- kernel-base/arch/mips/ar7/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/Makefile	2005-07-10 06:40:39.586266560 +0200
@@ -0,0 +1,29 @@
+# $Id$
+# Copyright (C) $Date$  $Author$
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+.S.s:
+	$(CPP) $(AFLAGS) $< -o $*.s
+
+.S.o:
+	$(CC) $(AFLAGS) -c $< -o $*.o
+
+O_TARGET := ar7.o
+
+export-objs := init.o
+obj-y := setup.o irq.o mipsIRQ.o reset.o init.o memory.o printf.o cmdline.o time.o
+
+include $(TOPDIR)/Rules.make
diff -urN kernel-base/arch/mips/ar7/memory.c kernel-tmp2/arch/mips/ar7/memory.c
--- kernel-base/arch/mips/ar7/memory.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/memory.c	2005-07-10 06:40:39.586266560 +0200
@@ -0,0 +1,130 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * PROM library functions for acquiring/using memory descriptors given to
+ * us from the YAMON.
+ *
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <asm/mips-boards/prom.h>
+#include <asm/ar7/ar7.h>
+
+enum yamon_memtypes {
+	yamon_dontuse,
+	yamon_prom,
+	yamon_free,
+};
+struct prom_pmemblock mdesc[PROM_MAX_PMEMBLOCKS];
+
+/* References to section boundaries */
+extern char _end;
+
+#define PFN_ALIGN(x)    (((unsigned long)(x) + (PAGE_SIZE - 1)) & PAGE_MASK)
+
+
+struct prom_pmemblock * __init prom_getmdesc(void)
+{
+	char *memsize_str;
+	unsigned int memsize;
+
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x02000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+
+	memset(mdesc, 0, sizeof(mdesc));
+
+	mdesc[0].type = yamon_dontuse;
+	mdesc[0].base = 0x00000000;
+	mdesc[0].size = CONFIG_AR7_MEMORY;
+
+	mdesc[1].type = yamon_prom;
+	mdesc[1].base = CONFIG_AR7_MEMORY;
+	mdesc[1].size = 0x00020000;
+
+	mdesc[2].type = yamon_free;
+	mdesc[2].base = CONFIG_AR7_MEMORY + 0x00020000;
+	mdesc[2].size = (memsize + CONFIG_AR7_MEMORY) - mdesc[2].base;
+
+	return &mdesc[0];
+}
+
+static int __init prom_memtype_classify (unsigned int type)
+{
+	switch (type) {
+		case yamon_free:
+			return BOOT_MEM_RAM;
+		case yamon_prom:
+			return BOOT_MEM_ROM_DATA;
+		default:
+			return BOOT_MEM_RESERVED;
+	}
+}
+
+void __init prom_meminit(void)
+{
+	struct prom_pmemblock *p;
+
+	p = prom_getmdesc();
+
+	while (p->size) {
+		long type;
+		unsigned long base, size;
+
+		type = prom_memtype_classify (p->type);
+		base = p->base;
+		size = p->size;
+
+		add_memory_region(base, size, type);
+		p++;
+	}
+}
+
+void __init prom_free_prom_memory (void)
+{
+	int i;
+	unsigned long freed = 0;
+	unsigned long addr;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		if (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)
+			continue;
+
+		addr = boot_mem_map.map[i].addr;
+		while (addr < boot_mem_map.map[i].addr
+				+ boot_mem_map.map[i].size) {
+			ClearPageReserved(virt_to_page(__va(addr)));
+			set_page_count(virt_to_page(__va(addr)), 1);
+			free_page((unsigned long)__va(addr));
+			addr += PAGE_SIZE;
+			freed += PAGE_SIZE;
+		}
+	}
+	printk("Freeing prom memory: %ldkb freed\n", freed >> 10);
+}
diff -urN kernel-base/arch/mips/ar7/mipsIRQ.S kernel-tmp2/arch/mips/ar7/mipsIRQ.S
--- kernel-base/arch/mips/ar7/mipsIRQ.S	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/mipsIRQ.S	2005-07-10 06:40:39.587266408 +0200
@@ -0,0 +1,120 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Interrupt exception dispatch code.
+ *
+ */
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/* A lot of complication here is taken away because:
+ *
+ * 1) We handle one interrupt and return, sitting in a loop and moving across
+ *    all the pending IRQ bits in the cause register is _NOT_ the answer, the
+ *    common case is one pending IRQ so optimize in that direction.
+ *
+ * 2) We need not check against bits in the status register IRQ mask, that
+ *    would make this routine slow as hell.
+ *
+ * 3) Linux only thinks in terms of all IRQs on or all IRQs off, nothing in
+ *    between like BSD spl() brain-damage.
+ *
+ * Furthermore, the IRQs on the MIPS board look basically (barring software
+ * IRQs which we don't use at all and all external interrupt sources are
+ * combined together on hardware interrupt 0 (MIPS IRQ 2)) like:
+ *
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware (ignored)
+ *             4        Hardware (ignored)
+ *             5        Hardware (ignored)
+ *             6        Hardware (ignored)
+ *             7        R4k timer (what we use)
+ *
+ * Note: On the SEAD board thing are a little bit different.
+ *       Here IRQ 2 (hw0) is wired to the UART0 and IRQ 3 (hw1) is wired
+ *       wired to UART1.
+ *
+ * We handle the IRQ according to _our_ priority which is:
+ *
+ * Highest ----     R4k Timer
+ * Lowest  ----     Combined hardware interrupt
+ *
+ * then we just return, if multiple IRQs are pending then we will just take
+ * another exception, big deal.
+ */
+
+.text
+.set	noreorder
+.set	noat
+	.align	5
+NESTED(mipsIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+
+	mfc0	s0, CP0_CAUSE		# get irq bits
+
+	/* First we check for r4k counter/timer IRQ. */
+	andi	a0, s0, CAUSEF_IP7
+	beq	a0, zero, 1f
+	andi	a0, s0, CAUSEF_IP2	# delay slot, check hw0 interrupt
+
+	/* Wheee, a timer interrupt. */
+	move	a0, sp
+	jal	ar7_timer_interrupt
+	nop
+
+	j	ret_from_irq
+	nop
+
+	1:
+	beq	a0, zero, 1f		# delay slot, check hw3 interrupt
+	nop
+
+	/* Wheee, combined hardware level zero interrupt. */
+	jal	avalanche_hw0_irqdispatch     
+	move	a0, sp			# delay slot
+
+	j	ret_from_irq
+	nop				# delay slot
+
+	1:
+	/*
+	 * Here by mistake?  This is possible, what can happen is that by the
+	 * time we take the exception the IRQ pin goes low, so just leave if
+	 * this is the case.
+	 */
+	move	a1,s0
+	PRINT("Got interrupt: c0_cause = %08x\n")
+	mfc0	a1, CP0_EPC
+	PRINT("c0_epc = %08x\n")
+
+	j	ret_from_irq
+	nop
+END(mipsIRQ)
diff -urN kernel-base/arch/mips/ar7/printf.c kernel-tmp2/arch/mips/ar7/printf.c
--- kernel-base/arch/mips/ar7/printf.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/printf.c	2005-07-10 06:40:39.587266408 +0200
@@ -0,0 +1,54 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Putting things on the screen/serial line using Adam2 facilities.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/serial_reg.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/serial.h>
+#include <asm/addrspace.h>
+#include <asm/ar7/ar7.h>
+
+#define AVALANCHE_YAMON_FUNCTION_BASE             (KSEG1ADDR(0x10000500))
+#define AVALANCHE_YAMON_PROM_PRINT_COUNT_ADDR     (AVALANCHE_YAMON_FUNCTION_BASE + 0x4)  /* print_count function */
+
+static char ppbuf[1024];
+
+void (*prom_print_str)(unsigned int out, char *s, int len);
+
+void prom_printf(char *fmt, ...) __init;
+void prom_printf(char *fmt, ...)
+{
+	va_list args;
+	int len;
+	prom_print_str = (void *)*(unsigned int *)AVALANCHE_YAMON_PROM_PRINT_COUNT_ADDR;
+
+	va_start(args, fmt);
+	vsprintf(ppbuf, fmt, args);
+	len = strlen(ppbuf);
+
+	prom_print_str(1, ppbuf, len);
+
+	va_end(args);
+	return;
+
+}
diff -urN kernel-base/arch/mips/ar7/reset.c kernel-tmp2/arch/mips/ar7/reset.c
--- kernel-base/arch/mips/ar7/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/reset.c	2005-07-10 06:40:39.587266408 +0200
@@ -0,0 +1,54 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Reset the MIPS boards.
+ *
+ */
+#include <linux/config.h>
+
+#include <asm/reboot.h>
+#include <asm/mips-boards/generic.h>
+
+static void ar7_machine_restart(char *command);
+static void ar7_machine_halt(void);
+static void ar7_machine_power_off(void);
+
+static void ar7_machine_restart(char *command)
+{
+
+}
+
+static void ar7_machine_halt(void)
+{
+
+}
+
+static void ar7_machine_power_off(void)
+{
+
+}
+
+void ar7_reboot_setup(void)
+{
+	_machine_restart = ar7_machine_restart;
+	_machine_halt = ar7_machine_halt;
+	_machine_power_off = ar7_machine_power_off;
+}
diff -urN kernel-base/arch/mips/ar7/setup.c kernel-tmp2/arch/mips/ar7/setup.c
--- kernel-base/arch/mips/ar7/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/setup.c	2005-07-10 06:40:39.588266256 +0200
@@ -0,0 +1,120 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/mc146818rtc.h>
+#include <linux/ioport.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mips-boards/generic.h>
+#include <asm/mips-boards/prom.h>
+
+#include <asm/dma.h>
+#include <asm/time.h>
+#include <asm/traps.h>
+
+#ifdef CONFIG_KGDB
+extern void rs_kgdb_hook(int);
+int remote_debug = 0;
+#endif
+
+extern struct rtc_ops no_rtc_ops;
+
+extern void ar7_reboot_setup(void);
+
+extern void ar7_time_init(void);
+extern void ar7_timer_setup(struct irqaction *irq);
+
+const char *get_system_type(void)
+{
+	return "Texas Instruments AR7";
+}
+
+void __init ar7_setup(void)
+{
+#ifdef CONFIG_KGDB
+	int rs_putDebugChar(char);
+	char rs_getDebugChar(void);
+	extern int (*generic_putDebugChar)(char);
+	extern char (*generic_getDebugChar)(void);
+#endif
+	char *argptr;
+#ifdef CONFIG_SERIAL_CONSOLE
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "console=")) == NULL) {
+		char console[20];
+		char *s;
+		int i = 0;
+		
+		s = prom_getenv("modetty0");
+		strcpy(console, "38400");
+		
+		if (s != NULL) {
+			while (s[i] >= '0' && s[i] <= '9')
+				i++;
+		
+			if (i > 0) {
+				strncpy(console, s, i);
+				console[i] = 0;
+			}
+		}
+		
+		argptr = prom_getcmdline();
+		strcat(argptr, " console=ttyS0,");
+		strcat(argptr, console);
+	}
+#endif
+
+#ifdef CONFIG_KGDB
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "kgdb=ttyS")) != NULL) {
+		int line;
+		argptr += strlen("kgdb=ttyS");
+		if (*argptr != '0' && *argptr != '1')
+			printk("KGDB: Uknown serial line /dev/ttyS%c, "
+					"falling back to /dev/ttyS1\n", *argptr);
+		line = *argptr == '0' ? 0 : 1;
+		printk("KGDB: Using serial line /dev/ttyS%d for session\n",
+				line ? 1 : 0);
+
+		rs_kgdb_hook(line);
+		generic_putDebugChar = rs_putDebugChar;
+		generic_getDebugChar = rs_getDebugChar;
+
+		prom_printf("KGDB: Using serial line /dev/ttyS%d for session, "
+				"please connect your debugger\n", line ? 1 : 0);
+
+		remote_debug = 1;
+		/* Breakpoints are in init_IRQ() */
+	}
+#endif
+
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "nofpu")) != NULL)
+		cpu_data[0].options &= ~MIPS_CPU_FPU;
+
+	rtc_ops = &no_rtc_ops;
+
+	ar7_reboot_setup();
+
+	board_time_init = ar7_time_init;
+	board_timer_setup = ar7_timer_setup;
+}
diff -urN kernel-base/arch/mips/ar7/time.c kernel-tmp2/arch/mips/ar7/time.c
--- kernel-base/arch/mips/ar7/time.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/arch/mips/ar7/time.c	2005-07-10 06:40:39.588266256 +0200
@@ -0,0 +1,125 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Setting up the clock on the MIPS boards.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/hardirq.h>
+#include <asm/div64.h>
+
+#include <linux/interrupt.h>
+#include <linux/mc146818rtc.h>
+#include <linux/timex.h>
+
+#include <asm/mips-boards/generic.h>
+#include <asm/mips-boards/prom.h>
+#include <asm/ar7/ar7.h>
+
+extern asmlinkage void mipsIRQ(void);
+
+static unsigned long r4k_offset; /* Amount to increment compare reg each time */
+static unsigned long r4k_cur;    /* What counter should be at next timer irq */
+
+#define MIPS_CPU_TIMER_IRQ 7
+#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
+
+static inline void ack_r4ktimer(unsigned long newval)
+{
+	write_c0_compare(newval);
+}
+
+void ar7_timer_interrupt(struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+
+	irq_enter(cpu, MIPS_CPU_TIMER_IRQ);
+
+	if (r4k_offset == 0)
+		goto null;
+
+	do {
+		kstat.irqs[cpu][MIPS_CPU_TIMER_IRQ]++;
+		do_timer(regs);
+		r4k_cur += r4k_offset;
+		ack_r4ktimer(r4k_cur);
+
+	} while (((unsigned long)read_c0_count()
+				- r4k_cur) < 0x7fffffff);
+
+	irq_exit(cpu, MIPS_CPU_TIMER_IRQ);
+
+	if (softirq_pending(cpu))
+		do_softirq();
+
+	return;
+
+null:
+	ack_r4ktimer(0);
+}
+
+/*
+ * Figure out the r4k offset, the amount to increment the compare
+ * register for each time tick.
+ */
+static unsigned long __init cal_r4koff(void)
+{
+	return ((CONFIG_AR7_CPU_FREQUENCY*500000)/HZ);
+}
+
+void __init ar7_time_init(void)
+{
+	unsigned long flags;
+	unsigned int est_freq; 
+
+	set_except_vector(0, mipsIRQ);
+	write_c0_count(0);
+
+	printk("calculating r4koff... ");
+	r4k_offset = cal_r4koff();
+	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);
+
+	est_freq = 2*r4k_offset*HZ;
+	est_freq += 5000;    /* round */
+	est_freq -= est_freq%10000;
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000,
+			(est_freq%1000000)*100/1000000);
+}
+
+void __init ar7_timer_setup(struct irqaction *irq)
+{
+	/* we are using the cpu counter for timer interrupts */
+	irq->handler = no_action;     /* we use our own handler */
+	setup_irq(MIPS_CPU_TIMER_IRQ, irq);
+
+	r4k_cur = (read_c0_count() + r4k_offset);
+	write_c0_compare(r4k_cur);
+	set_c0_status(ALLINTS);
+}
diff -urN kernel-base/arch/mips/config-shared.in kernel-tmp2/arch/mips/config-shared.in
--- kernel-base/arch/mips/config-shared.in	2005-07-10 03:00:44.784181376 +0200
+++ kernel-tmp2/arch/mips/config-shared.in	2005-07-10 06:40:39.589266104 +0200
@@ -20,6 +20,16 @@
 mainmenu_option next_comment
 comment 'Machine selection'
 dep_bool 'Support for Acer PICA 1 chipset (EXPERIMENTAL)' CONFIG_ACER_PICA_61 $CONFIG_EXPERIMENTAL
+dep_bool 'Support for Texas Instruments AR7 (EXPERIMENTAL)' CONFIG_AR7 $CONFIG_MIPS32 $CONFIG_EXPERIMENTAL
+if [ "$CONFIG_AR7" = "y" ]; then
+   choice 'Texas Instruments Reference Platform' \
+      "AR7DB CONFIG_AR7DB \
+      AR7RD CONFIG_AR7RD \
+      AR7WRD CONFIG_AR7WRD" AR7DB
+   int 'Texas Instruments AR7 CPU Frequency' CONFIG_AR7_CPU_FREQUENCY 150
+   int 'Texas Instruments AR7 System Frequency' CONFIG_AR7_SYS_FREQUENCY 125
+   hex 'Texas Instruments AR7 SDRAM Start' CONFIG_AR7_MEMORY 0x14000000
+fi
 dep_bool 'Support for Alchemy Bosporus board' CONFIG_MIPS_BOSPORUS $CONFIG_MIPS32
 dep_bool 'Support for FIC Multimedia Player board' CONFIG_MIPS_FICMMP $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Mirage board' CONFIG_MIPS_MIRAGE $CONFIG_MIPS32
@@ -239,6 +249,11 @@
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
+if [ "$CONFIG_AR7" = "y" ]; then
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SWAP_IO_SPACE y
+   define_bool CONFIG_AR7_PAGING y
+fi
 if [ "$CONFIG_CASIO_E55" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
    define_bool CONFIG_NONCOHERENT_IO y
@@ -736,6 +751,7 @@
 mainmenu_option next_comment
 comment 'General setup'
 if [ "$CONFIG_ACER_PICA_61" = "y" -o \
+     "$CONFIG_AR7" = "y" -o \
      "$CONFIG_CASIO_E55" = "y" -o \
      "$CONFIG_DDB5074" = "y" -o \
      "$CONFIG_DDB5476" = "y" -o \
@@ -797,6 +813,7 @@
 bool 'Networking support' CONFIG_NET
 
 if [ "$CONFIG_ACER_PICA_61" = "y" -o \
+     "$CONFIG_AR7" = "y" -o \
      "$CONFIG_CASIO_E55" = "y" -o \
      "$CONFIG_DECSTATION" = "y" -o \
      "$CONFIG_IBM_WORKPAD" = "y" -o \
diff -urN kernel-base/arch/mips/kernel/irq.c kernel-tmp2/arch/mips/kernel/irq.c
--- kernel-base/arch/mips/kernel/irq.c	2005-07-10 03:00:44.784181376 +0200
+++ kernel-tmp2/arch/mips/kernel/irq.c	2005-07-10 06:40:39.589266104 +0200
@@ -76,6 +76,7 @@
  * Generic, controller-independent functions:
  */
 
+#ifndef CONFIG_AR7
 int get_irq_list(char *buf)
 {
 	int i, j;
@@ -110,6 +111,7 @@
 	p += sprintf(p, "ERR: %10u\n", atomic_read(&irq_err_count));
 	return p - buf;
 }
+#endif
 
 #ifdef CONFIG_SMP
 int global_irq_holder = NO_PROC_ID;
@@ -525,6 +527,7 @@
  *
  */
 
+#ifndef CONFIG_AR7
 int request_irq(unsigned int irq,
 		void (*handler)(int, void *, struct pt_regs *),
 		unsigned long irqflags,
@@ -569,6 +572,7 @@
 		kfree(action);
 	return retval;
 }
+#endif
 
 /**
  *	free_irq - free an interrupt
@@ -588,6 +592,7 @@
  *	      the machine.
  */
 
+#ifndef CONFIG_AR7
 void free_irq(unsigned int irq, void *dev_id)
 {
 	irq_desc_t *desc;
@@ -629,6 +634,7 @@
 		return;
 	}
 }
+#endif
 
 /*
  * IRQ autodetection code..
diff -urN kernel-base/arch/mips/kernel/setup.c kernel-tmp2/arch/mips/kernel/setup.c
--- kernel-base/arch/mips/kernel/setup.c	2005-07-10 03:00:44.785181224 +0200
+++ kernel-tmp2/arch/mips/kernel/setup.c	2005-07-10 06:40:39.590265952 +0200
@@ -109,6 +109,7 @@
 unsigned long isa_slot_offset;
 EXPORT_SYMBOL(isa_slot_offset);
 
+extern void avalanche_bootmem_init(void);
 extern void SetUpBootInfo(void);
 extern void load_mmu(void);
 extern asmlinkage void start_kernel(void);
@@ -267,6 +268,9 @@
 #endif	/* CONFIG_BLK_DEV_INITRD */
 
 	/* Find the highest page frame number we have available.  */
+#ifdef CONFIG_AR7_PAGING
+ 	avalanche_bootmem_init();
+#else
 	max_pfn = 0;
 	first_usable_pfn = -1UL;
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
@@ -377,6 +381,7 @@
 	/* Reserve the bootmap memory.  */
 	reserve_bootmem(PFN_PHYS(first_usable_pfn), bootmap_size);
 
+#endif
 #ifdef CONFIG_BLK_DEV_INITRD
 	/* Board specific code should have set up initrd_start and initrd_end */
 	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
@@ -494,6 +499,7 @@
 	void hp_setup(void);
 	void au1x00_setup(void);
 	void frame_info_init(void);
+ 	void ar7_setup(void);
 
 	frame_info_init();
 #if defined(CONFIG_BLK_DEV_FD) || defined(CONFIG_BLK_DEV_FD_MODULE)
@@ -691,6 +697,11 @@
                 pmc_yosemite_setup();
                 break;
 #endif
+#ifdef CONFIG_AR7
+	case MACH_GROUP_UNKNOWN:
+		ar7_setup();
+		break;
+#endif
 	default:
 		panic("Unsupported architecture");
 	}
diff -urN kernel-base/arch/mips/kernel/traps.c kernel-tmp2/arch/mips/kernel/traps.c
--- kernel-base/arch/mips/kernel/traps.c	2005-07-10 03:00:44.786181072 +0200
+++ kernel-tmp2/arch/mips/kernel/traps.c	2005-07-10 06:40:39.591265800 +0200
@@ -40,6 +40,10 @@
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 
+#ifdef CONFIG_AR7
+#include <asm/ar7/ar7.h>
+#endif
+
 extern asmlinkage void handle_mod(void);
 extern asmlinkage void handle_tlbl(void);
 extern asmlinkage void handle_tlbs(void);
@@ -869,9 +873,15 @@
 
 	exception_handlers[n] = handler;
 	if (n == 0 && cpu_has_divec) {
+#ifdef CONFIG_AR7
+		*(volatile u32 *)(AVALANCHE_VECS_KSEG0+0x200) = 0x08000000 |
+			(0x03ffffff & (handler >> 2));
+		flush_icache_range(AVALANCHE_VECS_KSEG0+0x200, AVALANCHE_VECS_KSEG0 + 0x204);
+#else
 		*(volatile u32 *)(KSEG0+0x200) = 0x08000000 |
 		                                 (0x03ffffff & (handler >> 2));
 		flush_icache_range(KSEG0+0x200, KSEG0 + 0x204);
+#endif
 	}
 	return (void *)old_handler;
 }
@@ -920,14 +930,46 @@
 void __init trap_init(void)
 {
 	extern char except_vec1_generic;
+	extern char except_vec2_generic;
 	extern char except_vec3_generic, except_vec3_r4000;
 	extern char except_vec_ejtag_debug;
 	extern char except_vec4;
 	unsigned long i;
 
+#ifdef CONFIG_AR7
+	extern char jump_tlb_miss, jump_tlb_miss_unused;
+	extern char jump_cache_error,jump_general_exception;
+	extern char jump_dedicated_interrupt;
+	clear_c0_status(ST0_BEV);
+#endif
+
 	/* Copy the generic exception handler code to it's final destination. */
 	memcpy((void *)(KSEG0 + 0x80), &except_vec1_generic, 0x80);
+	memcpy((void *)(KSEG0 + 0x100), &except_vec2_generic, 0x80);
+	memcpy((void *)(KSEG0 + 0x180), &except_vec3_generic, 0x80);
 
+	memcpy((void *)(KSEG0 + 0x0),   &jump_tlb_miss, 0x80);
+	memcpy((void *)(KSEG0 + 0x80),  &jump_tlb_miss_unused, 0x80);
+	memcpy((void *)(KSEG0 + 0x100), &jump_cache_error, 0x80);
+	memcpy((void *)(KSEG0 + 0x180), &jump_general_exception, 0x80);
+	memcpy((void *)(KSEG0 + 0x200), &jump_dedicated_interrupt, 0x80);
+
+#ifdef CONFIG_AR7
+	memcpy((void *)(AVALANCHE_VECS_KSEG0 + 0x80), &except_vec1_generic, 0x80);
+	memcpy((void *)(AVALANCHE_VECS_KSEG0 + 0x100), &except_vec2_generic, 0x80);
+	memcpy((void *)(AVALANCHE_VECS_KSEG0 + 0x180), &except_vec3_generic, 0x80);
+	flush_icache_range(AVALANCHE_VECS_KSEG0, AVALANCHE_VECS_KSEG0 + 0x200);
+
+	memcpy((void *)(KSEG0 + 0x0),   &jump_tlb_miss, 0x80);
+	memcpy((void *)(KSEG0 + 0x80),  &jump_tlb_miss_unused, 0x80);
+	memcpy((void *)(KSEG0 + 0x100), &jump_cache_error, 0x80);
+	memcpy((void *)(KSEG0 + 0x180), &jump_general_exception, 0x80);
+	memcpy((void *)(KSEG0 + 0x200), &jump_dedicated_interrupt, 0x80);
+#else
+	memcpy((void *)(KSEG0 + 0x80), &except_vec1_generic, 0x80);
+#endif
+	flush_icache_range(KSEG0 + 0x80, KSEG0 + 0x200);
+	
 	/*
 	 * Setup default vectors
 	 */
@@ -951,8 +993,12 @@
 	 * Some MIPS CPUs have a dedicated interrupt vector which reduces the
 	 * interrupt processing overhead.  Use it where available.
 	 */
+#ifdef CONFIG_AR7
+	memcpy((void *)(AVALANCHE_VECS_KSEG0 + 0x200), &except_vec4, 8);
+#else
 	if (cpu_has_divec)
 		memcpy((void *)(KSEG0 + 0x200), &except_vec4, 8);
+#endif
 
 	/*
 	 * Some CPUs can enable/disable for cache parity detection, but does
@@ -991,12 +1037,17 @@
 	if (cpu_has_mcheck)
 		set_except_vector(24, handle_mcheck);
 
+memcpy((void *)(KSEG0 + 0x180), &except_vec3_generic, 0x80);
+#ifdef CONFIG_AR7
+	memcpy((void *)(AVALANCHE_VECS_KSEG0 + 0x180), &except_vec3_generic, 0x80);
+#else
 	if (cpu_has_vce)
 		memcpy((void *)(KSEG0 + 0x180), &except_vec3_r4000, 0x80);
 	else if (cpu_has_4kex)
 		memcpy((void *)(KSEG0 + 0x180), &except_vec3_generic, 0x80);
 	else
 		memcpy((void *)(KSEG0 + 0x080), &except_vec3_generic, 0x80);
+#endif
 
 	if (current_cpu_data.cputype == CPU_R6000 ||
 	    current_cpu_data.cputype == CPU_R6000A) {
@@ -1023,7 +1074,11 @@
 	if (board_nmi_handler_setup)
 		board_nmi_handler_setup();
 
+#ifdef CONFIG_AR7
+	flush_icache_range(AVALANCHE_VECS_KSEG0, AVALANCHE_VECS_KSEG0 + 0x200);
+#else
 	flush_icache_range(KSEG0, KSEG0 + 0x400);
+#endif
 
 	per_cpu_trap_init();
 }
diff -urN kernel-base/arch/mips/lib/promlib.c kernel-tmp2/arch/mips/lib/promlib.c
--- kernel-base/arch/mips/lib/promlib.c	2005-07-10 03:00:44.786181072 +0200
+++ kernel-tmp2/arch/mips/lib/promlib.c	2005-07-10 06:40:39.591265800 +0200
@@ -1,3 +1,4 @@
+#ifndef CONFIG_AR7
 #include <stdarg.h>
 #include <linux/kernel.h>
 
@@ -22,3 +23,4 @@
 	}
 	va_end(args);
 }
+#endif
diff -urN kernel-base/arch/mips/Makefile kernel-tmp2/arch/mips/Makefile
--- kernel-base/arch/mips/Makefile	2005-07-10 03:00:44.786181072 +0200
+++ kernel-tmp2/arch/mips/Makefile	2005-07-10 06:40:39.591265800 +0200
@@ -369,6 +369,16 @@
 endif
 
 #
+# Texas Instruments AR7
+#
+
+ifdef CONFIG_AR7
+LIBS		+= arch/mips/ar7/ar7.o arch/mips/ar7/ar7/ar7.o
+SUBDIRS		+= arch/mips/ar7 arch/mips/ar7/ar7
+LOADADDR	+= 0x94020000
+endif
+
+#
 # DECstation family
 #
 ifdef CONFIG_DECSTATION
diff -urN kernel-base/arch/mips/mm/init.c kernel-tmp2/arch/mips/mm/init.c
--- kernel-base/arch/mips/mm/init.c	2005-07-10 03:00:44.787180920 +0200
+++ kernel-tmp2/arch/mips/mm/init.c	2005-07-10 07:09:29.914216728 +0200
@@ -40,8 +40,10 @@
 
 mmu_gather_t mmu_gathers[NR_CPUS];
 unsigned long highstart_pfn, highend_pfn;
+#ifndef CONFIG_AR7_PAGING
 static unsigned long totalram_pages;
 static unsigned long totalhigh_pages;
+#endif
 
 void pgd_init(unsigned long page)
 {
@@ -235,6 +237,7 @@
 #endif
 }
 
+#ifndef CONFIG_AR7_PAGING
 void __init paging_init(void)
 {
 	unsigned long zones_size[MAX_NR_ZONES] = {0, 0, 0};
@@ -272,6 +275,7 @@
 
 	free_area_init(zones_size);
 }
+#endif
 
 #define PFN_UP(x)	(((x) + PAGE_SIZE - 1) >> PAGE_SHIFT)
 #define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
@@ -298,6 +302,7 @@
 	return 0;
 }
 
+#ifndef CONFIG_AR7_PAGING
 void __init mem_init(void)
 {
 	unsigned long codesize, reservedpages, datasize, initsize;
@@ -359,6 +364,7 @@
 	       initsize >> 10,
 	       (unsigned long) (totalhigh_pages << (PAGE_SHIFT-10)));
 }
+#endif
 
 #ifdef CONFIG_BLK_DEV_INITRD
 void free_initrd_mem(unsigned long start, unsigned long end)
@@ -376,6 +382,7 @@
 }
 #endif
 
+#ifndef CONFIG_AR7_PAGING
 extern char __init_begin, __init_end;
 extern void prom_free_prom_memory(void) __init;
 
@@ -383,7 +390,9 @@
 {
 	unsigned long addr;
 
+#ifndef CONFIG_AR7
 	prom_free_prom_memory ();
+#endif
 
 	addr = (unsigned long) &__init_begin;
 	while (addr < (unsigned long) &__init_end) {
@@ -409,3 +418,4 @@
 
 	return;
 }
+#endif
diff -urN kernel-base/arch/mips/mm/tlb-r4k.c kernel-tmp2/arch/mips/mm/tlb-r4k.c
--- kernel-base/arch/mips/mm/tlb-r4k.c	2005-07-10 03:00:44.787180920 +0200
+++ kernel-tmp2/arch/mips/mm/tlb-r4k.c	2005-07-10 06:40:39.592265648 +0200
@@ -20,6 +20,10 @@
 #include <asm/pgtable.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_AR7
+#include <asm/ar7/ar7.h>
+#endif
+
 extern char except_vec0_nevada, except_vec0_r4000, except_vec0_r4600;
 
 /* CP0 hazard avoidance. */
@@ -375,7 +379,12 @@
 		else if (current_cpu_data.cputype == CPU_R4600)
 			memcpy((void *)KSEG0, &except_vec0_r4600, 0x80);
 		else
+#ifdef CONFIG_AR7
+			memcpy((void *)AVALANCHE_VECS_KSEG0, &except_vec0_r4000, 0x80);
+		flush_icache_range(AVALANCHE_VECS_KSEG0, AVALANCHE_VECS_KSEG0 + 0x80);
+#else
 			memcpy((void *)KSEG0, &except_vec0_r4000, 0x80);
 		flush_icache_range(KSEG0, KSEG0 + 0x80);
+#endif
 	}
 }
diff -urN kernel-base/drivers/char/serial.c kernel-tmp2/drivers/char/serial.c
--- kernel-base/drivers/char/serial.c	2005-07-10 03:00:44.789180616 +0200
+++ kernel-tmp2/drivers/char/serial.c	2005-07-10 06:42:02.902600552 +0200
@@ -419,7 +419,40 @@
 	return 0;
 }
 
-#if defined(CONFIG_MIPS_ATLAS) || defined(CONFIG_MIPS_SEAD)
+#if defined(CONFIG_AR7)
+
+static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
+{
+	return (inb(info->port + (offset * 4)) & 0xff);  
+}
+
+
+static _INLINE_ unsigned int serial_inp(struct async_struct *info, int offset)
+{
+#ifdef CONFIG_SERIAL_NOPAUSE_IO
+	return (inb(info->port + (offset * 4)) & 0xff);
+#else
+	return (inb_p(info->port + (offset * 4)) & 0xff);
+#endif
+}
+
+static _INLINE_ void serial_out(struct async_struct *info, int offset, int value)
+{
+	outb(value, info->port + (offset * 4));      
+}
+
+
+static _INLINE_ void serial_outp(struct async_struct *info, int offset,
+		int value)
+{
+#ifdef CONFIG_SERIAL_NOPAUSE_IO
+	outb(value, info->port + (offset * 4));
+#else
+	outb_p(value, info->port + (offset * 4));
+#endif
+}
+
+#elif defined(CONFIG_MIPS_ATLAS) || defined(CONFIG_MIPS_SEAD)
 
 #include <asm/mips-boards/atlas.h>
 
@@ -478,8 +511,10 @@
  * needed for certain old 386 machines, I've left these #define's
  * in....
  */
+#ifndef CONFIG_AR7
 #define serial_inp(info, offset)		serial_in(info, offset)
 #define serial_outp(info, offset, value)	serial_out(info, offset, value)
+#endif
 
 
 /*
@@ -1728,7 +1763,16 @@
 			/* Special case since 134 is really 134.5 */
 			quot = (2*baud_base / 269);
 		else if (baud)
+#ifdef CONFIG_AR7
+			quot = (CONFIG_AR7_SYS_FREQUENCY*500000) / baud;
+			//quot = get_avalanche_vbus_freq() / baud;
+
+		if ((quot%16)>7)
+			quot += 8;
+		quot /=16;
+#else
 			quot = baud_base / baud;
+#endif
 	}
 	/* If the quotient is zero refuse the change */
 	if (!quot && old_termios) {
@@ -5552,8 +5596,10 @@
 		state->irq = irq_cannonicalize(state->irq);
 		if (state->hub6)
 			state->io_type = SERIAL_IO_HUB6;
+#ifndef CONFIG_AR7
 		if (state->port && check_region(state->port,8))
 			continue;
+#endif
 #ifdef CONFIG_MCA			
 		if ((state->flags & ASYNC_BOOT_ONLYMCA) && !MCA_bus)
 			continue;
@@ -6009,7 +6055,16 @@
 	info->io_type = state->io_type;
 	info->iomem_base = state->iomem_base;
 	info->iomem_reg_shift = state->iomem_reg_shift;
+#ifdef CONFIG_AR7
+	//quot = get_avalanche_vbus_freq() / baud;
+	quot = (CONFIG_AR7_SYS_FREQUENCY*500000) / baud;
+
+	if ((quot%16)>7)
+		quot += 8;
+	quot /=16;
+#else
 	quot = state->baud_base / baud;
+#endif
 	cval = cflag & (CSIZE | CSTOPB);
 #if defined(__powerpc__) || defined(__alpha__)
 	cval >>= 8;
diff -urN kernel-base/include/asm-mips/ar7/ar7.h kernel-tmp2/include/asm-mips/ar7/ar7.h
--- kernel-base/include/asm-mips/ar7/ar7.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/include/asm-mips/ar7/ar7.h	2005-07-10 06:40:39.622261088 +0200
@@ -0,0 +1,33 @@
+/*
+ * $Id$
+ * Copyright (C) $Date$  $Author$
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef _AR7_H
+#define _AR7_H
+
+#include <asm/addrspace.h>
+#include <linux/config.h>
+
+#define AVALANCHE_VECS_KSEG0 (KSEG0ADDR(CONFIG_AR7_MEMORY))
+
+#define AR7_UART0_REGS_BASE (KSEG1ADDR(0x08610E00))
+#define AR7_UART1_REGS_BASE (KSEG1ADDR(0x08610E00))
+#define AR7_BASE_BAUD ( 3686400 / 16 )
+
+#endif
diff -urN kernel-base/include/asm-mips/ar7/avalanche_intc.h kernel-tmp2/include/asm-mips/ar7/avalanche_intc.h
--- kernel-base/include/asm-mips/ar7/avalanche_intc.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/include/asm-mips/ar7/avalanche_intc.h	2005-07-10 06:40:39.622261088 +0200
@@ -0,0 +1,278 @@
+ /*
+ * Nitin Dhingra, iamnd@ti.com
+ * Copyright (C) 2000 Texas Instruments Inc.
+ *
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Defines of the Sead board specific address-MAP, registers, etc.
+ *
+ */
+#ifndef _AVALANCHE_INTC_H
+#define _AVALANCHE_INTC_H
+
+#define MIPS_EXCEPTION_OFFSET 8
+
+/******************************************************************************
+ Avalanche Interrupt number
+******************************************************************************/
+#define AVINTNUM(x) ((x) - MIPS_EXCEPTION_OFFSET)
+
+/*******************************************************************************
+*Linux Interrupt number
+*******************************************************************************/
+#define LNXINTNUM(x)((x) + MIPS_EXCEPTION_OFFSET)
+
+
+
+#define AVALANCHE_INT_END_PRIMARY      (40 + MIPS_EXCEPTION_OFFSET)
+#define AVALANCHE_INT_END_SECONDARY    (32 + MIPS_EXCEPTION_OFFSET)
+
+#define AVALANCHE_INT_END_PRIMARY_REG1 (31 + MIPS_EXCEPTION_OFFSET)
+#define AVALANCHE_INT_END_PRIMARY_REG2 (39 + MIPS_EXCEPTION_OFFSET)
+
+
+#define AVALANCHE_INT_END (AVINTNUM(AVALANCHE_INT_END_PRIMARY) + \
+			    AVINTNUM(AVALANCHE_INT_END_SECONDARY)  \
+                                    + MIPS_EXCEPTION_OFFSET - 1) /* Suraj, check */
+
+
+/*
+ * Avalanche interrupt controller register base (primary)
+ */
+#define KSEG1_BASE                  0xA0000000
+#define KSEG_INV_MASK               0x1FFFFFFF /* Inverted mask for kseg address */
+#define PHYS_ADDR(addr)             ((addr) & KSEG_INV_MASK)
+#define PHYS_TO_K1(addr)            (PHYS_ADDR(addr)|KSEG1_BASE)
+
+#define AVALANCHE_ICTRL_REGS_BASE   KSEG1ADDR(0x08612400)// AVALANCHE_INTC_BASE
+
+/******************************************************************************
+ * Avalanche exception controller register base (secondary)
+ ******************************************************************************/
+#define AVALANCHE_ECTRL_REGS_BASE  (AVALANCHE_ICTRL_REGS_BASE + 0x80)
+
+
+/******************************************************************************
+ *  Avalanche Interrupt pacing register base (secondary)
+ ******************************************************************************/
+#define AVALANCHE_IPACE_REGS_BASE  (AVALANCHE_ICTRL_REGS_BASE + 0xA0)
+
+
+
+/******************************************************************************
+ * Avalanche Interrupt Channel Control register base
+ *****************************************************************************/
+#define AVALANCHE_CHCTRL_REGS_BASE (AVALANCHE_ICTRL_REGS_BASE + 0x200)
+
+
+struct avalanche_ictrl_regs /* Avalanche Interrupt control registers */
+{
+  volatile unsigned long intsr1;    /* Interrupt Status/Set Register 1   0x00 */
+  volatile unsigned long intsr2;    /* Interrupt Status/Set Register 2   0x04 */
+  volatile unsigned long unused1;                                      /*0x08 */
+  volatile unsigned long unused2;                                      /*0x0C */
+  volatile unsigned long intcr1;    /* Interrupt Clear Register 1        0x10 */
+  volatile unsigned long intcr2;    /* Interrupt Clear Register 2        0x14 */
+  volatile unsigned long unused3;                                      /*0x18 */
+  volatile unsigned long unused4;                                      /*0x1C */
+  volatile unsigned long intesr1;   /* Interrupt Enable (Set) Register 1 0x20 */
+  volatile unsigned long intesr2;   /* Interrupt Enable (Set) Register 2 0x24 */
+  volatile unsigned long unused5;                                      /*0x28 */
+  volatile unsigned long unused6;                                      /*0x2C */
+  volatile unsigned long intecr1;   /* Interrupt Enable Clear Register 1 0x30 */
+  volatile unsigned long intecr2;   /* Interrupt Enable Clear Register 2 0x34 */
+  volatile unsigned long unused7;                                     /* 0x38 */
+  volatile unsigned long unused8;                                     /* 0x3c */
+  volatile unsigned long pintir;    /* Priority Interrupt Index Register 0x40 */
+  volatile unsigned long intmsr;    /* Priority Interrupt Mask Index Reg 0x44 */
+  volatile unsigned long unused9;                                     /* 0x48 */
+  volatile unsigned long unused10;                                    /* 0x4C */
+  volatile unsigned long intpolr1;  /* Interrupt Polarity Mask register 10x50 */
+  volatile unsigned long intpolr2;  /* Interrupt Polarity Mask register 20x54 */
+  volatile unsigned long unused11;                                    /* 0x58 */
+  volatile unsigned long unused12;                                   /*0x5C */
+  volatile unsigned long inttypr1;  /* Interrupt Type     Mask register 10x60 */
+  volatile unsigned long inttypr2;  /* Interrupt Type     Mask register 20x64 */
+};
+
+struct avalanche_exctrl_regs   /* Avalanche Exception control registers */
+{
+  volatile unsigned long exsr;      /* Exceptions Status/Set register    0x80 */
+  volatile unsigned long reserved;                                     /*0x84 */
+  volatile unsigned long excr;      /* Exceptions Clear Register         0x88 */
+  volatile unsigned long reserved1;                                    /*0x8c */
+  volatile unsigned long exiesr;    /* Exceptions Interrupt Enable (set) 0x90 */
+  volatile unsigned long reserved2;                                    /*0x94 */
+  volatile unsigned long exiecr;    /* Exceptions Interrupt Enable(clear)0x98 */
+};
+struct avalanche_ipace_regs
+{
+
+  volatile unsigned long ipacep;    /* Interrupt pacing register         0xa0 */
+  volatile unsigned long ipacemap;  /*Interrupt Pacing Map Register      0xa4 */
+  volatile unsigned long ipacemax;  /*Interrupt Pacing Max Register      0xa8 */
+};
+struct avalanche_channel_int_number
+{
+  volatile unsigned long cintnr0;   /* Channel Interrupt Number Register0x200 */
+  volatile unsigned long cintnr1;   /* Channel Interrupt Number Register0x204 */
+  volatile unsigned long cintnr2;   /* Channel Interrupt Number Register0x208 */
+  volatile unsigned long cintnr3;   /* Channel Interrupt Number Register0x20C */
+  volatile unsigned long cintnr4;   /* Channel Interrupt Number Register0x210 */
+  volatile unsigned long cintnr5;   /* Channel Interrupt Number Register0x214 */
+  volatile unsigned long cintnr6;   /* Channel Interrupt Number Register0x218 */
+  volatile unsigned long cintnr7;   /* Channel Interrupt Number Register0x21C */
+  volatile unsigned long cintnr8;   /* Channel Interrupt Number Register0x220 */
+  volatile unsigned long cintnr9;   /* Channel Interrupt Number Register0x224 */
+  volatile unsigned long cintnr10;  /* Channel Interrupt Number Register0x228 */
+  volatile unsigned long cintnr11;  /* Channel Interrupt Number Register0x22C */
+  volatile unsigned long cintnr12;  /* Channel Interrupt Number Register0x230 */
+  volatile unsigned long cintnr13;  /* Channel Interrupt Number Register0x234 */
+  volatile unsigned long cintnr14;  /* Channel Interrupt Number Register0x238 */
+  volatile unsigned long cintnr15;  /* Channel Interrupt Number Register0x23C */
+  volatile unsigned long cintnr16;  /* Channel Interrupt Number Register0x240 */
+  volatile unsigned long cintnr17;  /* Channel Interrupt Number Register0x244 */
+  volatile unsigned long cintnr18;  /* Channel Interrupt Number Register0x248 */
+  volatile unsigned long cintnr19;  /* Channel Interrupt Number Register0x24C */
+  volatile unsigned long cintnr20;  /* Channel Interrupt Number Register0x250 */
+  volatile unsigned long cintnr21;  /* Channel Interrupt Number Register0x254 */
+  volatile unsigned long cintnr22;  /* Channel Interrupt Number Register0x358 */
+  volatile unsigned long cintnr23;  /* Channel Interrupt Number Register0x35C */
+  volatile unsigned long cintnr24;  /* Channel Interrupt Number Register0x260 */
+  volatile unsigned long cintnr25;  /* Channel Interrupt Number Register0x264 */
+  volatile unsigned long cintnr26;  /* Channel Interrupt Number Register0x268 */
+  volatile unsigned long cintnr27;  /* Channel Interrupt Number Register0x26C */
+  volatile unsigned long cintnr28;  /* Channel Interrupt Number Register0x270 */
+  volatile unsigned long cintnr29;  /* Channel Interrupt Number Register0x274 */
+  volatile unsigned long cintnr30;  /* Channel Interrupt Number Register0x278 */
+  volatile unsigned long cintnr31;  /* Channel Interrupt Number Register0x27C */
+  volatile unsigned long cintnr32;  /* Channel Interrupt Number Register0x280 */
+  volatile unsigned long cintnr33;  /* Channel Interrupt Number Register0x284 */
+  volatile unsigned long cintnr34;  /* Channel Interrupt Number Register0x288 */
+  volatile unsigned long cintnr35;  /* Channel Interrupt Number Register0x28C */
+  volatile unsigned long cintnr36;  /* Channel Interrupt Number Register0x290 */
+  volatile unsigned long cintnr37;  /* Channel Interrupt Number Register0x294 */
+  volatile unsigned long cintnr38;  /* Channel Interrupt Number Register0x298 */
+  volatile unsigned long cintnr39;  /* Channel Interrupt Number Register0x29C */
+};
+
+struct avalanche_interrupt_line_to_channel
+{
+  unsigned long int_line0;    /* Start of primary interrupts */
+  unsigned long int_line1;
+  unsigned long int_line2;
+  unsigned long int_line3;
+  unsigned long int_line4;
+  unsigned long int_line5;
+  unsigned long int_line6;
+  unsigned long int_line7;
+  unsigned long int_line8;
+  unsigned long int_line9;
+  unsigned long int_line10;
+  unsigned long int_line11;
+  unsigned long int_line12;
+  unsigned long int_line13;
+  unsigned long int_line14;
+  unsigned long int_line15;
+  unsigned long int_line16;
+  unsigned long int_line17;
+  unsigned long int_line18;
+  unsigned long int_line19;
+  unsigned long int_line20;
+  unsigned long int_line21;
+  unsigned long int_line22;
+  unsigned long int_line23;
+  unsigned long int_line24;
+  unsigned long int_line25;
+  unsigned long int_line26;
+  unsigned long int_line27;
+  unsigned long int_line28;
+  unsigned long int_line29;
+  unsigned long int_line30;
+  unsigned long int_line31;
+  unsigned long int_line32;
+  unsigned long int_line33;
+  unsigned long int_line34;
+  unsigned long int_line35;
+  unsigned long int_line36;
+  unsigned long int_line37;
+  unsigned long int_line38;
+  unsigned long int_line39;
+};
+
+
+/* Interrupt Line #'s  (Sangam peripherals) */
+
+/*------------------------------*/
+/* Sangam primary interrupts */
+/*------------------------------*/
+
+#define UNIFIED_SECONDARY_INTERRUPT  0
+#define AVALANCHE_EXT_INT_0          1
+#define AVALANCHE_EXT_INT_1          2
+/*  Line #3  Reserved               */
+/*  Line #4  Reserved               */
+#define AVALANCHE_TIMER_0_INT        5
+#define AVALANCHE_TIMER_1_INT        6
+#define AVALANCHE_UART0_INT          7
+#define AVALANCHE_UART1_INT          8
+#define AVALANCHE_PDMA_INT0          9
+#define AVALANCHE_PDMA_INT1          10
+/*  Line #11  Reserved               */
+/*  Line #12  Reserved               */
+/*  Line #13  Reserved               */
+/*  Line #14  Reserved               */
+#define AVALANCHE_ATM_SAR_INT        15
+/*  Line #16  Reserved               */
+/*  Line #17  Reserved               */
+/*  Line #18  Reserved               */
+#define AVALANCHE_MAC0_INT           19
+/*  Line #20  Reserved               */
+#define AVALANCHE_VLYNQ0_INT         21
+#define AVALANCHE_CODEC_WAKE_INT     22
+/*  Line #23  Reserved               */
+#define AVALANCHE_USB_INT            24
+#define AVALANCHE_VLYNQ1_INT         25
+/*  Line #26  Reserved               */
+/*  Line #27  Reserved               */
+#define AVALANCHE_MAC1_INT           28
+#define AVALANCHE_I2CM_INT           29
+#define AVALANCHE_PDMA_INT2          30
+#define AVALANCHE_PDMA_INT3          31
+/*  Line #32  Reserved               */
+/*  Line #33  Reserved               */
+/*  Line #34  Reserved               */
+/*  Line #35  Reserved               */
+/*  Line #36  Reserved               */
+#define AVALANCHE_VDMA_VT_RX_INT     37
+#define AVALANCHE_VDMA_VT_TX_INT     38
+#define AVALANCHE_ADSLSS_INT         39
+
+/*-----------------------------------*/
+/* Sangam Secondary Interrupts    */
+/*-----------------------------------*/
+#define PRIMARY_INTS                 40
+
+#define EMIF_INT                    (7 + PRIMARY_INTS)
+
+
+extern void avalanche_int_set(int channel, int line);
+
+
+#endif /* _AVALANCHE_INTC_H */
diff -urN kernel-base/include/asm-mips/ar7/if_port.h kernel-tmp2/include/asm-mips/ar7/if_port.h
--- kernel-base/include/asm-mips/ar7/if_port.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/include/asm-mips/ar7/if_port.h	2005-07-10 06:40:39.623260936 +0200
@@ -0,0 +1,26 @@
+/*******************************************************************************   
+ * FILE PURPOSE:    Interface port id Header file                                      
+ *******************************************************************************   
+ * FILE NAME:       if_port.h                                                   
+ *                                                                                 
+ * DESCRIPTION:     Header file carrying information about port ids of interfaces                             
+ *                                                                                 
+ *                                                                                 
+ * (C) Copyright 2003, Texas Instruments, Inc                                      
+ ******************************************************************************/   
+#ifndef _IF_PORT_H_
+#define _IF_PORT_H_
+
+#define AVALANCHE_CPMAC_LOW_PORT_ID         0
+#define AVALANCHE_CPMAC_HIGH_PORT_ID        1    
+#define AVALANCHE_USB_PORT_ID               2
+#define AVALANCHE_WLAN_PORT_ID              3
+
+
+#define AVALANCHE_MARVELL_BASE_PORT_ID      4
+
+/* The marvell ports occupy port ids from  4 to 8 */
+/* so the next port id number should start at 9   */
+
+
+#endif /* _IF_PORT_H_ */
diff -urN kernel-base/include/asm-mips/ar7/sangam_boards.h kernel-tmp2/include/asm-mips/ar7/sangam_boards.h
--- kernel-base/include/asm-mips/ar7/sangam_boards.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/include/asm-mips/ar7/sangam_boards.h	2005-07-10 06:40:39.623260936 +0200
@@ -0,0 +1,77 @@
+#ifndef _SANGAM_BOARDS_H
+#define _SANGAM_BOARDS_H
+
+// Let us define board specific information here. 
+
+
+#if defined(CONFIG_AR7DB)
+
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x55555555  
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+
+#endif
+
+
+#if defined(CONFIG_AR7RD)
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x2
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined(CONFIG_AR7WI)
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x2
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined(CONFIG_AR7V)
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x2
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined(CONFIG_AR7WRD) 
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x00010000
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined(CONFIG_AR7VWI) 
+#define AFECLK_FREQ                                 35328000
+#define REFCLK_FREQ                                 25000000
+#define OSC3_FREQ                                   24000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x80000000
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x00010000
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0x80000000
+#endif
+
+
+#if defined CONFIG_SEAD2
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0xAAAAAAAA
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x55555555
+#define AVALANCHE_LOW_CPMAC_MDIX_MASK               0
+#include <asm/mips-boards/sead.h>
+#endif
+
+
+#endif
diff -urN kernel-base/include/asm-mips/ar7/sangam.h kernel-tmp2/include/asm-mips/ar7/sangam.h
--- kernel-base/include/asm-mips/ar7/sangam.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-tmp2/include/asm-mips/ar7/sangam.h	2005-07-10 06:40:39.624260784 +0200
@@ -0,0 +1,180 @@
+#ifndef _SANGAM_H_
+#define _SANGAM_H_
+
+#include <linux/config.h>
+#include <asm/addrspace.h>
+
+/*----------------------------------------------------
+ * Sangam's Module Base Addresses
+ *--------------------------------------------------*/
+#define AVALANCHE_ADSL_SUB_SYS_MEM_BASE       (KSEG1ADDR(0x01000000)) /* AVALANCHE ADSL Mem Base */
+#define AVALANCHE_BROADBAND_INTERFACE__BASE   (KSEG1ADDR(0x02000000)) /* AVALANCHE BBIF */        
+#define AVALANCHE_ATM_SAR_BASE                (KSEG1ADDR(0x03000000)) /* AVALANCHE ATM SAR */
+#define AVALANCHE_USB_SLAVE_BASE              (KSEG1ADDR(0x03400000)) /* AVALANCHE USB SLAVE */
+#define AVALANCHE_LOW_VLYNQ_MEM_MAP_BASE      (KSEG1ADDR(0x04000000)) /* AVALANCHE VLYNQ 0 Mem map */
+#define AVALANCHE_LOW_CPMAC_BASE              (KSEG1ADDR(0x08610000)) /* AVALANCHE CPMAC 0 */
+#define AVALANCHE_EMIF_CONTROL_BASE           (KSEG1ADDR(0x08610800)) /* AVALANCHE EMIF */
+#define AVALANCHE_GPIO_BASE                   (KSEG1ADDR(0x08610900)) /* AVALANCHE GPIO */
+#define AVALANCHE_CLOCK_CONTROL_BASE          (KSEG1ADDR(0x08610A00)) /* AVALANCHE Clock Control */
+#define AVALANCHE_WATCHDOG_TIMER_BASE         (KSEG1ADDR(0x08610B00)) /* AVALANCHE Watch Dog Timer */  
+#define AVALANCHE_TIMER0_BASE                 (KSEG1ADDR(0x08610C00)) /* AVALANCHE Timer 1 */  
+#define AVALANCHE_TIMER1_BASE                 (KSEG1ADDR(0x08610D00)) /* AVALANCHE Timer 2 */  
+#define AVALANCHE_UART0_REGS_BASE             (KSEG1ADDR(0x08610E00)) /* AVALANCHE UART 0 */
+#define AVALANCHE_UART1_REGS_BASE             (KSEG1ADDR(0x08610F00)) /* AVALANCHE UART 0 */
+#define AVALANCHE_I2C_BASE                    (KSEG1ADDR(0x08611000)) /* AVALANCHE I2C */
+#define AVALANCHE_USB_SLAVE_CONTROL_BASE      (KSEG1ADDR(0x08611200)) /* AVALANCHE USB DMA */
+#define AVALANCHE_MCDMA0_CTRL_BASE            (KSEG1ADDR(0x08611400)) /* AVALANCHE MC DMA 0 (channels 0-3) */
+#define AVALANCHE_RESET_CONTROL_BASE          (KSEG1ADDR(0x08611600)) /* AVALANCHE Reset Control */
+#define AVALANCHE_BIST_CONTROL_BASE           (KSEG1ADDR(0x08611700)) /* AVALANCHE BIST Control */
+#define AVALANCHE_LOW_VLYNQ_CONTROL_BASE      (KSEG1ADDR(0x08611800)) /* AVALANCHE VLYNQ0 Control */
+#define AVALANCHE_DEVICE_CONFIG_LATCH_BASE    (KSEG1ADDR(0x08611A00)) /* AVALANCHE Device Config Latch */
+#define AVALANCHE_HIGH_VLYNQ_CONTROL_BASE     (KSEG1ADDR(0x08611C00)) /* AVALANCHE VLYNQ1 Control */
+#define AVALANCHE_MDIO_BASE                   (KSEG1ADDR(0x08611E00)) /* AVALANCHE MDIO    */
+#define AVALANCHE_FSER_BASE                   (KSEG1ADDR(0x08612000)) /* AVALANCHE FSER base */
+#define AVALANCHE_INTC_BASE                   (KSEG1ADDR(0x08612400)) /* AVALANCHE INTC  */
+#define AVALANCHE_HIGH_CPMAC_BASE             (KSEG1ADDR(0x08612800)) /* AVALANCHE CPMAC 1 */
+#define AVALANCHE_HIGH_VLYNQ_MEM_MAP_BASE     (KSEG1ADDR(0x0C000000)) /* AVALANCHE VLYNQ 1 Mem map */
+
+#define AVALANCHE_SDRAM_BASE                  0x14000000UL
+
+
+/*----------------------------------------------------
+ * Sangam Interrupt Map (Primary Interrupts)
+ *--------------------------------------------------*/
+
+#define AVALANCHE_UNIFIED_SECONDARY_INT            0
+#define AVALANCHE_EXT_INT_0                        1
+#define AVALANCHE_EXT_INT_1                        2
+/* Line#  3 to 4 are reserved                            */
+#define AVALANCHE_TIMER_0_INT                      5
+#define AVALANCHE_TIMER_1_INT                      6
+#define AVALANCHE_UART0_INT                        7
+#define AVALANCHE_UART1_INT                        8
+#define AVALANCHE_DMA_INT0                         9
+#define AVALANCHE_DMA_INT1                        10
+/* Line# 11 to 14 are reserved                    */
+#define AVALANCHE_ATM_SAR_INT                     15
+/* Line# 16 to 18 are reserved                    */
+#define AVALANCHE_LOW_CPMAC_INT                   19
+/* Line# 20 is reserved                           */
+#define AVALANCHE_LOW_VLYNQ_INT                   21
+#define AVALANCHE_CODEC_WAKEUP_INT                22
+/* Line# 23 is reserved                           */
+#define AVALANCHE_USB_SLAVE_INT                   24
+#define AVALANCHE_HIGH_VLYNQ_INT                  25
+/* Line# 26 to 27 are reserved                    */
+#define AVALANCHE_UNIFIED_PHY_INT                 28
+#define AVALANCHE_I2C_INT                         29
+#define AVALANCHE_DMA_INT2                        30
+#define AVALANCHE_DMA_INT3                        31
+/* Line# 32 is reserved                           */
+#define AVALANCHE_HIGH_CPMAC_INT                  33
+/* Line# 34 to 36 is reserved                     */
+#define AVALANCHE_VDMA_VT_RX_INT                  37
+#define AVALANCHE_VDMA_VT_TX_INT                  38
+#define AVALANCHE_ADSL_SUB_SYSTEM_INT             39
+
+
+#define AVALANCHE_EMIF_INT                        47
+
+
+
+/*-----------------------------------------------------------
+ * Sangam's Reset Bits
+ *---------------------------------------------------------*/
+
+#define AVALANCHE_UART0_RESET_BIT                  0
+#define AVALANCHE_UART1_RESET_BIT                  1
+#define AVALANCHE_I2C_RESET_BIT                    2
+#define AVALANCHE_TIMER0_RESET_BIT                 3
+#define AVALANCHE_TIMER1_RESET_BIT                 4
+/* Reset bit  5 is reserved.                       */
+#define AVALANCHE_GPIO_RESET_BIT                   6
+#define AVALANCHE_ADSL_SUB_SYS_RESET_BIT           7
+#define AVALANCHE_USB_SLAVE_RESET_BIT              8
+#define AVALANCHE_ATM_SAR_RESET_BIT                9
+/* Reset bit 10 is reserved.                      */
+#define AVALANCHE_VDMA_VT_RESET_BIT               11
+#define AVALANCHE_FSER_RESET_BIT                  12
+/* Reset bit 13 to 15 are reserved                */
+#define AVALANCHE_HIGH_VLYNQ_RESET_BIT            16
+#define AVALANCHE_LOW_CPMAC_RESET_BIT             17
+#define AVALANCHE_MCDMA_RESET_BIT                 18
+#define AVALANCHE_BIST_RESET_BIT                  19
+#define AVALANCHE_LOW_VLYNQ_RESET_BIT             20
+#define AVALANCHE_HIGH_CPMAC_RESET_BIT            21
+#define AVALANCHE_MDIO_RESET_BIT                  22
+#define AVALANCHE_ADSL_SUB_SYS_DSP_RESET_BIT      23
+/* Reset bit 24 to 25 are reserved                */
+#define AVALANCHE_LOW_EPHY_RESET_BIT              26
+/* Reset bit 27 to 31 are reserved                */
+
+
+#define AVALANCHE_POWER_MODULE_USBSP               0
+#define AVALANCHE_POWER_MODULE_WDTP                1
+#define AVALANCHE_POWER_MODULE_UT0P                2
+#define AVALANCHE_POWER_MODULE_UT1P                3
+#define AVALANCHE_POWER_MODULE_IICP                4
+#define AVALANCHE_POWER_MODULE_VDMAP               5
+#define AVALANCHE_POWER_MODULE_GPIOP               6
+#define AVALANCHE_POWER_MODULE_VLYNQ1P             7
+#define AVALANCHE_POWER_MODULE_SARP                8
+#define AVALANCHE_POWER_MODULE_ADSLP               9
+#define AVALANCHE_POWER_MODULE_EMIFP              10
+#define AVALANCHE_POWER_MODULE_ADSPP              12
+#define AVALANCHE_POWER_MODULE_RAMP               13
+#define AVALANCHE_POWER_MODULE_ROMP               14
+#define AVALANCHE_POWER_MODULE_DMAP               15
+#define AVALANCHE_POWER_MODULE_BISTP              16
+#define AVALANCHE_POWER_MODULE_TIMER0P            18
+#define AVALANCHE_POWER_MODULE_TIMER1P            19
+#define AVALANCHE_POWER_MODULE_EMAC0P             20
+#define AVALANCHE_POWER_MODULE_EMAC1P             22
+#define AVALANCHE_POWER_MODULE_EPHYP              24
+#define AVALANCHE_POWER_MODULE_VLYNQ0P            27
+
+
+
+
+
+/*
+ * Sangam board vectors
+ */
+
+#define AVALANCHE_VECS       (KSEG1ADDR(AVALANCHE_SDRAM_BASE))
+#define AVALANCHE_VECS_KSEG0 (KSEG0ADDR(AVALANCHE_SDRAM_BASE))
+
+/*-----------------------------------------------------------------------------
+ * Sangam's system register.
+ * 
+ *---------------------------------------------------------------------------*/
+#define AVALANCHE_DCL_BOOTCR          (KSEG1ADDR(0x08611A00))
+#define AVALANCHE_EMIF_SDRAM_CFG      (AVALANCHE_EMIF_CONTROL_BASE + 0x8)
+#define AVALANCHE_RST_CTRL_PRCR       (KSEG1ADDR(0x08611600))
+#define AVALANCHE_RST_CTRL_SWRCR      (KSEG1ADDR(0x08611604))
+#define AVALANCHE_RST_CTRL_RSR        (KSEG1ADDR(0x08611600))
+
+#define AVALANCHE_POWER_CTRL_PDCR     (KSEG1ADDR(0x08610A00))
+#define AVALANCHE_WAKEUP_CTRL_WKCR    (KSEG1ADDR(0x08610A0C))
+
+#define AVALANCHE_GPIO_DATA_IN        (AVALANCHE_GPIO_BASE +  0x0)
+#define AVALANCHE_GPIO_DATA_OUT       (AVALANCHE_GPIO_BASE +  0x4)
+#define AVALANCHE_GPIO_DIR            (AVALANCHE_GPIO_BASE +  0x8)    
+#define AVALANCHE_GPIO_ENBL           (AVALANCHE_GPIO_BASE +  0xC)
+#define AVALANCHE_CVR                 (AVALANCHE_GPIO_BASE +  0x14)
+
+/*
+ * Yamon Prom print address.
+ */
+#define AVALANCHE_YAMON_FUNCTION_BASE             (KSEG1ADDR(0x10000500))
+#define AVALANCHE_YAMON_PROM_PRINT_COUNT_ADDR     (AVALANCHE_YAMON_FUNCTION_BASE + 0x4)  /* print_count function */
+#define AVALANCHE_YAMON_PROM_PRINT_ADDR           (AVALANCHE_YAMON_FUNCTION_BASE + 0x34)
+
+#define AVALANCHE_BASE_BAUD       ( 3686400 / 16 )
+
+#define  AVALANCHE_GPIO_PIN_COUNT         32             
+#define  AVALANCHE_GPIO_OFF_MAP           {0xF34FFFC0} 
+
+#include "sangam_boards.h"
+
+#endif /*_SANGAM_H_ */
diff -urN kernel-base/include/asm-mips/io.h kernel-tmp2/include/asm-mips/io.h
--- kernel-base/include/asm-mips/io.h	2005-07-10 03:00:44.797179400 +0200
+++ kernel-tmp2/include/asm-mips/io.h	2005-07-10 06:40:39.624260784 +0200
@@ -63,8 +63,12 @@
 #ifdef CONFIG_64BIT_PHYS_ADDR
 #define page_to_phys(page)	((u64)(page - mem_map) << PAGE_SHIFT)
 #else
+#ifdef CONFIG_AR7_PAGING
+#define page_to_phys(page)	(((page - mem_map) << PAGE_SHIFT) + CONFIG_AR7_MEMORY)
+#else 
 #define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
 #endif
+#endif
 
 #define IO_SPACE_LIMIT 0xffff
 
diff -urN kernel-base/include/asm-mips/irq.h kernel-tmp2/include/asm-mips/irq.h
--- kernel-base/include/asm-mips/irq.h	2005-07-10 03:00:44.798179248 +0200
+++ kernel-tmp2/include/asm-mips/irq.h	2005-07-10 06:40:39.624260784 +0200
@@ -14,7 +14,12 @@
 #include <linux/config.h>
 #include <linux/linkage.h>
 
+#ifdef CONFIG_AR7
+#include <asm/ar7/avalanche_intc.h>
+#define NR_IRQS AVALANCHE_INT_END + 1
+#else
 #define NR_IRQS 128		/* Largest number of ints of all machines.  */
+#endif
 
 #ifdef CONFIG_I8259
 static inline int irq_cannonicalize(int irq)
diff -urN kernel-base/include/asm-mips/page.h kernel-tmp2/include/asm-mips/page.h
--- kernel-base/include/asm-mips/page.h	2005-07-10 03:00:44.798179248 +0200
+++ kernel-tmp2/include/asm-mips/page.h	2005-07-10 06:40:39.625260632 +0200
@@ -129,7 +129,11 @@
 
 #define __pa(x)		((unsigned long) (x) - PAGE_OFFSET)
 #define __va(x)		((void *)((unsigned long) (x) + PAGE_OFFSET))
+#ifdef CONFIG_AR7_PAGING
+#define virt_to_page(kaddr)	phys_to_page(__pa(kaddr))
+#else
 #define virt_to_page(kaddr)	(mem_map + (__pa(kaddr) >> PAGE_SHIFT))
+#endif
 #define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
 
 #define VM_DATA_DEFAULT_FLAGS  (VM_READ | VM_WRITE | VM_EXEC | \
diff -urN kernel-base/include/asm-mips/pgtable-32.h kernel-tmp2/include/asm-mips/pgtable-32.h
--- kernel-base/include/asm-mips/pgtable-32.h	2005-07-10 03:00:44.798179248 +0200
+++ kernel-tmp2/include/asm-mips/pgtable-32.h	2005-07-10 06:40:39.625260632 +0200
@@ -108,7 +108,18 @@
  * and a page entry and page directory to the page they refer to.
  */
 
-#ifdef CONFIG_CPU_VR41XX
+#if defined(CONFIG_AR7_PAGING)
+#define mk_pte(page, pgprot)						\
+({									\
+	pte_t   __pte;							\
+									\
+	pte_val(__pte) = ((phys_t)(page - mem_map) << (PAGE_SHIFT) |	\
+		CONFIG_AR7_MEMORY) |					\
+	pgprot_val(pgprot);						\
+									\
+	__pte;								\
+})
+#elif defined(CONFIG_CPU_VR41XX)
 #define mk_pte(page, pgprot)                                            \
 ({                                                                      \
         pte_t   __pte;                                                  \
@@ -130,6 +141,7 @@
 })
 #endif
 
+
 static inline pte_t mk_pte_phys(phys_t physpage, pgprot_t pgprot)
 {
 #ifdef CONFIG_CPU_VR41XX
@@ -175,7 +187,10 @@
 		set_pte(ptep, __pte(0));
 }
 
-#ifdef CONFIG_CPU_VR41XX
+#if defined(CONFIG_AR7_PAGING)
+#define phys_to_page(phys)	(mem_map + (((phys)-CONFIG_AR7_MEMORY) >> PAGE_SHIFT))
+#define pte_page(x)		phys_to_page(pte_val(x))
+#elif defined(CONFIG_CPU_VR41XX)
 #define pte_page(x)  (mem_map+((unsigned long)(((x).pte_low >> (PAGE_SHIFT+2)))))
 #define __mk_pte(page_nr,pgprot) __pte(((page_nr) << (PAGE_SHIFT+2)) | pgprot_val(pgprot))
 #else
diff -urN kernel-base/include/asm-mips/serial.h kernel-tmp2/include/asm-mips/serial.h
--- kernel-base/include/asm-mips/serial.h	2005-07-10 03:00:44.799179096 +0200
+++ kernel-tmp2/include/asm-mips/serial.h	2005-07-10 06:40:39.625260632 +0200
@@ -65,6 +65,15 @@
 
 #define C_P(card,port) (((card)<<6|(port)<<3) + 1)
 
+#ifdef CONFIG_AR7
+#include <asm/ar7/ar7.h>
+#define AR7_SERIAL_PORT_DEFNS  \
+	{ 0, AR7_BASE_BAUD, AR7_UART0_REGS_BASE, LNXINTNUM(AVALANCHE_UART0_INT), STD_COM_FLAGS }, \
+	{ 0, AR7_BASE_BAUD, AR7_UART1_REGS_BASE, LNXINTNUM(AVALANCHE_UART1_INT), STD_COM_FLAGS }, 
+#else 
+#define AR7_SERIAL_PORT_DEFNS
+#endif
+
 #ifdef CONFIG_MIPS_JAZZ
 #define _JAZZ_SERIAL_INIT(int, base)					\
 	{ .baud_base = JAZZ_BASE_BAUD, .irq = int, .flags = STD_COM_FLAGS,	\
@@ -468,6 +477,7 @@
 #endif
 
 #define SERIAL_PORT_DFNS			\
+	AR7_SERIAL_PORT_DEFNS			\
 	ATLAS_SERIAL_PORT_DEFNS			\
 	AU1000_SERIAL_PORT_DEFNS		\
 	COBALT_SERIAL_PORT_DEFNS		\
diff -urN kernel-base/Makefile kernel-tmp2/Makefile
--- kernel-base/Makefile	2005-07-10 03:00:44.799179096 +0200
+++ kernel-tmp2/Makefile	2005-07-10 06:40:39.626260480 +0200
@@ -91,7 +91,7 @@
 
 CPPFLAGS := -D__KERNEL__ -I$(HPATH)
 
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -O2 \
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -Os \
 	  -fno-strict-aliasing -fno-common
 ifndef CONFIG_FRAME_POINTER
 CFLAGS += -fomit-frame-pointer
