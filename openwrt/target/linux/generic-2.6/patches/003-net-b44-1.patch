diff -ur linux-2.6.15-rc5/drivers/net/b44.c linux-2.6.15-rc5-openwrt/drivers/net/b44.c
--- linux-2.6.15-rc5/drivers/net/b44.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-openwrt/drivers/net/b44.c	2005-08-15 02:20:18.000000000 +0200
@@ -18,7 +18,7 @@
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/init.h>
-#include <linux/dma-mapping.h>
+#include <linux/version.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -28,8 +28,8 @@
 
 #define DRV_MODULE_NAME		"b44"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"0.97"
-#define DRV_MODULE_RELDATE	"Nov 30, 2005"
+#define DRV_MODULE_VERSION	"0.95"
+#define DRV_MODULE_RELDATE	"Aug 3, 2004"
 
 #define B44_DEF_MSG_ENABLE	  \
 	(NETIF_MSG_DRV		| \
@@ -101,35 +101,10 @@
 static void b44_halt(struct b44 *);
 static void b44_init_rings(struct b44 *);
 static void b44_init_hw(struct b44 *);
-
-static int dma_desc_align_mask;
-static int dma_desc_sync_size;
-
-static const char b44_gstrings[][ETH_GSTRING_LEN] = {
-#define _B44(x...)	# x,
-B44_STAT_REG_DECLARE
-#undef _B44
-};
-
-static inline void b44_sync_dma_desc_for_device(struct pci_dev *pdev,
-                                                dma_addr_t dma_base,
-                                                unsigned long offset,
-                                                enum dma_data_direction dir)
-{
-	dma_sync_single_range_for_device(&pdev->dev, dma_base,
-	                                 offset & dma_desc_align_mask,
-	                                 dma_desc_sync_size, dir);
-}
-
-static inline void b44_sync_dma_desc_for_cpu(struct pci_dev *pdev,
-                                             dma_addr_t dma_base,
-                                             unsigned long offset,
-                                             enum dma_data_direction dir)
-{
-	dma_sync_single_range_for_cpu(&pdev->dev, dma_base,
-	                              offset & dma_desc_align_mask,
-	                              dma_desc_sync_size, dir);
-}
+static int b44_poll(struct net_device *dev, int *budget);
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void b44_poll_controller(struct net_device *dev);
+#endif
 
 static inline unsigned long br32(const struct b44 *bp, unsigned long reg)
 {
@@ -503,10 +478,7 @@
 	for (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL) {
 		*val++ += br32(bp, reg);
 	}
-
-	/* Pad */
-	reg += 8*4UL;
-
+	val = &bp->hw_stats.rx_good_octets;
 	for (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL) {
 		*val++ += br32(bp, reg);
 	}
@@ -657,7 +629,7 @@
 
 	/* Hardware bug work-around, the chip is unable to do PCI DMA
 	   to/from anything above 1GB :-( */
-	if (mapping + RX_PKT_BUF_SZ > B44_DMA_MASK) {
+	if(mapping+RX_PKT_BUF_SZ > B44_DMA_MASK) {
 		/* Sigh... */
 		pci_unmap_single(bp->pdev, mapping, RX_PKT_BUF_SZ,PCI_DMA_FROMDEVICE);
 		dev_kfree_skb_any(skb);
@@ -667,7 +639,7 @@
 		mapping = pci_map_single(bp->pdev, skb->data,
 					 RX_PKT_BUF_SZ,
 					 PCI_DMA_FROMDEVICE);
-		if (mapping + RX_PKT_BUF_SZ > B44_DMA_MASK) {
+		if(mapping+RX_PKT_BUF_SZ > B44_DMA_MASK) {
 			pci_unmap_single(bp->pdev, mapping, RX_PKT_BUF_SZ,PCI_DMA_FROMDEVICE);
 			dev_kfree_skb_any(skb);
 			return -ENOMEM;
@@ -696,11 +668,6 @@
 	dp->ctrl = cpu_to_le32(ctrl);
 	dp->addr = cpu_to_le32((u32) mapping + bp->rx_offset + bp->dma_offset);
 
-	if (bp->flags & B44_FLAG_RX_RING_HACK)
-		b44_sync_dma_desc_for_device(bp->pdev, bp->rx_ring_dma,
-		                             dest_idx * sizeof(dp),
-		                             DMA_BIDIRECTIONAL);
-
 	return RX_PKT_BUF_SZ;
 }
 
@@ -725,11 +692,6 @@
 	pci_unmap_addr_set(dest_map, mapping,
 			   pci_unmap_addr(src_map, mapping));
 
-	if (bp->flags & B44_FLAG_RX_RING_HACK)
-		b44_sync_dma_desc_for_cpu(bp->pdev, bp->rx_ring_dma,
-		                          src_idx * sizeof(src_desc),
-		                          DMA_BIDIRECTIONAL);
-
 	ctrl = src_desc->ctrl;
 	if (dest_idx == (B44_RX_RING_SIZE - 1))
 		ctrl |= cpu_to_le32(DESC_CTRL_EOT);
@@ -738,14 +700,8 @@
 
 	dest_desc->ctrl = ctrl;
 	dest_desc->addr = src_desc->addr;
-
 	src_map->skb = NULL;
 
-	if (bp->flags & B44_FLAG_RX_RING_HACK)
-		b44_sync_dma_desc_for_device(bp->pdev, bp->rx_ring_dma,
-		                             dest_idx * sizeof(dest_desc),
-		                             DMA_BIDIRECTIONAL);
-
 	pci_dma_sync_single_for_device(bp->pdev, src_desc->addr,
 				       RX_PKT_BUF_SZ,
 				       PCI_DMA_FROMDEVICE);
@@ -894,10 +850,11 @@
 {
 	struct net_device *dev = dev_id;
 	struct b44 *bp = netdev_priv(dev);
+	unsigned long flags;
 	u32 istat, imask;
 	int handled = 0;
 
-	spin_lock(&bp->lock);
+	spin_lock_irqsave(&bp->lock, flags);
 
 	istat = br32(bp, B44_ISTAT);
 	imask = br32(bp, B44_IMASK);
@@ -908,12 +865,6 @@
 	istat &= imask;
 	if (istat) {
 		handled = 1;
-
-		if (unlikely(!netif_running(dev))) {
-			printk(KERN_INFO "%s: late interrupt.\n", dev->name);
-			goto irq_ack;
-		}
-
 		if (netif_rx_schedule_prep(dev)) {
 			/* NOTE: These writes are posted by the readback of
 			 *       the ISTAT register below.
@@ -926,11 +877,10 @@
 			       dev->name);
 		}
 
-irq_ack:
 		bw32(bp, B44_ISTAT, istat);
 		br32(bp, B44_ISTAT);
 	}
-	spin_unlock(&bp->lock);
+	spin_unlock_irqrestore(&bp->lock, flags);
 	return IRQ_RETVAL(handled);
 }
 
@@ -958,7 +908,6 @@
 {
 	struct b44 *bp = netdev_priv(dev);
 	struct sk_buff *bounce_skb;
-	int rc = NETDEV_TX_OK;
 	dma_addr_t mapping;
 	u32 len, entry, ctrl;
 
@@ -968,28 +917,29 @@
 	/* This is a hard error, log it. */
 	if (unlikely(TX_BUFFS_AVAIL(bp) < 1)) {
 		netif_stop_queue(dev);
+		spin_unlock_irq(&bp->lock);
 		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
 		       dev->name);
-		goto err_out;
+		return 1;
 	}
 
 	mapping = pci_map_single(bp->pdev, skb->data, len, PCI_DMA_TODEVICE);
-	if (mapping + len > B44_DMA_MASK) {
+	if(mapping+len > B44_DMA_MASK) {
 		/* Chip can't handle DMA to/from >1GB, use bounce buffer */
 		pci_unmap_single(bp->pdev, mapping, len, PCI_DMA_TODEVICE);
 
 		bounce_skb = __dev_alloc_skb(TX_PKT_BUF_SZ,
 					     GFP_ATOMIC|GFP_DMA);
 		if (!bounce_skb)
-			goto err_out;
+			return NETDEV_TX_BUSY;
 
 		mapping = pci_map_single(bp->pdev, bounce_skb->data,
 					 len, PCI_DMA_TODEVICE);
-		if (mapping + len > B44_DMA_MASK) {
+		if(mapping+len > B44_DMA_MASK) {
 			pci_unmap_single(bp->pdev, mapping,
 					 len, PCI_DMA_TODEVICE);
 			dev_kfree_skb_any(bounce_skb);
-			goto err_out;
+			return NETDEV_TX_BUSY;
 		}
 
 		memcpy(skb_put(bounce_skb, len), skb->data, skb->len);
@@ -1009,11 +959,6 @@
 	bp->tx_ring[entry].ctrl = cpu_to_le32(ctrl);
 	bp->tx_ring[entry].addr = cpu_to_le32((u32) mapping+bp->dma_offset);
 
-	if (bp->flags & B44_FLAG_TX_RING_HACK)
-		b44_sync_dma_desc_for_device(bp->pdev, bp->tx_ring_dma,
-		                             entry * sizeof(bp->tx_ring[0]),
-		                             DMA_TO_DEVICE);
-
 	entry = NEXT_TX(entry);
 
 	bp->tx_prod = entry;
@@ -1029,16 +974,11 @@
 	if (TX_BUFFS_AVAIL(bp) < 1)
 		netif_stop_queue(dev);
 
-	dev->trans_start = jiffies;
-
-out_unlock:
 	spin_unlock_irq(&bp->lock);
 
-	return rc;
+	dev->trans_start = jiffies;
 
-err_out:
-	rc = NETDEV_TX_BUSY;
-	goto out_unlock;
+	return 0;
 }
 
 static int b44_change_mtu(struct net_device *dev, int new_mtu)
@@ -1112,7 +1052,8 @@
  *
  * The chip has been shut down and the driver detached from
  * the networking, so no interrupts or new tx packets will
- * end up in the driver.
+ * end up in the driver.  bp->lock is not held and we are not
+ * in an interrupt context and thus may sleep.
  */
 static void b44_init_rings(struct b44 *bp)
 {
@@ -1123,16 +1064,6 @@
 	memset(bp->rx_ring, 0, B44_RX_RING_BYTES);
 	memset(bp->tx_ring, 0, B44_TX_RING_BYTES);
 
-	if (bp->flags & B44_FLAG_RX_RING_HACK)
-		dma_sync_single_for_device(&bp->pdev->dev, bp->rx_ring_dma,
-		                           DMA_TABLE_BYTES,
-		                           PCI_DMA_BIDIRECTIONAL);
-
-	if (bp->flags & B44_FLAG_TX_RING_HACK)
-		dma_sync_single_for_device(&bp->pdev->dev, bp->tx_ring_dma,
-		                           DMA_TABLE_BYTES,
-		                           PCI_DMA_TODEVICE);
-
 	for (i = 0; i < bp->rx_pending; i++) {
 		if (b44_alloc_rx_skb(bp, -1, i) < 0)
 			break;
@@ -1145,33 +1076,23 @@
  */
 static void b44_free_consistent(struct b44 *bp)
 {
-	kfree(bp->rx_buffers);
-	bp->rx_buffers = NULL;
-	kfree(bp->tx_buffers);
-	bp->tx_buffers = NULL;
+	if (bp->rx_buffers) {
+		kfree(bp->rx_buffers);
+		bp->rx_buffers = NULL;
+	}
+	if (bp->tx_buffers) {
+		kfree(bp->tx_buffers);
+		bp->tx_buffers = NULL;
+	}
 	if (bp->rx_ring) {
-		if (bp->flags & B44_FLAG_RX_RING_HACK) {
-			dma_unmap_single(&bp->pdev->dev, bp->rx_ring_dma,
-				         DMA_TABLE_BYTES,
-				         DMA_BIDIRECTIONAL);
-			kfree(bp->rx_ring);
-		} else
-			pci_free_consistent(bp->pdev, DMA_TABLE_BYTES,
-					    bp->rx_ring, bp->rx_ring_dma);
+		pci_free_consistent(bp->pdev, DMA_TABLE_BYTES,
+				    bp->rx_ring, bp->rx_ring_dma);
 		bp->rx_ring = NULL;
-		bp->flags &= ~B44_FLAG_RX_RING_HACK;
 	}
 	if (bp->tx_ring) {
-		if (bp->flags & B44_FLAG_TX_RING_HACK) {
-			dma_unmap_single(&bp->pdev->dev, bp->tx_ring_dma,
-				         DMA_TABLE_BYTES,
-				         DMA_TO_DEVICE);
-			kfree(bp->tx_ring);
-		} else
-			pci_free_consistent(bp->pdev, DMA_TABLE_BYTES,
-					    bp->tx_ring, bp->tx_ring_dma);
+		pci_free_consistent(bp->pdev, DMA_TABLE_BYTES,
+				    bp->tx_ring, bp->tx_ring_dma);
 		bp->tx_ring = NULL;
-		bp->flags &= ~B44_FLAG_TX_RING_HACK;
 	}
 }
 
@@ -1184,67 +1105,25 @@
 	int size;
 
 	size  = B44_RX_RING_SIZE * sizeof(struct ring_info);
-	bp->rx_buffers = kzalloc(size, GFP_KERNEL);
+	bp->rx_buffers = kmalloc(size, GFP_KERNEL);
 	if (!bp->rx_buffers)
 		goto out_err;
+	memset(bp->rx_buffers, 0, size);
 
 	size = B44_TX_RING_SIZE * sizeof(struct ring_info);
-	bp->tx_buffers = kzalloc(size, GFP_KERNEL);
+	bp->tx_buffers = kmalloc(size, GFP_KERNEL);
 	if (!bp->tx_buffers)
 		goto out_err;
+	memset(bp->tx_buffers, 0, size);
 
 	size = DMA_TABLE_BYTES;
 	bp->rx_ring = pci_alloc_consistent(bp->pdev, size, &bp->rx_ring_dma);
-	if (!bp->rx_ring) {
-		/* Allocation may have failed due to pci_alloc_consistent
-		   insisting on use of GFP_DMA, which is more restrictive
-		   than necessary...  */
-		struct dma_desc *rx_ring;
-		dma_addr_t rx_ring_dma;
-
-		rx_ring = kzalloc(size, GFP_KERNEL);
-		if (!rx_ring)
-			goto out_err;
-
-		rx_ring_dma = dma_map_single(&bp->pdev->dev, rx_ring,
-		                             DMA_TABLE_BYTES,
-		                             DMA_BIDIRECTIONAL);
-
-		if (rx_ring_dma + size > B44_DMA_MASK) {
-			kfree(rx_ring);
-			goto out_err;
-		}
-
-		bp->rx_ring = rx_ring;
-		bp->rx_ring_dma = rx_ring_dma;
-		bp->flags |= B44_FLAG_RX_RING_HACK;
-	}
+	if (!bp->rx_ring)
+		goto out_err;
 
 	bp->tx_ring = pci_alloc_consistent(bp->pdev, size, &bp->tx_ring_dma);
-	if (!bp->tx_ring) {
-		/* Allocation may have failed due to pci_alloc_consistent
-		   insisting on use of GFP_DMA, which is more restrictive
-		   than necessary...  */
-		struct dma_desc *tx_ring;
-		dma_addr_t tx_ring_dma;
-
-		tx_ring = kzalloc(size, GFP_KERNEL);
-		if (!tx_ring)
-			goto out_err;
-
-		tx_ring_dma = dma_map_single(&bp->pdev->dev, tx_ring,
-		                             DMA_TABLE_BYTES,
-		                             DMA_TO_DEVICE);
-
-		if (tx_ring_dma + size > B44_DMA_MASK) {
-			kfree(tx_ring);
-			goto out_err;
-		}
-
-		bp->tx_ring = tx_ring;
-		bp->tx_ring_dma = tx_ring_dma;
-		bp->flags |= B44_FLAG_TX_RING_HACK;
-	}
+	if (!bp->tx_ring)
+		goto out_err;
 
 	return 0;
 
@@ -1394,21 +1273,19 @@
 
 	err = b44_alloc_consistent(bp);
 	if (err)
-		goto out;
+		return err;
+
+	err = request_irq(dev->irq, b44_interrupt, SA_SHIRQ, dev->name, dev);
+	if (err)
+		goto err_out_free;
+
+	spin_lock_irq(&bp->lock);
 
 	b44_init_rings(bp);
 	b44_init_hw(bp);
+	bp->flags |= B44_FLAG_INIT_COMPLETE;
 
-	netif_carrier_off(dev);
-	b44_check_phy(bp);
-
-	err = request_irq(dev->irq, b44_interrupt, SA_SHIRQ, dev->name, dev);
-	if (unlikely(err < 0)) {
-		b44_chip_reset(bp);
-		b44_free_rings(bp);
-		b44_free_consistent(bp);
-		goto out;
-	}
+	spin_unlock_irq(&bp->lock);
 
 	init_timer(&bp->timer);
 	bp->timer.expires = jiffies + HZ;
@@ -1417,8 +1294,11 @@
 	add_timer(&bp->timer);
 
 	b44_enable_ints(bp);
-	netif_start_queue(dev);
-out:
+
+	return 0;
+
+err_out_free:
+	b44_free_consistent(bp);
 	return err;
 }
 
@@ -1453,8 +1333,6 @@
 
 	netif_stop_queue(dev);
 
-	netif_poll_disable(dev);
-
 	del_timer_sync(&bp->timer);
 
 	spin_lock_irq(&bp->lock);
@@ -1464,14 +1342,13 @@
 #endif
 	b44_halt(bp);
 	b44_free_rings(bp);
+	bp->flags &= ~B44_FLAG_INIT_COMPLETE;
 	netif_carrier_off(bp->dev);
 
 	spin_unlock_irq(&bp->lock);
 
 	free_irq(dev->irq, dev);
 
-	netif_poll_enable(dev);
-
 	b44_free_consistent(bp);
 
 	return 0;
@@ -1536,6 +1413,8 @@
 {
 	struct b44 *bp = netdev_priv(dev);
 	u32 val;
+	int i=0;
+	unsigned char zero[6] = {0,0,0,0,0,0};
 
 	val = br32(bp, B44_RXCONFIG);
 	val &= ~(RXCONFIG_PROMISC | RXCONFIG_ALLMULTI);
@@ -1543,17 +1422,14 @@
 		val |= RXCONFIG_PROMISC;
 		bw32(bp, B44_RXCONFIG, val);
 	} else {
-		unsigned char zero[6] = {0, 0, 0, 0, 0, 0};
-		int i = 0;
-
 		__b44_set_mac_addr(bp);
 
 		if (dev->flags & IFF_ALLMULTI)
 			val |= RXCONFIG_ALLMULTI;
 		else
-			i = __b44_load_mcast(bp, dev);
+			i=__b44_load_mcast(bp, dev);
 		
-		for (; i < 64; i++) {
+		for(;i<64;i++) {
 			__b44_cam_write(bp, zero, i);			
 		}
 		bw32(bp, B44_RXCONFIG, val);
@@ -1617,7 +1493,7 @@
 {
 	struct b44 *bp = netdev_priv(dev);
 
-	if (!netif_running(dev))
+	if (!(bp->flags & B44_FLAG_INIT_COMPLETE))
 		return -EAGAIN;
 	cmd->supported = (SUPPORTED_Autoneg);
 	cmd->supported |= (SUPPORTED_100baseT_Half |
@@ -1628,14 +1504,14 @@
 
 	cmd->advertising = 0;
 	if (bp->flags & B44_FLAG_ADV_10HALF)
-		cmd->advertising |= ADVERTISED_10baseT_Half;
+		cmd->advertising |= ADVERTISE_10HALF;
 	if (bp->flags & B44_FLAG_ADV_10FULL)
-		cmd->advertising |= ADVERTISED_10baseT_Full;
+		cmd->advertising |= ADVERTISE_10FULL;
 	if (bp->flags & B44_FLAG_ADV_100HALF)
-		cmd->advertising |= ADVERTISED_100baseT_Half;
+		cmd->advertising |= ADVERTISE_100HALF;
 	if (bp->flags & B44_FLAG_ADV_100FULL)
-		cmd->advertising |= ADVERTISED_100baseT_Full;
-	cmd->advertising |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;
+		cmd->advertising |= ADVERTISE_100FULL;
+	cmd->advertising |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
 	cmd->speed = (bp->flags & B44_FLAG_100_BASE_T) ?
 		SPEED_100 : SPEED_10;
 	cmd->duplex = (bp->flags & B44_FLAG_FULL_DUPLEX) ?
@@ -1655,7 +1531,7 @@
 {
 	struct b44 *bp = netdev_priv(dev);
 
-	if (!netif_running(dev))
+	if (!(bp->flags & B44_FLAG_INIT_COMPLETE))
 		return -EAGAIN;
 
 	/* We do not support gigabit. */
@@ -1785,37 +1661,6 @@
 	return 0;
 }
 
-static void b44_get_strings(struct net_device *dev, u32 stringset, u8 *data)
-{
-	switch(stringset) {
-	case ETH_SS_STATS:
-		memcpy(data, *b44_gstrings, sizeof(b44_gstrings));
-		break;
-	}
-}
-
-static int b44_get_stats_count(struct net_device *dev)
-{
-	return ARRAY_SIZE(b44_gstrings);
-}
-
-static void b44_get_ethtool_stats(struct net_device *dev,
-				  struct ethtool_stats *stats, u64 *data)
-{
-	struct b44 *bp = netdev_priv(dev);
-	u32 *val = &bp->hw_stats.tx_good_octets;
-	u32 i;
-
-	spin_lock_irq(&bp->lock);
-
-	b44_stats_update(bp);
-
-	for (i = 0; i < ARRAY_SIZE(b44_gstrings); i++)
-		*data++ = *val++;
-
-	spin_unlock_irq(&bp->lock);
-}
-
 static struct ethtool_ops b44_ethtool_ops = {
 	.get_drvinfo		= b44_get_drvinfo,
 	.get_settings		= b44_get_settings,
@@ -1828,25 +1673,18 @@
 	.set_pauseparam		= b44_set_pauseparam,
 	.get_msglevel		= b44_get_msglevel,
 	.set_msglevel		= b44_set_msglevel,
-	.get_strings		= b44_get_strings,
-	.get_stats_count	= b44_get_stats_count,
-	.get_ethtool_stats	= b44_get_ethtool_stats,
-	.get_perm_addr		= ethtool_op_get_perm_addr,
 };
 
 static int b44_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	struct mii_ioctl_data *data = if_mii(ifr);
 	struct b44 *bp = netdev_priv(dev);
-	int err = -EINVAL;
-
-	if (!netif_running(dev))
-		goto out;
+	int err;
 
 	spin_lock_irq(&bp->lock);
 	err = generic_mii_ioctl(&bp->mii_if, data, cmd, NULL);
 	spin_unlock_irq(&bp->lock);
-out:
+
 	return err;
 }
 
@@ -1877,7 +1715,6 @@
 	bp->dev->dev_addr[3] = eeprom[80];
 	bp->dev->dev_addr[4] = eeprom[83];
 	bp->dev->dev_addr[5] = eeprom[82];
-	memcpy(bp->dev->perm_addr, bp->dev->dev_addr, bp->dev->addr_len);
 
 	bp->phy_addr = eeprom[90] & 0x1f;
 
@@ -1942,9 +1779,9 @@
 	
 	err = pci_set_consistent_dma_mask(pdev, (u64) B44_DMA_MASK);
 	if (err) {
-		printk(KERN_ERR PFX "No usable DMA configuration, "
-		       "aborting.\n");
-		goto err_out_free_res;
+	  printk(KERN_ERR PFX "No usable DMA configuration, "
+		 "aborting.\n");
+	  goto err_out_free_res;
 	}
 
 	b44reg_base = pci_resource_start(pdev, 0);
@@ -1966,8 +1803,10 @@
 	bp = netdev_priv(dev);
 	bp->pdev = pdev;
 	bp->dev = dev;
-
-	bp->msg_enable = netif_msg_init(b44_debug, B44_DEF_MSG_ENABLE);
+	if (b44_debug >= 0)
+		bp->msg_enable = (1 << b44_debug) - 1;
+	else
+		bp->msg_enable = B44_DEF_MSG_ENABLE;
 
 	spin_lock_init(&bp->lock);
 
@@ -2057,14 +1896,17 @@
 static void __devexit b44_remove_one(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
-	struct b44 *bp = netdev_priv(dev);
 
-	unregister_netdev(dev);
-	iounmap(bp->regs);
-	free_netdev(dev);
-	pci_release_regions(pdev);
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
+	if (dev) {
+		struct b44 *bp = netdev_priv(dev);
+
+		unregister_netdev(dev);
+		iounmap(bp->regs);
+		free_netdev(dev);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		pci_set_drvdata(pdev, NULL);
+	}
 }
 
 static int b44_suspend(struct pci_dev *pdev, pm_message_t state)
@@ -2085,9 +1927,6 @@
 	b44_free_rings(bp);
 
 	spin_unlock_irq(&bp->lock);
-
-	free_irq(dev->irq, dev);
-	pci_disable_device(pdev);
 	return 0;
 }
 
@@ -2097,15 +1936,10 @@
 	struct b44 *bp = netdev_priv(dev);
 
 	pci_restore_state(pdev);
-	pci_enable_device(pdev);
-	pci_set_master(pdev);
 
 	if (!netif_running(dev))
 		return 0;
 
-	if (request_irq(dev->irq, b44_interrupt, SA_SHIRQ, dev->name, dev))
-		printk(KERN_ERR PFX "%s: request_irq failed\n", dev->name);
-
 	spin_lock_irq(&bp->lock);
 
 	b44_init_rings(bp);
@@ -2117,7 +1951,6 @@
 	add_timer(&bp->timer);
 
 	b44_enable_ints(bp);
-	netif_wake_queue(dev);
 	return 0;
 }
 
@@ -2132,12 +1965,6 @@
 
 static int __init b44_init(void)
 {
-	unsigned int dma_desc_align_size = dma_get_cache_alignment();
-
-	/* Setup paramaters for syncing RX/TX DMA descriptors */
-	dma_desc_align_mask = ~(dma_desc_align_size - 1);
-	dma_desc_sync_size = max(dma_desc_align_size, sizeof(struct dma_desc));
-
 	return pci_module_init(&b44_driver);
 }
 
diff -ur linux-2.6.15-rc5/drivers/net/b44.h linux-2.6.15-rc5-openwrt/drivers/net/b44.h
--- linux-2.6.15-rc5/drivers/net/b44.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-openwrt/drivers/net/b44.h	2005-08-15 02:20:18.000000000 +0200
@@ -346,63 +346,29 @@
 
 #define B44_MCAST_TABLE_SIZE	32
 
-#define	B44_STAT_REG_DECLARE		\
-	_B44(tx_good_octets)		\
-	_B44(tx_good_pkts)		\
-	_B44(tx_octets)			\
-	_B44(tx_pkts)			\
-	_B44(tx_broadcast_pkts)		\
-	_B44(tx_multicast_pkts)		\
-	_B44(tx_len_64)			\
-	_B44(tx_len_65_to_127)		\
-	_B44(tx_len_128_to_255)		\
-	_B44(tx_len_256_to_511)		\
-	_B44(tx_len_512_to_1023)	\
-	_B44(tx_len_1024_to_max)	\
-	_B44(tx_jabber_pkts)		\
-	_B44(tx_oversize_pkts)		\
-	_B44(tx_fragment_pkts)		\
-	_B44(tx_underruns)		\
-	_B44(tx_total_cols)		\
-	_B44(tx_single_cols)		\
-	_B44(tx_multiple_cols)		\
-	_B44(tx_excessive_cols)		\
-	_B44(tx_late_cols)		\
-	_B44(tx_defered)		\
-	_B44(tx_carrier_lost)		\
-	_B44(tx_pause_pkts)		\
-	_B44(rx_good_octets)		\
-	_B44(rx_good_pkts)		\
-	_B44(rx_octets)			\
-	_B44(rx_pkts)			\
-	_B44(rx_broadcast_pkts)		\
-	_B44(rx_multicast_pkts)		\
-	_B44(rx_len_64)			\
-	_B44(rx_len_65_to_127)		\
-	_B44(rx_len_128_to_255)		\
-	_B44(rx_len_256_to_511)		\
-	_B44(rx_len_512_to_1023)	\
-	_B44(rx_len_1024_to_max)	\
-	_B44(rx_jabber_pkts)		\
-	_B44(rx_oversize_pkts)		\
-	_B44(rx_fragment_pkts)		\
-	_B44(rx_missed_pkts)		\
-	_B44(rx_crc_align_errs)		\
-	_B44(rx_undersize)		\
-	_B44(rx_crc_errs)		\
-	_B44(rx_align_errs)		\
-	_B44(rx_symbol_errs)		\
-	_B44(rx_pause_pkts)		\
-	_B44(rx_nonpause_pkts)
-
 /* SW copy of device statistics, kept up to date by periodic timer
- * which probes HW values. Check b44_stats_update if you mess with
- * the layout
+ * which probes HW values.  Must have same relative layout as HW
+ * register above, because b44_stats_update depends upon this.
  */
 struct b44_hw_stats {
-#define _B44(x)	u32 x;
-B44_STAT_REG_DECLARE
-#undef _B44
+	u32 tx_good_octets, tx_good_pkts, tx_octets;
+	u32 tx_pkts, tx_broadcast_pkts, tx_multicast_pkts;
+	u32 tx_len_64, tx_len_65_to_127, tx_len_128_to_255;
+	u32 tx_len_256_to_511, tx_len_512_to_1023, tx_len_1024_to_max;
+	u32 tx_jabber_pkts, tx_oversize_pkts, tx_fragment_pkts;
+	u32 tx_underruns, tx_total_cols, tx_single_cols;
+	u32 tx_multiple_cols, tx_excessive_cols, tx_late_cols;
+	u32 tx_defered, tx_carrier_lost, tx_pause_pkts;
+	u32 __pad1[8];
+
+	u32 rx_good_octets, rx_good_pkts, rx_octets;
+	u32 rx_pkts, rx_broadcast_pkts, rx_multicast_pkts;
+	u32 rx_len_64, rx_len_65_to_127, rx_len_128_to_255;
+	u32 rx_len_256_to_511, rx_len_512_to_1023, rx_len_1024_to_max;
+	u32 rx_jabber_pkts, rx_oversize_pkts, rx_fragment_pkts;
+	u32 rx_missed_pkts, rx_crc_align_errs, rx_undersize;
+	u32 rx_crc_errs, rx_align_errs, rx_symbol_errs;
+	u32 rx_pause_pkts, rx_nonpause_pkts;
 };
 
 struct b44 {
@@ -420,6 +386,7 @@
 
 	u32			dma_offset;
 	u32			flags;
+#define B44_FLAG_INIT_COMPLETE	0x00000001
 #define B44_FLAG_BUGGY_TXPTR	0x00000002
 #define B44_FLAG_REORDER_BUG	0x00000004
 #define B44_FLAG_PAUSE_AUTO	0x00008000
@@ -433,8 +400,6 @@
 #define B44_FLAG_ADV_100HALF	0x04000000
 #define B44_FLAG_ADV_100FULL	0x08000000
 #define B44_FLAG_INTERNAL_PHY	0x10000000
-#define B44_FLAG_RX_RING_HACK	0x20000000
-#define B44_FLAG_TX_RING_HACK	0x40000000
 
 	u32			rx_offset;
 
