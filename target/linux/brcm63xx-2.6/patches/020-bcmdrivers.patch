diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/Makefile linux-2.6.16.7-patched/bcmdrivers/opensource/Makefile
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/Makefile	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,20 @@
+# File: modules/drivers/Makefile
+#
+# Makefile for the GPLed Linux kernel modules.
+#
+
+LN_NAME=bcm9$(BRCM_CHIP)
+LN_DRIVER_DIRS =
+
+-include $(KERNEL_DIR)/.config
+
+ifneq ($(CONFIG_BCM_SERIAL),)
+  LN_DRIVER_DIRS +=ln -sn impl$(CONFIG_BCM_SERIAL_IMPL) char/serial/$(LN_NAME);
+endif
+
+obj-$(CONFIG_BCM_SERIAL) += char/serial/impl$(CONFIG_BCM_SERIAL_IMPL)/
+
+
+symlinks:
+	find . -lname "*" -name "$(LN_NAME)" -print -exec rm -f "{}" ";"	
+	$(CONFIG_SHELL) -c "$(LN_DRIVER_DIRS)"
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/char/serial/impl1/Makefile linux-2.6.16.7-patched/bcmdrivers/opensource/char/serial/impl1/Makefile
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/char/serial/impl1/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/char/serial/impl1/Makefile	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,13 @@
+# File: bcmdrivers/opensource/char/serial
+#
+# Makefile for the BCM63xx serial/console driver
+
+obj-$(CONFIG_BCM_SERIAL) += bcm63xx_cons.o
+
+EXTRA_CFLAGS += -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+
+-include $(TOPDIR)/Rules.make
+
+clean:
+	rm -f core *.o *.a *.s
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/char/serial/impl1/bcm63xx_cons.c linux-2.6.16.7-patched/bcmdrivers/opensource/char/serial/impl1/bcm63xx_cons.c
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/char/serial/impl1/bcm63xx_cons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/char/serial/impl1/bcm63xx_cons.c	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,1038 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+/* Description: Serial port driver for the BCM963XX. */
+
+#define CARDNAME    "bcm963xx_serial driver"
+#define VERSION     "2.0"
+#define VER_STR     CARDNAME " v" VERSION "\n"
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h> 
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+/* for definition of struct console */
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <asm/uaccess.h>
+
+#include <bcmtypes.h>
+#include <board.h>
+#include <bcm_map_part.h>
+#include <bcm_intr.h>
+
+extern void _putc(char);
+extern void _puts(const char *);
+
+typedef struct bcm_serial {
+    volatile Uart *         port;
+    int                     type;
+    int                     flags; 
+    int                     irq;
+    int                     baud_base;
+    int                     blocked_open;
+    unsigned short          close_delay;
+    unsigned short          closing_wait;
+    unsigned short          line;                /* port/line number */
+    unsigned short          cflags;              /* line configuration flag */
+    unsigned short          x_char;              /* xon/xoff character */
+    unsigned short          read_status_mask;    /* mask for read condition */
+    unsigned short          ignore_status_mask;  /* mask for ignore condition */
+    unsigned long           event;               /* mask used in BH */
+    int                     xmit_head;           /* Position of the head */
+    int                     xmit_tail;           /* Position of the tail */
+    int                     xmit_cnt;            /* Count of the chars in the buffer */
+    int                     count;               /* indicates how many times it has been opened */
+    int                     magic;
+
+    struct async_icount     icount;              /* keep track of things ... */
+    struct tty_struct       *tty;                /* tty associated */    
+    struct termios          normal_termios;
+
+    wait_queue_head_t       open_wait;
+    wait_queue_head_t       close_wait;
+
+    long                    session;             /* Session of opening process */
+    long                    pgrp;                /* pgrp of opening process */
+
+    unsigned char           is_initialized;
+} Context;
+
+
+/*---------------------------------------------------------------------*/
+/* Define bits in the Interrupt Enable register                        */
+/*---------------------------------------------------------------------*/
+/* Enable receive interrupt              */
+#define RXINT   (RXFIFONE|RXOVFERR)
+
+/* Enable transmit interrupt             */
+#define TXINT    (TXFIFOEMT|TXUNDERR|TXOVFERR) 
+
+/* Enable receiver line status interrupt */
+#define LSINT    (RXBRK|RXPARERR|RXFRAMERR)
+
+#define BCM_NUM_UARTS                   1
+
+#define BD_BCM63XX_TIMER_CLOCK_INPUT    (FPERIPH)
+
+
+static struct bcm_serial multi[BCM_NUM_UARTS];
+static struct bcm_serial *lines[BCM_NUM_UARTS];
+static struct tty_driver serial_driver;
+static struct tty_struct *serial_table[BCM_NUM_UARTS];
+static struct termios *serial_termios[BCM_NUM_UARTS];
+static struct termios *serial_termios_locked[BCM_NUM_UARTS];
+static int serial_refcount;
+
+
+static void bcm_stop (struct tty_struct *tty);
+static void bcm_start (struct tty_struct *tty);
+static inline void receive_chars (struct bcm_serial * info);
+static int startup (struct bcm_serial *info);
+static void shutdown (struct bcm_serial * info);
+static void change_speed( volatile Uart *pUart, tcflag_t cFlag );
+static void bcm63xx_cons_flush_chars (struct tty_struct *tty);
+static int bcm63xx_cons_write (struct tty_struct *tty, int from_user,
+    const unsigned char *buf, int count);
+static int bcm63xx_cons_write_room (struct tty_struct *tty);
+static int bcm_chars_in_buffer (struct tty_struct *tty);
+static void bcm_flush_buffer (struct tty_struct *tty);
+static void bcm_throttle (struct tty_struct *tty);
+static void bcm_unthrottle (struct tty_struct *tty);
+static void bcm_send_xchar (struct tty_struct *tty, char ch);
+static int get_serial_info(struct bcm_serial *info, struct serial_struct *retinfo);
+static int set_serial_info (struct bcm_serial *info, struct serial_struct *new_info);
+static int get_lsr_info (struct bcm_serial *info, unsigned int *value);
+static void send_break (struct bcm_serial *info, int duration);
+static int bcm_ioctl (struct tty_struct * tty, struct file * file,
+    unsigned int cmd, unsigned long arg);
+static void bcm_set_termios (struct tty_struct *tty, struct termios *old_termios);
+static void bcm63xx_cons_close (struct tty_struct *tty, struct file *filp);
+static void bcm_hangup (struct tty_struct *tty);
+static int block_til_ready (struct tty_struct *tty, struct file *filp, struct bcm_serial *info);
+static int bcm63xx_cons_open (struct tty_struct * tty, struct file * filp);
+static int __init bcm63xx_serialinit(void);
+
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop () and rs_start ()
+ *
+ * These routines are called before setting or resetting 
+ * tty->stopped. They enable or disable transmitter interrupts, 
+ * as necessary.
+ * ------------------------------------------------------------
+ */
+static void bcm_stop (struct tty_struct *tty)
+{
+}  
+
+static void bcm_start (struct tty_struct *tty)
+{
+    _puts(CARDNAME " Start\n");
+}  
+
+/*
+ * ------------------------------------------------------------
+ * receive_char ()
+ *
+ * This routine deals with inputs from any lines.
+ * ------------------------------------------------------------
+ */
+static inline void receive_chars (struct bcm_serial * info)
+{
+    struct tty_struct *tty = 0;
+    struct async_icount * icount;
+    int ignore = 0;
+    unsigned short status, tmp;
+    UCHAR ch = 0;
+    while ((status = info->port->intStatus) & RXINT)
+    {
+	char flag_char = 0;
+
+        if (status & RXFIFONE)
+            ch = info->port->Data;  // Read the character
+        tty = info->tty;                  /* now tty points to the proper dev */
+        icount = &info->icount;
+        if (! tty)
+            break;
+        if (!tty_buffer_request_room(tty, 1))
+            break;
+        icount->rx++;
+        if (status & RXBRK)
+        {
+            flag_char = TTY_BREAK;
+            icount->brk++;
+        }
+        // keep track of the statistics
+        if (status & (RXFRAMERR | RXPARERR | RXOVFERR))
+        {
+            if (status & RXPARERR)                /* parity error */
+                icount->parity++;
+            else
+                if (status & RXFRAMERR)           /* frame error */
+                    icount->frame++;
+            if (status & RXOVFERR)
+            {
+                // Overflow. Reset the RX FIFO
+                info->port->fifoctl |= RSTRXFIFOS;
+                icount->overrun++;
+            }
+            // check to see if we should ignore the character
+            // and mask off conditions that should be ignored
+            if (status & info->ignore_status_mask)
+            {
+                if (++ignore > 100 )
+                    break;
+                goto ignore_char;
+            }
+            // Mask off the error conditions we want to ignore
+            tmp = status & info->read_status_mask;
+            if (tmp & RXPARERR)
+            {
+                flag_char = TTY_PARITY;
+            }
+            else
+                if (tmp & RXFRAMERR)
+                {
+                    flag_char = TTY_FRAME;
+                }
+            if (tmp & RXOVFERR)
+            {
+	        tty_insert_flip_char(tty, ch, flag_char);
+		ch = 0;
+		flag_char = TTY_OVERRUN;
+		if (!tty_buffer_request_room(tty, 1))
+		  break;
+            }
+        }
+	tty_insert_flip_char(tty, ch, flag_char);
+    }
+ignore_char:
+    if (tty)
+        tty_flip_buffer_push(tty);
+}
+
+
+/*
+ * ------------------------------------------------------------
+ * bcm_interrupt ()
+ *
+ * this is the main interrupt routine for the chip.
+ * It deals with the multiple ports.
+ * ------------------------------------------------------------
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static irqreturn_t bcm_interrupt (int irq, void * dev, struct pt_regs * regs)
+#else
+static void bcm_interrupt (int irq, void * dev, struct pt_regs * regs)
+#endif
+{
+    struct bcm_serial * info = lines[0];
+    UINT16  intStat;
+
+    /* get pending interrupt flags from UART  */
+
+    /* Mask with only the serial interrupts that are enabled */
+    intStat = info->port->intStatus & info->port->intMask;
+    while (intStat)
+    {
+        if (intStat & RXINT)
+            receive_chars (info);          
+        else
+            if (intStat & TXINT)
+                info->port->intStatus = TXINT;
+            else /* don't know what it was, so let's mask it */
+                info->port->intMask &= ~intStat;
+
+        intStat = info->port->intStatus & info->port->intMask;
+    }
+
+    // Clear the interrupt
+    BcmHalInterruptEnable (INTERRUPT_ID_UART);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    return IRQ_HANDLED;
+#endif    
+}
+
+/*
+ * -------------------------------------------------------------------
+ * startup ()
+ *
+ * various initialization tasks
+ * ------------------------------------------------------------------- 
+ */
+static int startup (struct bcm_serial *info)
+{
+    // Port is already started...
+    return 0;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * shutdown ()
+ *
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ * ------------------------------------------------------------------- 
+ */
+static void shutdown (struct bcm_serial * info)
+{
+    unsigned long flags;
+    if (!info->is_initialized)
+        return;
+
+    save_flags (flags);
+    cli ();
+
+    info->port->control &= ~(BRGEN|TXEN|RXEN);
+    if (info->tty)
+        set_bit (TTY_IO_ERROR, &info->tty->flags);
+    info->is_initialized = 0;
+
+    restore_flags (flags);
+}
+/* 
+ * -------------------------------------------------------------------
+ * change_speed ()
+ *
+ * Set the baud rate, character size, parity and stop bits.
+ * ------------------------------------------------------------------- 
+ */
+static void change_speed( volatile Uart *pUart, tcflag_t cFlag )
+{
+    unsigned long ulFlags, ulBaud, ulClockFreqHz, ulTmp;
+    save_flags(ulFlags);
+    cli();
+    switch( cFlag & (CBAUD | CBAUDEX) )
+    {
+    case B115200:
+        ulBaud = 115200;
+        break;
+    case B57600:
+        ulBaud = 57600;
+        break;
+    case B38400:
+        ulBaud = 38400;
+        break;
+    case B19200:
+        ulBaud = 19200;
+        break;
+    case B9600:
+        ulBaud = 9600;
+        break;
+    case B4800:
+        ulBaud = 4800;
+        break;
+    case B2400:
+        ulBaud = 2400;
+        break;
+    case B1800:
+        ulBaud = 1800;
+        break;
+    case B1200:
+        ulBaud = 1200;
+        break;
+    case B600:
+        ulBaud = 600;
+        break;
+    case B300:
+        ulBaud = 300;
+        break;
+    case B200:
+        ulBaud = 200;
+        break;
+    case B150:
+        ulBaud = 150;
+        break;
+    case B134:
+        ulBaud = 134;
+        break;
+    case B110:
+        ulBaud = 110;
+        break;
+    case B75:
+        ulBaud = 75;
+        break;
+    case B50:
+        ulBaud = 50;
+        break;
+    default:
+        ulBaud = 115200;
+        break;
+    }
+
+    /* Calculate buad rate.  */
+    ulClockFreqHz = BD_BCM63XX_TIMER_CLOCK_INPUT;
+    ulTmp = (ulClockFreqHz / ulBaud) / 16;
+    if( ulTmp & 0x01 )
+        ulTmp /= 2; /* Rounding up, so sub is already accounted for */
+    else
+        ulTmp = (ulTmp / 2) - 1; /* Rounding down so we must sub 1 */
+    pUart->baudword = ulTmp;
+
+    /* Set character size, stop bits and parity.  */
+    switch( cFlag & CSIZE )
+    {
+    case CS5:
+        ulTmp = BITS5SYM; /* select transmit 5 bit data size */
+        break;
+    case CS6:
+        ulTmp = BITS6SYM; /* select transmit 6 bit data size */
+        break;
+    case CS7:
+        ulTmp = BITS7SYM; /* select transmit 7 bit data size */
+        break;
+    /*case CS8:*/
+    default:
+        ulTmp = BITS8SYM; /* select transmit 8 bit data size */
+        break;
+    }
+    if( cFlag & CSTOPB )
+        ulTmp |= TWOSTOP;         /* select 2 stop bits */
+    else
+        ulTmp |= ONESTOP;         /* select one stop bit */
+
+    /* Write these values into the config reg.  */
+    pUart->config = ulTmp;
+    pUart->control &= ~(RXPARITYEN | TXPARITYEN | RXPARITYEVEN | TXPARITYEVEN);
+    switch( cFlag & (PARENB | PARODD) )
+    {
+    case PARENB|PARODD:
+        pUart->control |= RXPARITYEN | TXPARITYEN;
+        break;
+    case PARENB:
+        pUart->control |= RXPARITYEN | TXPARITYEN | RXPARITYEVEN | TXPARITYEVEN;
+        break;
+    default:
+        pUart->control |= 0;
+        break;
+    }
+
+    /* Reset and flush uart */
+    pUart->fifoctl = RSTTXFIFOS | RSTRXFIFOS;
+    restore_flags( ulFlags );
+}
+
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_flush_char ()
+ *
+ * Nothing to flush.  Polled I/O is used.
+ * ------------------------------------------------------------------- 
+ */
+static void bcm63xx_cons_flush_chars (struct tty_struct *tty)
+{
+}
+
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm63xx_cons_write ()
+ *
+ * Main output routine using polled I/O.
+ * ------------------------------------------------------------------- 
+ */
+static int bcm63xx_cons_write (struct tty_struct *tty, int from_user,
+    const unsigned char *buf, int count)
+{
+    int c;
+
+    for (c = 0; c < count; c++)
+        _putc(buf[c]);
+    return count;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm63xx_cons_write_room ()
+ *
+ * Compute the amount of space available for writing.
+ * ------------------------------------------------------------------- 
+ */
+static int bcm63xx_cons_write_room (struct tty_struct *tty)
+{
+    /* Pick a number.  Any number.  Polled I/O is used. */
+    return 1024;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_chars_in_buffer ()
+ *
+ * compute the amount of char left to be transmitted
+ * ------------------------------------------------------------------- 
+ */
+static int bcm_chars_in_buffer (struct tty_struct *tty)
+{
+    return 0;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_flush_buffer ()
+ *
+ * Empty the output buffer
+ * ------------------------------------------------------------------- 
+ */
+static void bcm_flush_buffer (struct tty_struct *tty)
+{
+}
+
+/*
+ * ------------------------------------------------------------
+ * bcm_throttle () and bcm_unthrottle ()
+ * 
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled (or not).
+ * ------------------------------------------------------------
+ */
+static void bcm_throttle (struct tty_struct *tty)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;  
+    if (I_IXOFF(tty))
+        info->x_char = STOP_CHAR(tty);
+}
+
+static void bcm_unthrottle (struct tty_struct *tty)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;  
+    if (I_IXOFF(tty))
+    {
+        if (info->x_char)
+            info->x_char = 0;
+        else
+            info->x_char = START_CHAR(tty);
+    }
+}
+
+static void bcm_send_xchar (struct tty_struct *tty, char ch)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+    info->x_char = ch;
+    if (ch)
+        bcm_start (info->tty);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_ioctl () and friends
+ * ------------------------------------------------------------
+ */
+static int get_serial_info(struct bcm_serial *info, struct serial_struct *retinfo)
+{
+    struct serial_struct tmp;
+
+    if (!retinfo)
+        return -EFAULT;
+
+    memset (&tmp, 0, sizeof(tmp));
+    tmp.type            = info->type;
+    tmp.line            = info->line;
+    tmp.port            = (int) info->port;
+    tmp.irq             = info->irq;
+    tmp.flags           = 0;
+    tmp.baud_base       = info->baud_base;
+    tmp.close_delay     = info->close_delay;
+    tmp.closing_wait    = info->closing_wait;
+
+    return copy_to_user (retinfo, &tmp, sizeof(*retinfo));
+}
+
+static int set_serial_info (struct bcm_serial *info, struct serial_struct *new_info)
+{
+    struct serial_struct new_serial;
+    struct bcm_serial old_info;
+    int retval = 0;
+
+    if (!new_info)
+        return -EFAULT;
+
+    copy_from_user (&new_serial, new_info, sizeof(new_serial));
+    old_info = *info;
+
+    if (!capable(CAP_SYS_ADMIN))
+        return -EPERM;
+
+
+    if (info->count > 1)
+        return -EBUSY;
+
+    /* OK, past this point, all the error checking has been done.
+     * At this point, we start making changes.....
+     */
+    info->baud_base = new_serial.baud_base;
+    info->type = new_serial.type;
+    info->close_delay = new_serial.close_delay;
+    info->closing_wait = new_serial.closing_wait;
+    retval = startup (info);
+    return retval;
+}
+
+/*
+ * get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ *          is emptied.  On bus types like RS485, the transmitter must
+ *          release the bus after transmitting. This must be done when
+ *          the transmit shift register is empty, not be done when the
+ *          transmit holding register is empty.  This functionality
+ *          allows an RS485 driver to be written in user space. 
+ */
+static int get_lsr_info (struct bcm_serial *info, unsigned int *value)
+{
+    return( 0 );
+}
+
+/*
+ * This routine sends a break character out the serial port.
+ */
+static void send_break (struct bcm_serial *info, int duration)
+{
+    unsigned long flags;
+
+    if (!info->port)
+        return;
+
+    current->state = TASK_INTERRUPTIBLE;
+
+    save_flags (flags);
+    cli();
+
+    info->port->control |= XMITBREAK;
+    schedule_timeout(duration);
+    info->port->control &= ~XMITBREAK;
+
+    restore_flags (flags);
+}
+
+static int bcm_ioctl (struct tty_struct * tty, struct file * file,
+    unsigned int cmd, unsigned long arg)
+{
+    int error;
+    struct bcm_serial * info = (struct bcm_serial *)tty->driver_data;
+    int retval;
+
+    if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+        (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD)  &&
+        (cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT))
+    {
+        if (tty->flags & (1 << TTY_IO_ERROR))
+            return -EIO;
+    }
+    switch (cmd) 
+    {
+
+    case TCSBRK:    /* SVID version: non-zero arg --> no break */
+        retval = tty_check_change (tty);
+        if (retval)
+            return retval;
+        tty_wait_until_sent (tty, 0);
+        if (!arg)
+            send_break (info, HZ/4); /* 1/4 second */
+        return 0;
+
+    case TCSBRKP:   /* support for POSIX tcsendbreak() */
+        retval = tty_check_change (tty);
+        if (retval)
+            return retval;
+        tty_wait_until_sent (tty, 0);
+        send_break (info, arg ? arg*(HZ/10) : HZ/4);
+        return 0;
+
+    case TIOCGSOFTCAR:
+        error = access_ok (VERIFY_WRITE, (void *)arg, sizeof(long));
+        if (!error)
+            return -EFAULT;
+	else
+	{
+	    put_user (C_CLOCAL(tty) ? 1 : 0, (unsigned long *)arg);
+	    return 0;
+	}
+
+    case TIOCSSOFTCAR:
+        error = get_user (arg, (unsigned long *)arg);
+        if (error)
+            return error;
+        tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
+        return 0;
+
+    case TIOCGSERIAL:
+        error = access_ok (VERIFY_WRITE, (void *)arg, sizeof(struct serial_struct));
+        if (!error)
+            return -EFAULT;
+	else
+	    return get_serial_info (info, (struct serial_struct *)arg);
+
+    case TIOCSSERIAL:
+        return set_serial_info (info, (struct serial_struct *) arg);
+
+    case TIOCSERGETLSR: /* Get line status register */
+        error = access_ok (VERIFY_WRITE, (void *)arg, sizeof(unsigned int));
+        if (!error)
+            return -EFAULT;
+        else
+            return get_lsr_info (info, (unsigned int *)arg);
+
+    case TIOCSERGSTRUCT:
+        error = access_ok (VERIFY_WRITE, (void *)arg, sizeof(struct bcm_serial));
+        if (!error)
+            return -EFAULT;
+	else
+	{
+	    copy_to_user((struct bcm_serial *)arg, info, sizeof(struct bcm_serial));
+	    return 0;
+	}
+
+    default:
+        return -ENOIOCTLCMD;
+    }
+    return 0;
+}
+
+static void bcm_set_termios (struct tty_struct *tty, struct termios *old_termios)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+
+    if( tty->termios->c_cflag != old_termios->c_cflag )
+        change_speed (info->port, tty->termios->c_cflag);
+}
+
+/*
+ * ------------------------------------------------------------
+ * bcm63xx_cons_close()
+ * 
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we turn off
+ * the transmit enable and receive enable flags.
+ * ------------------------------------------------------------
+ */
+static void bcm63xx_cons_close (struct tty_struct *tty, struct file *filp)
+{
+    struct bcm_serial * info = (struct bcm_serial *)tty->driver_data;
+    unsigned long flags;
+
+    if (!info)
+        return;
+
+    save_flags (flags); 
+    cli();
+
+    if (tty_hung_up_p (filp))
+    {
+        restore_flags (flags);
+        return;
+    }
+
+    if ((tty->count == 1) && (info->count != 1))
+    {
+
+        /* Uh, oh.  tty->count is 1, which means that the tty
+         * structure will be freed.  Info->count should always
+         * be one in these conditions.  If it's greater than
+         * one, we've got real problems, since it means the
+         * serial port won't be shutdown.
+         */
+        printk("bcm63xx_cons_close: bad serial port count; tty->count is 1, "
+            "info->count is %d\n", info->count);
+        info->count = 1;
+    }
+
+    if (--info->count < 0)
+    {
+        printk("ds_close: bad serial port count for ttys%d: %d\n",
+        info->line, info->count);
+        info->count = 0;
+    }
+
+    if (info->count)
+    {
+        restore_flags (flags);
+        return;
+    }
+
+    /* Now we wait for the transmit buffer to clear; and we notify 
+     * the line discipline to only process XON/XOFF characters.
+     */
+    tty->closing = 1;
+
+    /* At this point we stop accepting input.  To do this, we
+     * disable the receive line status interrupts.
+     */
+    shutdown (info);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    if (tty->driver->flush_buffer)
+        tty->driver->flush_buffer (tty);
+#else    
+    if (tty->driver.flush_buffer)
+        tty->driver.flush_buffer (tty);
+#endif
+    if (tty->ldisc.flush_buffer)
+        tty->ldisc.flush_buffer (tty);
+
+    tty->closing = 0;
+    info->event = 0;
+    info->tty = 0;
+    if (tty->ldisc.num != tty_ldisc_get(N_TTY)->num)
+    {
+        if (tty->ldisc.close)
+            (tty->ldisc.close)(tty);
+        tty->ldisc = *tty_ldisc_get(N_TTY);
+        tty->termios->c_line = N_TTY;
+        if (tty->ldisc.open)
+            (tty->ldisc.open)(tty);
+    }
+    if (info->blocked_open)
+    {
+        if (info->close_delay)
+        {
+            current->state = TASK_INTERRUPTIBLE;
+            schedule_timeout(info->close_delay);
+        }
+        wake_up_interruptible (&info->open_wait);
+    }
+    wake_up_interruptible (&info->close_wait);
+
+    restore_flags (flags);
+}
+
+/*
+ * bcm_hangup () --- called by tty_hangup() when a hangup is signaled.
+ */
+static void bcm_hangup (struct tty_struct *tty)
+{
+
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+
+    shutdown (info);
+    info->event = 0;
+    info->count = 0;
+    info->tty = 0;
+    wake_up_interruptible (&info->open_wait);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_open() and friends
+ * ------------------------------------------------------------
+ */
+static int block_til_ready (struct tty_struct *tty, struct file *filp,
+    struct bcm_serial *info)
+{
+    return 0;
+}       
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port. It also performs the 
+ * serial-specific initialization for the tty structure.
+ */
+static int bcm63xx_cons_open (struct tty_struct * tty, struct file * filp)
+{
+    struct bcm_serial *info;
+    int retval, line;
+
+    // Make sure we're only opening on of the ports we support
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    line = MINOR(tty->driver->cdev.dev) - tty->driver->minor_start;
+#else
+    line = MINOR(tty->device) - tty->driver.minor_start;
+#endif    
+
+    if ((line < 0) || (line >= BCM_NUM_UARTS))
+        return -ENODEV;
+
+    info = lines[line];
+
+    info->port->intMask  = 0;     /* Clear any pending interrupts */
+    info->port->intMask  = RXINT; /* Enable RX */
+
+    info->count++;
+    tty->driver_data = info;
+    info->tty = tty;
+    BcmHalInterruptEnable (INTERRUPT_ID_UART);
+
+    // Start up serial port
+    retval = startup (info);
+    if (retval)
+        return retval;
+
+    retval = block_til_ready (tty, filp, info);
+    if (retval)
+        return retval;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    info->pgrp = process_group(current);
+    info->session = current->signal->session;
+#else
+    info->session = current->session;    
+    info->pgrp = current->pgrp;
+#endif    
+
+    return 0;
+}
+
+/* --------------------------------------------------------------------------
+    Name: bcm63xx_serialinit
+ Purpose: Initialize our BCM63xx serial driver
+-------------------------------------------------------------------------- */
+static int __init bcm63xx_serialinit(void)
+{
+    int i, flags;
+    struct bcm_serial * info;
+
+    // Print the driver version information
+    printk(VER_STR);
+
+    memset(&serial_driver, 0, sizeof(struct tty_driver));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)     
+    serial_driver.owner 	    = THIS_MODULE;
+    serial_driver.devfs_name 	    = "tts/";
+#endif    
+    serial_driver.magic             = TTY_DRIVER_MAGIC;
+    serial_driver.name              = "ttyS";
+    serial_driver.major             = TTY_MAJOR;
+    serial_driver.minor_start       = 64;
+    serial_driver.num               = BCM_NUM_UARTS;
+    serial_driver.type              = TTY_DRIVER_TYPE_SERIAL;
+    serial_driver.subtype           = SERIAL_TYPE_NORMAL;
+    serial_driver.init_termios      = tty_std_termios;
+    serial_driver.init_termios.c_cflag = B115200 | CS8 | CREAD | CLOCAL;
+    serial_driver.flags             = TTY_DRIVER_REAL_RAW;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)    
+    serial_driver.refcount          = serial_refcount;
+    serial_driver.ttys	            = serial_table;    
+#else
+    serial_driver.refcount          = &serial_refcount;
+    serial_driver.table             = serial_table;    
+#endif    
+
+    serial_driver.termios           = serial_termios;
+    serial_driver.termios_locked    = serial_termios_locked;
+    serial_driver.open              = bcm63xx_cons_open;
+    serial_driver.close             = bcm63xx_cons_close;
+    serial_driver.write             = bcm63xx_cons_write;
+    serial_driver.flush_chars       = bcm63xx_cons_flush_chars;
+    serial_driver.write_room        = bcm63xx_cons_write_room;
+    serial_driver.chars_in_buffer   = bcm_chars_in_buffer;
+    serial_driver.flush_buffer      = bcm_flush_buffer;
+    serial_driver.ioctl             = bcm_ioctl;
+    serial_driver.throttle          = bcm_throttle;
+    serial_driver.unthrottle        = bcm_unthrottle;
+    serial_driver.send_xchar        = bcm_send_xchar;
+    serial_driver.set_termios       = bcm_set_termios;
+    serial_driver.stop              = bcm_stop;
+    serial_driver.start             = bcm_start;
+    serial_driver.hangup            = bcm_hangup;
+
+    if (tty_register_driver (&serial_driver))
+        panic("Couldn't register serial driver\n");
+
+    save_flags(flags); cli();
+    for (i = 0; i < BCM_NUM_UARTS; i++)
+    {
+        info = &multi[i]; 
+        lines[i] = info;
+        info->port                  = (Uart *) ((char *)UART_BASE + (i * 0x20));
+        info->irq                   = (2 - i) + 8;
+        info->line                  = i;
+        info->tty                   = 0;
+        info->close_delay           = 50;
+        info->closing_wait          = 3000;
+        info->x_char                = 0;
+        info->event                 = 0;
+        info->count                 = 0;
+        info->blocked_open          = 0;	
+        info->normal_termios        = serial_driver.init_termios;
+        init_waitqueue_head(&info->open_wait); 
+        init_waitqueue_head(&info->close_wait); 
+
+        /* If we are pointing to address zero then punt - not correctly
+         * set up in setup.c to handle this. 
+         */
+        if (! info->port)
+            return 0;
+        BcmHalMapInterrupt(bcm_interrupt, 0, INTERRUPT_ID_UART);
+    }
+
+    /* order matters here... the trick is that flags
+     * is updated... in request_irq - to immediatedly obliterate
+     * it is unwise. 
+     */
+    restore_flags(flags);
+    return 0;
+}
+
+module_init(bcm63xx_serialinit);
+
+/* --------------------------------------------------------------------------
+    Name: bcm_console_print
+ Purpose: bcm_console_print is registered for printk.
+          The console_lock must be held when we get here.
+-------------------------------------------------------------------------- */
+static void bcm_console_print (struct console * cons, const char * str,
+    unsigned int count)
+{
+    unsigned int i;
+    //_puts(str);
+    for(i=0; i<count; i++, str++)
+    {
+        _putc(*str);
+        if (*str == 10)
+        {
+            _putc(13);
+        }
+    }
+}
+
+static struct tty_driver * bcm_console_device(struct console * c, int *index)
+{
+    *index = c->index;
+    return &serial_driver;
+}
+
+static int __init bcm_console_setup(struct console * co, char * options)
+{
+    return 0;
+}
+
+static struct console bcm_sercons = {
+    .name	= "ttyS",
+    .write	= bcm_console_print,
+    .device	= bcm_console_device,
+    .setup	= bcm_console_setup,
+    .flags	= CON_PRINTBUFFER, // CON_CONSDEV, CONSOLE_LINE,
+    .index	= -1,
+};
+
+static int __init bcm63xx_console_init(void)
+{
+    register_console(&bcm_sercons);
+    return 0;
+}
+
+console_initcall(bcm63xx_console_init);
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6338_intr.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6338_intr.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6338_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6338_intr.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6338_INTR_H
+#define __6338_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+/*=====================================================================*/
+/* BCM6338 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6338 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+#define INTERRUPT_ID_TIMER               (INTERNAL_ISR_TABLE_OFFSET + 0)
+#define INTERRUPT_ID_SPI                 (INTERNAL_ISR_TABLE_OFFSET + 1)
+#define INTERRUPT_ID_UART                (INTERNAL_ISR_TABLE_OFFSET + 2)
+#define INTERRUPT_ID_DG                  (INTERNAL_ISR_TABLE_OFFSET + 4)
+#define INTERRUPT_ID_ADSL                (INTERNAL_ISR_TABLE_OFFSET + 5)
+#define INTERRUPT_ID_ATM                 (INTERNAL_ISR_TABLE_OFFSET + 6)
+#define INTERRUPT_ID_USBS                (INTERNAL_ISR_TABLE_OFFSET + 7)
+#define INTERRUPT_ID_EMAC1               (INTERNAL_ISR_TABLE_OFFSET + 8)
+#define INTERRUPT_ID_EPHY                (INTERNAL_ISR_TABLE_OFFSET + 9)
+#define INTERRUPT_ID_SDRAM               (INTERNAL_ISR_TABLE_OFFSET + 10)
+#define INTERRUPT_ID_USB_CNTL_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 11)
+#define INTERRUPT_ID_USB_CNTL_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 12)
+#define INTERRUPT_ID_USB_BULK_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 13)
+#define INTERRUPT_ID_USB_BULK_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 14)
+#define INTERRUPT_ID_EMAC1_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 15)
+#define INTERRUPT_ID_EMAC1_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 16)
+#define INTERRUPT_ID_SDIO                (INTERNAL_ISR_TABLE_OFFSET + 17)
+
+#ifdef __cplusplus
+    }
+#endif                    
+
+#endif  /* __BCM6338_H */
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6338_map_part.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6338_map_part.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6338_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6338_map_part.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,341 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6338_MAP_H
+#define __BCM6338_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+
+#define PERF_BASE           0xfffe0000
+#define TIMR_BASE           0xfffe0200 
+#define UART_BASE           0xfffe0300
+#define GPIO_BASE           0xfffe0400
+#define SPI_BASE            0xfffe0c00
+
+typedef struct PerfControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define EMAC_CLK_EN     0x0010
+#define USBS_CLK_EN     0x0010
+#define SAR_CLK_EN      0x0020
+
+#define SPI_CLK_EN      0x0200
+
+  uint32        pll_control;
+#define SOFT_RESET 0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  5
+#define EI_CLEAR_SHFT   10
+#define EI_MASK_SHFT    15
+#define EI_INSENS_SHFT  20
+#define EI_LEVEL_SHFT   25
+
+  uint32        unused[4];      /* (18) */
+  uint32        BlockSoftReset; /* (28) */
+#define BSR_SPI             0x00000001
+#define BSR_EMAC            0x00000004
+#define BSR_USBH            0x00000008
+#define BSR_USBS            0x00000010
+#define BSR_ADSL            0x00000020
+#define BSR_DMAMEM          0x00000040
+#define BSR_SAR             0x00000080
+#define BSR_ACLC            0x00000100
+#define BSR_ADSL_MIPS_PLL   0x00000400
+#define BSR_ALL_BLOCKS      \
+    (BSR_SPI | BSR_EMAC | BSR_USBH | BSR_USBS | BSR_ADSL | BSR_DMAMEM | \
+     BSR_SAR | BSR_ACLC | BSR_ADSL_MIPS_PLL) 
+} PerfControl;
+
+#define PERF ((volatile PerfControl * const) PERF_BASE)
+
+
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint32        unused0;
+  uint32        GPIODir;      /* bits 7:0 */
+  uint32        unused1;
+  uint32        GPIOio;       /* bits 7:0 */
+  uint32        LEDCtrl;
+#define         LED3_STROBE             0x08000000
+#define         LED2_STROBE             0x04000000
+#define         LED1_STROBE             0x02000000
+#define         LED0_STROBE             0x01000000
+#define         LED_TEST                0x00010000
+#define         LED3_DISABLE_LINK_ACT   0x00008000
+#define         LED2_DISABLE_LINK_ACT   0x00004000
+#define         LED1_DISABLE_LINK_ACT   0x00002000
+#define         LED0_DISABLE_LINK_ACT   0x00001000
+#define         LED_INTERVAL_SET_MASK   0x00000f00
+#define         LED_INTERVAL_SET_320MS  0x00000500
+#define         LED_INTERVAL_SET_160MS  0x00000400
+#define         LED_INTERVAL_SET_80MS   0x00000300
+#define         LED_INTERVAL_SET_40MS   0x00000200
+#define         LED_INTERVAL_SET_20MS   0x00000100
+#define         LED3_ON                 0x00000080
+#define         LED2_ON                 0x00000040
+#define         LED1_ON                 0x00000020
+#define         LED0_ON                 0x00000010
+#define         LED3_ENABLE             0x00000008
+#define         LED2_ENABLE             0x00000004
+#define         LED1_ENABLE             0x00000002
+#define         LED0_ENABLE             0x00000001
+  uint32        SpiSlaveCfg;
+#define         SPI_SLAVE_RESET         0x00010000
+#define         SPI_RESTRICT            0x00000400
+#define         SPI_DELAY_DISABLE       0x00000200
+#define         SPI_PROBE_MUX_SEL_MASK  0x000001e0
+#define         SPI_SER_ADDR_CFG_MASK   0x0000000c
+#define         SPI_MODE                0x00000001
+  uint32        vRegConfig;
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+/* Number to mask conversion macro used for GPIODir and GPIOio */
+#define GPIO_NUM_MAX_BITS_MASK          0x0f
+#define GPIO_NUM_TO_MASK(X)             (1 << ((X) & GPIO_NUM_MAX_BITS_MASK))
+
+/*
+** Spi Controller
+*/
+
+typedef struct SpiControl {
+  uint16        spiCmd;                 /* (0x0): SPI command */
+#define SPI_CMD_START_IMMEDIATE         3
+
+#define SPI_CMD_COMMAND_SHIFT           0
+#define SPI_CMD_DEVICE_ID_SHIFT         4
+#define SPI_CMD_PREPEND_BYTE_CNT_SHIFT  8
+
+  byte          spiIntStatus;           /* (0x2): SPI interrupt status */
+  byte          spiMaskIntStatus;       /* (0x3): SPI masked interrupt status */
+
+  byte          spiIntMask;             /* (0x4): SPI interrupt mask */
+#define SPI_INTR_CMD_DONE               0x01
+#define SPI_INTR_CLEAR_ALL              0x1f
+
+  byte          spiStatus;              /* (0x5): SPI status */
+
+  byte          spiClkCfg;              /* (0x6): SPI clock configuration */
+
+  byte          spiFillByte;            /* (0x7): SPI fill byte */
+
+  byte          unused0; 
+  byte          spiMsgTail;             /* (0x9): msgtail */
+  byte          unused1; 
+  byte          spiRxTail;              /* (0xB): rxtail */
+
+  uint32        unused2[13];            /* (0x0c - 0x3c) reserved */
+
+  byte          spiMsgCtl;              /* (0x40) control byte */
+#define HALF_DUPLEX_W                   1
+#define HALF_DUPLEX_R                   2
+#define SPI_MSG_TYPE_SHIFT              6
+#define SPI_BYTE_CNT_SHIFT              0
+  byte          spiMsgData[63];         /* (0x41 - 0x7f) msg data */
+  byte          spiRxDataFifo[64];      /* (0x80 - 0xbf) rx data */
+  byte          unused3[64];            /* (0xc0 - 0xff) reserved */
+} SpiControl;
+
+#define SPI ((volatile SpiControl * const) SPI_BASE)
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_TS_TA_MODE      0x00000080      /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100      /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct MpiRegisters {
+  EbiChipSelect cs[1];                  /* size chip select configuration */
+} MpiRegisters;
+
+#define MPI ((volatile MpiRegisters * const) MPI_BASE)
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6345_intr.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6345_intr.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6345_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6345_intr.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6345_INTR_H
+#define __6345_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+/*=====================================================================*/
+/* BCM6345 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6345 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+#define DMA_ISR_TABLE_OFFSET            (INTERNAL_ISR_TABLE_OFFSET + 13)
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+/* Internal peripheral interrupt IDs */
+#define INTERRUPT_ID_TIMER              (INTERNAL_ISR_TABLE_OFFSET +  0)
+#define INTERRUPT_ID_UART               (INTERNAL_ISR_TABLE_OFFSET +  2)
+#define INTERRUPT_ID_ADSL               (INTERNAL_ISR_TABLE_OFFSET +  3)
+#define INTERRUPT_ID_ATM                (INTERNAL_ISR_TABLE_OFFSET +  4)
+#define INTERRUPT_ID_USB                (INTERNAL_ISR_TABLE_OFFSET +  5)
+#define INTERRUPT_ID_EMAC               (INTERNAL_ISR_TABLE_OFFSET +  8)
+#define INTERRUPT_ID_EPHY               (INTERNAL_ISR_TABLE_OFFSET +  12)
+
+/* DMA channel interrupt IDs */        
+#define INTERRUPT_ID_EMAC_RX_CHAN       (DMA_ISR_TABLE_OFFSET + EMAC_RX_CHAN)
+#define INTERRUPT_ID_EMAC_TX_CHAN       (DMA_ISR_TABLE_OFFSET + EMAC_TX_CHAN)
+#define INTERRUPT_ID_EBI_RX_CHAN        (DMA_ISR_TABLE_OFFSET + EBI_RX_CHAN)
+#define INTERRUPT_ID_EBI_TX_CHAN        (DMA_ISR_TABLE_OFFSET + EBI_TX_CHAN)
+#define INTERRUPT_ID_RESERVED_RX_CHAN   (DMA_ISR_TABLE_OFFSET + RESERVED_RX_CHAN)
+#define INTERRUPT_ID_RESERVED_TX_CHAN   (DMA_ISR_TABLE_OFFSET + RESERVED_TX_CHAN)
+#define INTERRUPT_ID_USB_BULK_RX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_BULK_RX_CHAN)
+#define INTERRUPT_ID_USB_BULK_TX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_BULK_TX_CHAN)
+#define INTERRUPT_ID_USB_CNTL_RX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_CNTL_RX_CHAN)
+#define INTERRUPT_ID_USB_CNTL_TX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_CNTL_TX_CHAN)
+#define INTERRUPT_ID_USB_ISO_RX_CHAN    (DMA_ISR_TABLE_OFFSET + USB_ISO_RX_CHAN)
+#define INTERRUPT_ID_USB_ISO_TX_CHAN    (DMA_ISR_TABLE_OFFSET + USB_ISO_TX_CHAN)
+
+#ifdef __cplusplus
+    }
+#endif                    
+
+#endif  /* __BCM6345_H */
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6345_map_part.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6345_map_part.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6345_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6345_map_part.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,169 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6345_MAP_H
+#define __BCM6345_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+#include "6345_intr.h"
+
+typedef struct IntControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define USB_CLK_EN      0x0100
+#define EMAC_CLK_EN     0x0080
+#define UART_CLK_EN     0x0008
+#define CPU_CLK_EN      0x0001
+
+  uint32        pll_control;
+#define SOFT_RESET	0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  4
+#define EI_CLEAR_SHFT   8
+#define EI_MASK_SHFT    12
+#define EI_INSENS_SHFT  16
+#define EI_LEVEL_SHFT   20
+} IntControl;
+
+#define INTC_BASE     0xfffe0000
+#define PERF ((volatile IntControl * const) INTC_BASE)
+
+#define TIMR_BASE     0xfffe0200    
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+  byte          config;
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define XMITBREAK       0x40
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  uint32        baudword;
+
+  byte          txf_levl;
+  byte          rxf_levl;
+  byte          fifocfg;
+  byte          prog_out;
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;
+  byte          DeltaIPConfig_Mask;
+  byte          DeltaIP_SyncIP;
+  uint16        intMask;
+  uint16        intStatus;
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOEMT       0x0020
+#define RXOVFERR        0x0080
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART_BASE     0xfffe0300
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint16        unused0;
+  byte          unused1;
+  byte          TBusSel;
+
+  uint16        unused2;
+  uint16        GPIODir;
+  byte          unused3;
+  byte          Leds;
+  uint16        GPIOio;
+
+  uint32        UartCtl;
+} GpioControl;
+
+#define GPIO_BASE     0xfffe0400
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+#define GPIO_NUM_MAX_BITS_MASK          0x0f
+#define GPIO_NUM_TO_MASK(X)             (1 << ((X) & GPIO_NUM_MAX_BITS_MASK))
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6348_intr.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6348_intr.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6348_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6348_intr.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,80 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6348_INTR_H
+#define __6348_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+/*=====================================================================*/
+/* BCM6348 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6348 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+#define INTERRUPT_ID_TIMER               (INTERNAL_ISR_TABLE_OFFSET + 0)
+#define INTERRUPT_ID_SPI                 (INTERNAL_ISR_TABLE_OFFSET + 1)
+#define INTERRUPT_ID_UART                (INTERNAL_ISR_TABLE_OFFSET + 2)
+#define INTERRUPT_ID_ADSL                (INTERNAL_ISR_TABLE_OFFSET + 4)
+#define INTERRUPT_ID_ATM                 (INTERNAL_ISR_TABLE_OFFSET + 5)
+#define INTERRUPT_ID_USBS                (INTERNAL_ISR_TABLE_OFFSET + 6)
+#define INTERRUPT_ID_EMAC2               (INTERNAL_ISR_TABLE_OFFSET + 7)
+#define INTERRUPT_ID_EMAC1               (INTERNAL_ISR_TABLE_OFFSET + 8)
+#define INTERRUPT_ID_EPHY                (INTERNAL_ISR_TABLE_OFFSET + 9)
+#define INTERRUPT_ID_M2M                 (INTERNAL_ISR_TABLE_OFFSET + 10)
+#define INTERRUPT_ID_ACLC                (INTERNAL_ISR_TABLE_OFFSET + 11)
+#define INTERRUPT_ID_USBH                (INTERNAL_ISR_TABLE_OFFSET + 12)
+#define INTERRUPT_ID_SDRAM               (INTERNAL_ISR_TABLE_OFFSET + 13)
+#define INTERRUPT_ID_USB_CNTL_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 14)
+#define INTERRUPT_ID_USB_CNTL_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 15)
+#define INTERRUPT_ID_USB_BULK_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 16)
+#define INTERRUPT_ID_USB_BULK_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 17)
+#define INTERRUPT_ID_USB_ISO_RX_DMA      (INTERNAL_ISR_TABLE_OFFSET + 18)
+#define INTERRUPT_ID_USB_ISO_TX_DMA      (INTERNAL_ISR_TABLE_OFFSET + 19)
+#define INTERRUPT_ID_EMAC1_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 20)
+#define INTERRUPT_ID_EMAC1_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 21)
+#define INTERRUPT_ID_EMAC2_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 22)
+#define INTERRUPT_ID_EMAC2_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 23)
+#define INTERRUPT_ID_MPI                 (INTERNAL_ISR_TABLE_OFFSET + 24)
+#define INTERRUPT_ID_DG                  (INTERNAL_ISR_TABLE_OFFSET + 25)
+
+#ifdef __cplusplus
+    }
+#endif                    
+
+#endif  /* __BCM6348_H */
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6348_map_part.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6348_map_part.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/6348_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/6348_map_part.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,508 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6348_MAP_H
+#define __BCM6348_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+
+#define PERF_BASE           0xfffe0000
+#define TIMR_BASE           0xfffe0200    
+#define UART_BASE           0xfffe0300
+#define GPIO_BASE           0xfffe0400
+#define MPI_BASE            0xfffe2000    /* MPI control registers */
+#define USB_HOST_BASE       0xfffe1b00    /* USB host registers */
+#define USB_HOST_NON_OHCI   0xfffe1c00    /* USB host non-OHCI registers */
+
+typedef struct PerfControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define EMAC_CLK_EN     0x0010
+#define SAR_CLK_EN      0x0020
+#define USBS_CLK_EN     0x0040
+#define USBH_CLK_EN     0x0100
+
+  uint32        pll_control;
+#define SOFT_RESET 0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  5
+#define EI_CLEAR_SHFT   10
+#define EI_MASK_SHFT    15
+#define EI_INSENS_SHFT  20
+#define EI_LEVEL_SHFT   25
+
+  uint32        unused[4];      /* (18) */
+  uint32        BlockSoftReset; /* (28) */
+#define BSR_SPI             0x00000001
+#define BSR_EMAC            0x00000004
+#define BSR_USBH            0x00000008
+#define BSR_USBS            0x00000010
+#define BSR_ADSL            0x00000020
+#define BSR_DMAMEM          0x00000040
+#define BSR_SAR             0x00000080
+#define BSR_ACLC            0x00000100
+#define BSR_ADSL_MIPS_PLL   0x00000400
+#define BSR_ALL_BLOCKS      \
+    (BSR_SPI | BSR_EMAC | BSR_USBH | BSR_USBS | BSR_ADSL | BSR_DMAMEM | \
+     BSR_SAR | BSR_ACLC | BSR_ADSL_MIPS_PLL) 
+  uint32        unused2[2];     /* (2c) */
+  uint32        PllStrap;       /* (34) */
+#define PLL_N1_SHFT         20
+#define PLL_N1_MASK         (7<<PLL_N1_SHFT)
+#define PLL_N2_SHFT         15
+#define PLL_N2_MASK         (0x1f<<PLL_N2_SHFT)
+#define PLL_M1_REF_SHFT     12
+#define PLL_M1_REF_MASK     (7<<PLL_M1_REF_SHFT)
+#define PLL_M2_REF_SHFT     9
+#define PLL_M2_REF_MASK     (7<<PLL_M2_REF_SHFT)
+#define PLL_M1_CPU_SHFT     6
+#define PLL_M1_CPU_MASK     (7<<PLL_M1_CPU_SHFT)
+#define PLL_M1_BUS_SHFT     3
+#define PLL_M1_BUS_MASK     (7<<PLL_M1_BUS_SHFT)
+#define PLL_M2_BUS_SHFT     0
+#define PLL_M2_BUS_MASK     (7<<PLL_M2_BUS_SHFT)
+} PerfControl;
+
+#define PERF ((volatile PerfControl * const) PERF_BASE)
+
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint32        GPIODir_high; /* bits 36:32 */
+  uint32        GPIODir;      /* bits 31:00 */
+  uint32        GPIOio_high;  /* bits 36:32 */
+  uint32        GPIOio;       /* bits 31:00 */
+  uint32        LEDCtrl;
+#define         LED3_STROBE             0x08000000
+#define         LED2_STROBE             0x04000000
+#define         LED1_STROBE             0x02000000
+#define         LED0_STROBE             0x01000000
+#define         LED_TEST                0x00010000
+#define         LED3_DISABLE_LINK_ACT   0x00008000
+#define         LED2_DISABLE_LINK_ACT   0x00004000
+#define         LED1_DISABLE_LINK_ACT   0x00002000
+#define         LED0_DISABLE_LINK_ACT   0x00001000
+#define         LED_INTERVAL_SET_MASK   0x00000f00
+#define         LED_INTERVAL_SET_320MS  0x00000500
+#define         LED_INTERVAL_SET_160MS  0x00000400
+#define         LED_INTERVAL_SET_80MS   0x00000300
+#define         LED_INTERVAL_SET_40MS   0x00000200
+#define         LED_INTERVAL_SET_20MS   0x00000100
+#define         LED3_ON                 0x00000080
+#define         LED2_ON                 0x00000040
+#define         LED1_ON                 0x00000020
+#define         LED0_ON                 0x00000010
+#define         LED3_ENABLE             0x00000008
+#define         LED2_ENABLE             0x00000004
+#define         LED1_ENABLE             0x00000002
+#define         LED0_ENABLE             0x00000001
+  uint32        SpiSlaveCfg;
+#define         SPI_SLAVE_RESET         0x00010000
+#define         SPI_RESTRICT            0x00000400
+#define         SPI_DELAY_DISABLE       0x00000200
+#define         SPI_PROBE_MUX_SEL_MASK  0x000001e0
+#define         SPI_SER_ADDR_CFG_MASK   0x0000000c
+#define         SPI_MODE                0x00000001
+  uint32        GPIOMode;
+#define         GROUP4_DIAG             0x00090000
+#define         GROUP4_UTOPIA           0x00080000
+#define         GROUP4_LEGACY_LED       0x00030000
+#define         GROUP4_MII_SNOOP        0x00020000
+#define         GROUP4_EXT_EPHY         0x00010000
+#define         GROUP3_DIAG             0x00009000
+#define         GROUP3_UTOPIA           0x00008000
+#define         GROUP3_EXT_MII          0x00007000
+#define         GROUP2_DIAG             0x00000900
+#define         GROUP2_PCI              0x00000500
+#define         GROUP1_DIAG             0x00000090
+#define         GROUP1_UTOPIA           0x00000080
+#define         GROUP1_SPI_UART         0x00000060
+#define         GROUP1_SPI_MASTER       0x00000060
+#define         GROUP1_MII_PCCARD       0x00000040
+#define         GROUP1_MII_SNOOP        0x00000020
+#define         GROUP1_EXT_EPHY         0x00000010
+#define         GROUP0_DIAG             0x00000009
+#define         GROUP0_EXT_MII          0x00000007
+
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+/* Number to mask conversion macro used for GPIODir and GPIOio */
+#define GPIO_NUM_TOTAL_BITS_MASK        0x3f
+#define GPIO_NUM_MAX_BITS_MASK          0x1f
+#define GPIO_NUM_TO_MASK(X)             ( (((X) & GPIO_NUM_TOTAL_BITS_MASK) < 32) ? (1 << ((X) & GPIO_NUM_MAX_BITS_MASK)) : (0) )
+
+/* Number to mask conversion macro used for GPIODir_high and GPIOio_high */
+#define GPIO_NUM_MAX_BITS_MASK_HIGH     0x07
+#define GPIO_NUM_TO_MASK_HIGH(X)        ( (((X) & GPIO_NUM_TOTAL_BITS_MASK) >= 32) ? (1 << ((X-32) & GPIO_NUM_MAX_BITS_MASK_HIGH)) : (0) )
+
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_TS_TA_MODE      0x00000080      /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100      /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct MpiRegisters {
+  EbiChipSelect cs[7];                  /* size chip select configuration */
+#define EBI_CS0_BASE            0
+#define EBI_CS1_BASE            1
+#define EBI_CS2_BASE            2
+#define EBI_CS3_BASE            3
+#define PCMCIA_COMMON_BASE      4
+#define PCMCIA_ATTRIBUTE_BASE   5
+#define PCMCIA_IO_BASE          6
+  uint32        unused0[2];             /* reserved */
+  uint32        ebi_control;            /* ebi control */
+  uint32        unused1[4];             /* reserved */
+#define EBI_ACCESS_TIMEOUT      0x000007FF
+  uint32        pcmcia_cntl1;           /* pcmcia control 1 */
+#define PCCARD_CARD_RESET       0x00040000
+#define CARDBUS_ENABLE          0x00008000
+#define PCMCIA_ENABLE           0x00004000
+#define PCMCIA_GPIO_ENABLE      0x00002000
+#define CARDBUS_IDSEL           0x00001F00
+#define VS2_OEN                 0x00000080
+#define VS1_OEN                 0x00000040
+#define VS2_OUT                 0x00000020
+#define VS1_OUT                 0x00000010
+#define VS2_IN                  0x00000008
+#define VS1_IN                  0x00000004
+#define CD2_IN                  0x00000002
+#define CD1_IN                  0x00000001
+#define VS_MASK                 0x0000000C
+#define CD_MASK                 0x00000003
+  uint32        unused2;                /* reserved */
+  uint32        pcmcia_cntl2;           /* pcmcia control 2 */
+#define PCMCIA_BYTESWAP_DIS     0x00000002
+#define PCMCIA_HALFWORD_EN      0x00000001
+#define RW_ACTIVE_CNT_BIT       2
+#define INACTIVE_CNT_BIT        8
+#define CE_SETUP_CNT_BIT        16
+#define CE_HOLD_CNT_BIT         24
+  uint32        unused3[40];            /* reserved */
+
+  uint32        sp0range;               /* PCI to internal system bus address space */
+  uint32        sp0remap;
+  uint32        sp0cfg;
+  uint32        sp1range;
+  uint32        sp1remap;
+  uint32        sp1cfg;
+
+  uint32        EndianCfg;
+
+  uint32        l2pcfgctl;              /* internal system bus to PCI IO/Cfg control */
+#define DIR_CFG_SEL             0x80000000 /* change from PCI I/O access to PCI config access */
+#define DIR_CFG_USEREG          0x40000000 /* use this register info for PCI configuration access */
+#define DEVICE_NUMBER           0x00007C00 /* device number for the PCI configuration access */
+#define FUNC_NUMBER             0x00000300 /* function number for the PCI configuration access */
+#define REG_NUMBER              0x000000FC /* register number for the PCI configuration access */
+#define CONFIG_TYPE             0x00000003 /* configuration type for the PCI configuration access */
+
+  uint32        l2pmrange1;             /* internal system bus to PCI memory space */
+#define PCI_SIZE_64K            0xFFFF0000
+#define PCI_SIZE_128K           0xFFFE0000
+#define PCI_SIZE_256K           0xFFFC0000
+#define PCI_SIZE_512K           0xFFF80000
+#define PCI_SIZE_1M             0xFFF00000
+#define PCI_SIZE_2M             0xFFE00000
+#define PCI_SIZE_4M             0xFFC00000
+#define PCI_SIZE_8M             0xFF800000
+#define PCI_SIZE_16M            0xFF000000
+#define PCI_SIZE_32M            0xFE000000
+  uint32        l2pmbase1;              /* kseg0 or kseg1 address & 0x1FFFFFFF */
+  uint32        l2pmremap1;
+#define CARDBUS_MEM             0x00000004
+#define MEM_WINDOW_EN           0x00000001
+  uint32        l2pmrange2;
+  uint32        l2pmbase2;
+  uint32        l2pmremap2;
+  uint32        l2piorange;             /* internal system bus to PCI I/O space */
+  uint32        l2piobase;
+  uint32        l2pioremap;
+
+  uint32        pcimodesel;
+#define PCI2_INT_BUS_RD_PREFECH 0x000000F0
+#define PCI_BAR2_NOSWAP         0x00000002 /* BAR at offset 0x20 */
+#define PCI_BAR1_NOSWAP         0x00000001 /* BAR at affset 0x1c */
+
+  uint32        pciintstat;             /* PCI interrupt mask/status */
+#define MAILBOX1_SENT           0x08
+#define MAILBOX0_SENT           0x04
+#define MAILBOX1_MSG_RCV        0x02
+#define MAILBOX0_MSG_RCV        0x01
+  uint32        locbuscntrl;            /* internal system bus control */
+#define DIR_U2P_NOSWAP          0x00000002
+#define EN_PCI_GPIO             0x00000001
+  uint32        locintstat;             /* internal system bus interrupt mask/status */
+#define CSERR                   0x0200
+#define SERR                    0x0100
+#define EXT_PCI_INT             0x0080
+#define DIR_FAILED              0x0040
+#define DIR_COMPLETE            0x0020
+#define PCI_CFG                 0x0010
+  uint32        unused5[7];
+
+  uint32        mailbox0;
+  uint32        mailbox1;
+
+  uint32        pcicfgcntrl;            /* internal system bus PCI configuration control */
+#define PCI_CFG_REG_WRITE_EN    0x00000080
+#define PCI_CFG_ADDR            0x0000003C
+  uint32        pcicfgdata;             /* internal system bus PCI configuration data */
+
+  uint32        locch2ctl;              /* PCI to interrnal system bus DMA (downstream) local control */
+#define MPI_DMA_HALT            0x00000008  /* idle after finish current memory burst */
+#define MPI_DMA_PKT_HALT        0x00000004  /* idle after an EOP flag is detected */
+#define MPI_DMA_STALL           0x00000002  /* idle after an EOP flag is detected */
+#define MPI_DMA_ENABLE          0x00000001  /* set to enable channel */
+  uint32        locch2intStat;
+#define MPI_DMA_NO_DESC         0x00000004  /* no valid descriptors */
+#define MPI_DMA_DONE            0x00000002  /* packet xfer complete */
+#define MPI_DMA_BUFF_DONE       0x00000001  /* buffer done */
+  uint32        locch2intMask;
+  uint32        unused6;
+  uint32        locch2descaddr;
+  uint32        locch2status1;
+#define LOCAL_DESC_STATE        0xE0000000
+#define PCI_DESC_STATE          0x1C000000
+#define BYTE_DONE               0x03FFC000
+#define RING_ADDR               0x00003FFF
+  uint32        locch2status2;
+#define BUFPTR_OFFSET           0x1FFF0000
+#define PCI_MASTER_STATE        0x000000C0
+#define LOC_MASTER_STATE        0x00000038
+#define CONTROL_STATE           0x00000007
+  uint32        unused7;
+
+  uint32        locch1Ctl;              /*internal system bus to PCI DMA (upstream) local control */
+#define DMA_U2P_LE              0x00000200  /* local bus is little endian */
+#define DMA_U2P_NOSWAP          0x00000100  /* lccal bus is little endian but no data swapped */
+  uint32        locch1intstat;
+  uint32        locch1intmask;
+  uint32        unused8;
+  uint32        locch1descaddr;
+  uint32        locch1status1;
+  uint32        locch1status2;
+  uint32        unused9;
+
+  uint32        pcich1ctl;              /* internal system bus to PCI DMA PCI control */
+  uint32        pcich1intstat;
+  uint32        pcich1intmask;
+  uint32        pcich1descaddr;
+  uint32        pcich1status1;
+  uint32        pcich1status2;
+
+  uint32        pcich2Ctl;              /* PCI to internal system bus DMA PCI control */
+  uint32        pcich2intstat;
+  uint32        pcich2intmask;
+  uint32        pcich2descaddr;
+  uint32        pcich2status1;
+  uint32        pcich2status2;
+
+  uint32        perm_id;                /* permanent device and vendor id */
+  uint32        perm_rev;               /* permanent revision id */
+} MpiRegisters;
+
+#define MPI ((volatile MpiRegisters * const) MPI_BASE)
+
+/* PCI configuration address space start offset 0x40 */
+#define BRCM_PCI_CONFIG_TIMER               0x40
+#define BRCM_PCI_CONFIG_TIMER_RETRY_MASK	0x0000FF00
+#define BRCM_PCI_CONFIG_TIMER_TRDY_MASK		0x000000FF
+
+/* USB host non-Open HCI register, USB_HOST_NON_OHCI, bit definitions. */
+#define NON_OHCI_ENABLE_PORT1   0x00000001 /* Use USB port 1 for host, not dev */
+#define NON_OHCI_BYTE_SWAP      0x00000008 /* Swap USB host registers */
+
+#define USBH_NON_OHCI ((volatile unsigned long * const) USB_HOST_NON_OHCI)
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcmTag.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcmTag.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcmTag.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcmTag.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,153 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+//**************************************************************************************
+// File Name  : bcmTag.h
+//
+// Description: add tag with validation system to the firmware image file to be uploaded
+//              via http
+//
+// Created    : 02/28/2002  seanl
+//**************************************************************************************
+
+#ifndef _BCMTAG_H_
+#define _BCMTAG_H_
+
+
+#define BCM_SIG_1   "Broadcom Corporation"
+#define BCM_SIG_2   "ver. 2.0"          // was "firmware version 2.0" now it is split 6 char out for chip id.
+
+#define BCM_TAG_VER         "6"
+#define BCM_TAG_VER_LAST    "26"
+
+// file tag (head) structure all is in clear text except validationTokens (crc, md5, sha1, etc). Total: 128 unsigned chars
+#define TAG_LEN         256
+#define TAG_VER_LEN     4
+#define SIG_LEN         20
+#define SIG_LEN_2       14   // Original second SIG = 20 is now devided into 14 for SIG_LEN_2 and 6 for CHIP_ID
+#define CHIP_ID_LEN		6	
+#define IMAGE_LEN       10
+#define ADDRESS_LEN     12
+#define FLAG_LEN        2
+#define TOKEN_LEN       20
+#define BOARD_ID_LEN    16
+#define RESERVED_LEN    (TAG_LEN - TAG_VER_LEN - SIG_LEN - SIG_LEN_2 - CHIP_ID_LEN - BOARD_ID_LEN - \
+                        (4*IMAGE_LEN) - (3*ADDRESS_LEN) - (3*FLAG_LEN) - (2*TOKEN_LEN))
+
+
+// TAG for downloadable image (kernel plus file system)
+typedef struct _FILE_TAG
+{
+    unsigned char tagVersion[TAG_VER_LEN];       // tag version.  Will be 2 here.
+    unsigned char signiture_1[SIG_LEN];          // text line for company info
+    unsigned char signiture_2[SIG_LEN_2];        // additional info (can be version number)
+    unsigned char chipId[CHIP_ID_LEN];			 // chip id 
+    unsigned char boardId[BOARD_ID_LEN];         // board id
+    unsigned char bigEndian[FLAG_LEN];           // if = 1 - big, = 0 - little endia of the host
+    unsigned char totalImageLen[IMAGE_LEN];      // the sum of all the following length
+    unsigned char cfeAddress[ADDRESS_LEN];       // if non zero, cfe starting address
+    unsigned char cfeLen[IMAGE_LEN];             // if non zero, cfe size in clear ASCII text.
+    unsigned char rootfsAddress[ADDRESS_LEN];    // if non zero, filesystem starting address
+    unsigned char rootfsLen[IMAGE_LEN];          // if non zero, filesystem size in clear ASCII text.
+    unsigned char kernelAddress[ADDRESS_LEN];    // if non zero, kernel starting address
+    unsigned char kernelLen[IMAGE_LEN];          // if non zero, kernel size in clear ASCII text.
+    unsigned char dualImage[FLAG_LEN];           // if 1, dual image
+    unsigned char inactiveLen[FLAG_LEN];         // if 1, the image is INACTIVE; if 0, active 
+    unsigned char reserved[RESERVED_LEN];        // reserved for later use
+    unsigned char imageValidationToken[TOKEN_LEN];// image validation token - can be crc, md5, sha;  for
+                                                 // now will be 4 unsigned char crc
+    unsigned char tagValidationToken[TOKEN_LEN]; // validation token for tag(from signiture_1 to end of // mageValidationToken)
+} FILE_TAG, *PFILE_TAG;
+
+#define CRC32_INIT_VALUE 0xffffffff /* Initial CRC32 checksum value */
+#define CRC_LEN 4
+
+// only included if for bcmTag.exe program
+#ifdef BCMTAG_EXE_USE
+
+static unsigned long Crc32_table[256] = {
+    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
+    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
+    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
+    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
+    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
+    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
+    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
+    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
+    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
+    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
+    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
+    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
+    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
+    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
+    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
+    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
+    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
+    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
+    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
+    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
+    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
+    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
+    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
+    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
+    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
+    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
+    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
+    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
+    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
+    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
+    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
+    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
+    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
+    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
+    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
+    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
+    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
+    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
+    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
+    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
+    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
+    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
+    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
+    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
+    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
+    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
+    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
+    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
+    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
+    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
+    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
+    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
+    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
+    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
+    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
+    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
+    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
+    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
+    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
+    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
+    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
+    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
+    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
+    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
+};
+#endif // BCMTAG_USE
+
+
+#endif // _BCMTAG_H_
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcm_intr.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcm_intr.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcm_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcm_intr.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM_INTR_H
+#define __BCM_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+#if defined(CONFIG_BCM96338)
+#include <6338_intr.h>
+#endif
+#if defined(CONFIG_BCM96345)
+#include <6345_intr.h>
+#endif
+#if defined(CONFIG_BCM96348)
+#include <6348_intr.h>
+#endif
+
+/* defines */
+struct pt_regs;
+typedef int (*FN_HANDLER) (int, void *, struct pt_regs *);
+
+/* prototypes */
+extern void enable_brcm_irq(unsigned int irq);
+extern void disable_brcm_irq(unsigned int irq);
+extern int request_external_irq(unsigned int irq,
+    FN_HANDLER handler, unsigned long irqflags, 
+    const char * devname, void *dev_id);
+extern unsigned int BcmHalMapInterrupt(FN_HANDLER isr, unsigned int param,
+    unsigned int interruptId);
+extern void dump_intr_regs(void);
+
+/* compatibility definitions */
+#define BcmHalInterruptEnable(irq)      enable_brcm_irq( irq )
+#define BcmHalInterruptDisable(irq)     disable_brcm_irq( irq )
+
+#ifdef __cplusplus
+    }
+#endif
+
+#endif
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcm_map_part.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcm_map_part.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcm_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcm_map_part.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM_MAP_PART_H
+#define __BCM_MAP_PART_H
+
+#if defined(CONFIG_BCM96338)
+#include <6338_map_part.h>
+#endif
+#if defined(CONFIG_BCM96345)
+#include <6345_map_part.h>
+#endif
+#if defined(CONFIG_BCM96348)
+#include <6348_map_part.h>
+#endif
+
+#endif
+
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcmpci.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcmpci.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcmpci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcmpci.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,87 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+//
+// bcmpci.h - bcm96348 PCI, Cardbus, and PCMCIA definition
+//
+#ifndef BCMPCI_H
+#define BCMPCI_H
+
+/* Memory window in internal system bus address space */ 
+#define BCM_PCI_MEM_BASE        0x08000000
+/* IO window in internal system bus address space */ 
+#define BCM_PCI_IO_BASE         0x0C000000
+
+#define BCM_PCI_ADDR_MASK       0x1fffffff
+
+/* Memory window size (range) */
+#define BCM_PCI_MEM_SIZE_16MB   0x01000000
+/* IO window size (range) */
+#define BCM_PCI_IO_SIZE_64KB    0x00010000
+
+/* PCI Configuration and I/O space acesss */
+#define BCM_PCI_CFG(d, f, o)    ( (d << 11) | (f << 8) | (o/4 << 2) )
+
+/* fake USB PCI slot */
+#define USB_HOST_SLOT           9
+#define USB_BAR0_MEM_SIZE       0x0800
+
+#define BCM_HOST_MEM_SPACE1     0x10000000
+#define BCM_HOST_MEM_SPACE2     0x00000000
+
+/* 
+ * EBI bus clock is 33MHz and share with PCI bus
+ * each clock cycle is 30ns.
+ */
+/* attribute memory access wait cnt for 4306 */
+#define PCMCIA_ATTR_CE_HOLD     3  // data hold time 70ns
+#define PCMCIA_ATTR_CE_SETUP    3  // data setup time 50ns
+#define PCMCIA_ATTR_INACTIVE    6  // time between read/write cycles 180ns. For the total cycle time 600ns (cnt1+cnt2+cnt3+cnt4)
+#define PCMCIA_ATTR_ACTIVE      10 // OE/WE pulse width 300ns
+
+/* common memory access wait cnt for 4306 */
+#define PCMCIA_MEM_CE_HOLD      1  // data hold time 30ns
+#define PCMCIA_MEM_CE_SETUP     1  // data setup time 30ns
+#define PCMCIA_MEM_INACTIVE     2  // time between read/write cycles 40ns. For the total cycle time 250ns (cnt1+cnt2+cnt3+cnt4)
+#define PCMCIA_MEM_ACTIVE       5  // OE/WE pulse width 150ns
+
+#define PCCARD_VCC_MASK     0x00070000  // Mask Reset also
+#define PCCARD_VCC_33V      0x00010000
+#define PCCARD_VCC_50V      0x00020000
+
+typedef enum {
+    MPI_CARDTYPE_NONE,      // No Card in slot
+    MPI_CARDTYPE_PCMCIA,    // 16-bit PCMCIA card in slot    
+    MPI_CARDTYPE_CARDBUS,   // 32-bit CardBus card in slot
+}   CardType;
+
+#define CARDBUS_SLOT        0    // Slot 0 is default for CardBus
+
+#define pcmciaAttrOffset    0x00200000
+#define pcmciaMemOffset     0x00000000
+// Needs to be right above PCI I/O space. Give 0x8000 (32K) to PCMCIA. 
+#define pcmciaIoOffset      (BCM_PCI_IO_BASE + 0x80000)
+// Base Address is that mapped into the MPI ChipSelect registers. 
+// UBUS bridge MemoryWindow 0 outputs a 0x00 for the base.
+#define pcmciaBase          0xbf000000
+#define pcmciaAttr          (pcmciaAttrOffset | pcmciaBase)
+#define pcmciaMem           (pcmciaMemOffset  | pcmciaBase)
+#define pcmciaIo            (pcmciaIoOffset   | pcmciaBase)
+
+#endif
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcmtypes.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcmtypes.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/bcmtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/bcmtypes.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,163 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+//
+// bcmtypes.h - misc useful typedefs
+//
+#ifndef BCMTYPES_H
+#define BCMTYPES_H
+
+// These are also defined in typedefs.h in the application area, so I need to
+// protect against re-definition.
+
+#ifndef _TYPEDEFS_H_
+typedef unsigned char   uint8;
+typedef unsigned short  uint16;
+typedef unsigned long   uint32;
+typedef signed char     int8;
+typedef signed short    int16;
+typedef signed long     int32;
+#if !defined(__cplusplus)
+typedef	int	bool;
+#endif
+#endif
+
+typedef unsigned char   byte;
+// typedef unsigned long   sem_t;
+
+typedef unsigned long   HANDLE,*PULONG,DWORD,*PDWORD;
+typedef signed long     LONG,*PLONG;
+
+typedef unsigned int    *PUINT;
+typedef signed int      INT;
+
+typedef unsigned short  *PUSHORT;
+typedef signed short    SHORT,*PSHORT;
+typedef unsigned short  WORD,*PWORD;
+
+typedef unsigned char   *PUCHAR;
+typedef signed char     *PCHAR;
+
+typedef void            *PVOID;
+
+typedef unsigned char   BOOLEAN, *PBOOL, *PBOOLEAN;
+
+typedef unsigned char   BYTE,*PBYTE;
+
+//#ifndef __GNUC__
+//The following has been defined in Vxworks internally: vxTypesOld.h
+//redefine under vxworks will cause error
+typedef signed int      *PINT;
+
+typedef signed char     INT8;
+typedef signed short    INT16;
+typedef signed long     INT32;
+
+typedef unsigned char   UINT8;
+typedef unsigned short  UINT16;
+typedef unsigned long   UINT32;
+
+typedef unsigned char   UCHAR;
+typedef unsigned short  USHORT;
+typedef unsigned int    UINT;
+typedef unsigned long   ULONG;
+
+typedef void            VOID;
+typedef unsigned char   BOOL;
+
+//#endif  /* __GNUC__ */
+
+
+// These are also defined in typedefs.h in the application area, so I need to
+// protect against re-definition.
+#ifndef TYPEDEFS_H
+
+// Maximum and minimum values for a signed 16 bit integer.
+#define MAX_INT16 32767
+#define MIN_INT16 -32768
+
+// Useful for true/false return values.  This uses the
+// Taligent notation (k for constant).
+typedef enum
+{
+    kFalse = 0,
+    kTrue = 1
+} Bool;
+
+#endif
+
+/* macros to protect against unaligned accesses */
+
+#if 0
+/* first arg is an address, second is a value */
+#define PUT16( a, d ) { 		\
+  *((byte *)a) = (byte)((d)>>8); 	\
+  *(((byte *)a)+1) = (byte)(d); 	\
+}
+
+#define PUT32( a, d ) { 		\
+  *((byte *)a) = (byte)((d)>>24); 	\
+  *(((byte *)a)+1) = (byte)((d)>>16); 	\
+  *(((byte *)a)+2) = (byte)((d)>>8); 	\
+  *(((byte *)a)+3) = (byte)(d); 	\
+}
+
+/* first arg is an address, returns a value */
+#define GET16( a ) ( 			\
+  (*((byte *)a) << 8) |			\
+  (*(((byte *)a)+1))	 		\
+)
+
+#define GET32( a ) ( 			\
+  (*((byte *)a) << 24)     |		\
+  (*(((byte *)a)+1) << 16) | 		\
+  (*(((byte *)a)+2) << 8)  | 		\
+  (*(((byte *)a)+3))	 		\
+)
+#endif
+
+#ifndef YES
+#define YES 1
+#endif
+
+#ifndef NO
+#define NO  0
+#endif
+
+#ifndef IN
+#define IN
+#endif
+
+#ifndef OUT
+#define OUT
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE  0
+#endif
+
+#define READ32(addr)        (*(volatile UINT32 *)((ULONG)&addr))
+#define READ16(addr)        (*(volatile UINT16 *)((ULONG)&addr))
+#define READ8(addr)         (*(volatile UINT8  *)((ULONG)&addr))
+
+#endif
diff -Naurp linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/board.h linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/board.h
--- linux-2.6.16.7-generic-patched/bcmdrivers/opensource/include/bcm963xx/board.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.7-patched/bcmdrivers/opensource/include/bcm963xx/board.h	2006-07-05 15:21:58.000000000 +0200
@@ -0,0 +1,374 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE:  board.h                                                  */
+/*   DATE:    97/02/18                                                 */
+/*   PURPOSE: Board specific information.  This module should include  */
+/*            all base device addresses and board specific macros.     */
+/*                                                                     */
+/***********************************************************************/
+#ifndef _BOARD_H
+#define _BOARD_H
+
+#if __cplusplus
+extern "C" {
+#endif
+/*****************************************************************************/
+/*                    Misc board definitions                                 */
+/*****************************************************************************/
+
+#define	DYING_GASP_API
+
+/*****************************************************************************/
+/*                    Physical Memory Map                                    */
+/*****************************************************************************/
+
+#define PHYS_DRAM_BASE           0x00000000     /* Dynamic RAM Base */
+#define PHYS_FLASH_BASE          0x1FC00000     /* Flash Memory         */
+
+/*****************************************************************************/
+/* Note that the addresses above are physical addresses and that programs    */
+/* have to use converted addresses defined below:                            */
+/*****************************************************************************/
+#define DRAM_BASE           (0x80000000 | PHYS_DRAM_BASE)   /* cached DRAM */
+#define DRAM_BASE_NOCACHE   (0xA0000000 | PHYS_DRAM_BASE)   /* uncached DRAM */
+#define FLASH_BASE          (0xA0000000 | PHYS_FLASH_BASE)  /* uncached Flash  */
+
+/*****************************************************************************/
+/*  Select the PLL value to get the desired CPU clock frequency.             */
+/*                                                                           */
+/*                                                                           */
+/*****************************************************************************/
+#define FPERIPH            50000000
+
+#define ONEK                            1024
+#define BLK64K                          (64*ONEK)
+#define FLASH45_BLKS_BOOT_ROM           1
+#define FLASH45_LENGTH_BOOT_ROM         (FLASH45_BLKS_BOOT_ROM * BLK64K)
+#define FLASH_RESERVED_AT_END           (64*ONEK) /*reserved for PSI, scratch pad*/
+    
+/*****************************************************************************/
+/* Note that the addresses above are physical addresses and that programs    */
+/* have to use converted addresses defined below:                            */
+/*****************************************************************************/
+#define DRAM_BASE           (0x80000000 | PHYS_DRAM_BASE)   /* cached DRAM */
+#define DRAM_BASE_NOCACHE   (0xA0000000 | PHYS_DRAM_BASE)   /* uncached DRAM */
+#define FLASH_BASE          (0xA0000000 | PHYS_FLASH_BASE)  /* uncached Flash  */
+
+/*****************************************************************************/
+/*  Select the PLL value to get the desired CPU clock frequency.             */
+/*                                                                           */
+/*                                                                           */
+/*****************************************************************************/
+#define FPERIPH            50000000
+    
+#define SDRAM_TYPE_ADDRESS_OFFSET   16
+#define NVRAM_DATA_OFFSET           0x0580
+#define NVRAM_DATA_ID               0x0f1e2d3c
+#define BOARD_SDRAM_TYPE            *(unsigned long *) \
+                                    (FLASH_BASE + SDRAM_TYPE_ADDRESS_OFFSET)
+
+#define ONEK                1024
+#define BLK64K              (64*ONEK)
+
+// nvram and psi flash definitions for 45
+#define FLASH45_LENGTH_NVRAM            ONEK            // 1k nvram 
+#define NVRAM_PSI_DEFAULT               24              // default psi in K byes
+
+/*****************************************************************************/
+/*       NVRAM Offset and definition                                         */
+/*****************************************************************************/
+
+#define NVRAM_VERSION_NUMBER            2
+#define NVRAM_VERSION_NUMBER_ADDRESS    0
+
+#define NVRAM_BOOTLINE_LEN              256
+#define NVRAM_BOARD_ID_STRING_LEN       16
+#define NVRAM_MAC_ADDRESS_LEN           6
+#define NVRAM_MAC_COUNT_MAX             32
+
+/*****************************************************************************/
+/*       Misc Offsets                                                        */
+/*****************************************************************************/
+
+#define CFE_VERSION_OFFSET           0x0570
+#define CFE_VERSION_MARK_SIZE        5
+#define CFE_VERSION_SIZE             5
+
+typedef struct
+{
+    unsigned long ulVersion;
+    char szBootline[NVRAM_BOOTLINE_LEN];
+    char szBoardId[NVRAM_BOARD_ID_STRING_LEN];
+    unsigned long ulReserved1[2];
+    unsigned long ulNumMacAddrs;
+    unsigned char ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN];
+    char chReserved[2];
+    unsigned long ulCheckSum;
+} NVRAM_DATA, *PNVRAM_DATA;
+
+
+/*****************************************************************************/
+/*          board ioctl calls for flash, led and some other utilities        */
+/*****************************************************************************/
+
+
+/* Defines. for board driver */
+#define BOARD_IOCTL_MAGIC       'B'
+#define BOARD_DRV_MAJOR          206
+
+#define MAC_ADDRESS_ANY         (unsigned long) -1
+
+#define BOARD_IOCTL_FLASH_INIT \
+    _IOWR(BOARD_IOCTL_MAGIC, 0, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_FLASH_WRITE \
+    _IOWR(BOARD_IOCTL_MAGIC, 1, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_FLASH_READ \
+    _IOWR(BOARD_IOCTL_MAGIC, 2, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_NR_PAGES \
+    _IOWR(BOARD_IOCTL_MAGIC, 3, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_DUMP_ADDR \
+    _IOWR(BOARD_IOCTL_MAGIC, 4, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_MEMORY \
+    _IOWR(BOARD_IOCTL_MAGIC, 5, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_MIPS_SOFT_RESET \
+    _IOWR(BOARD_IOCTL_MAGIC, 6, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_LED_CTRL \
+    _IOWR(BOARD_IOCTL_MAGIC, 7, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_ID \
+    _IOWR(BOARD_IOCTL_MAGIC, 8, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 9, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_RELEASE_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 10, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_PSI_SIZE \
+    _IOWR(BOARD_IOCTL_MAGIC, 11, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_SDRAM_SIZE \
+    _IOWR(BOARD_IOCTL_MAGIC, 12, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_MONITOR_FD \
+    _IOWR(BOARD_IOCTL_MAGIC, 13, BOARD_IOCTL_PARMS)
+    
+#define BOARD_IOCTL_WAKEUP_MONITOR_TASK \
+    _IOWR(BOARD_IOCTL_MAGIC, 14, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_BOOTLINE \
+    _IOWR(BOARD_IOCTL_MAGIC, 15, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_BOOTLINE \
+    _IOWR(BOARD_IOCTL_MAGIC, 16, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_BASE_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 17, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_CHIP_ID \
+    _IOWR(BOARD_IOCTL_MAGIC, 18, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_NUM_ENET \
+    _IOWR(BOARD_IOCTL_MAGIC, 19, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_CFE_VER \
+    _IOWR(BOARD_IOCTL_MAGIC, 20, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_ENET_CFG \
+    _IOWR(BOARD_IOCTL_MAGIC, 21, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_WLAN_ANT_INUSE \
+    _IOWR(BOARD_IOCTL_MAGIC, 22, BOARD_IOCTL_PARMS)
+    
+#define BOARD_IOCTL_SET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 23, BOARD_IOCTL_PARMS)        
+
+#define BOARD_IOCTL_GET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 24, BOARD_IOCTL_PARMS)        
+
+#define BOARD_IOCTL_UNSET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 25, BOARD_IOCTL_PARMS) 
+
+#define BOARD_IOCTL_SET_SES_LED \
+    _IOWR(BOARD_IOCTL_MAGIC, 26, BOARD_IOCTL_PARMS)
+
+//<<JUNHON, 2004/09/15, get reset button status , tim hou , 05/04/12
+#define RESET_BUTTON_UP           1
+#define RESET_BUTTON_PRESSDOWN    0
+#define BOARD_IOCTL_GET_RESETHOLD \
+    _IOWR(BOARD_IOCTL_MAGIC, 27, BOARD_IOCTL_PARMS)
+//>>JUNHON, 2004/09/15    
+    
+// for the action in BOARD_IOCTL_PARMS for flash operation
+typedef enum 
+{
+    PERSISTENT,
+    NVRAM,
+    BCM_IMAGE_CFE,
+    BCM_IMAGE_FS,
+    BCM_IMAGE_KERNEL,
+    BCM_IMAGE_WHOLE,
+    SCRATCH_PAD,
+    FLASH_SIZE,
+} BOARD_IOCTL_ACTION;
+    
+    
+typedef struct boardIoctParms
+{
+    char *string;
+    char *buf;
+    int strLen;
+    int offset;
+    BOARD_IOCTL_ACTION  action;        /* flash read/write: nvram, persistent, bcm image */
+    int result;
+} BOARD_IOCTL_PARMS;
+
+
+// LED defines 
+typedef enum
+{   
+    kLedAdsl,
+    kLedWireless,
+    kLedUsb,
+    kLedHpna,
+    kLedWanData,
+    kLedPPP,
+    kLedVoip,
+    kLedSes,
+    kLedEnd,                // NOTE: Insert the new led name before this one.  Alway stay at the end.
+} BOARD_LED_NAME;
+
+typedef enum
+{
+    kLedStateOff,                        /* turn led off */
+    kLedStateOn,                         /* turn led on */
+    kLedStateFail,                       /* turn led on red */
+    kLedStateBlinkOnce,                  /* blink once, ~100ms and ignore the same call during the 100ms period */
+    kLedStateSlowBlinkContinues,         /* slow blink continues at ~600ms interval */
+    kLedStateFastBlinkContinues,         /* fast blink continues at ~200ms interval */
+} BOARD_LED_STATE;
+
+
+// virtual and physical map pair defined in board.c
+typedef struct ledmappair
+{
+    BOARD_LED_NAME ledName;         // virtual led name
+    BOARD_LED_STATE ledInitState;   // initial led state when the board boots.
+    unsigned short ledMask;         // physical GPIO pin mask
+    unsigned short ledActiveLow;    // reset bit to turn on LED
+    unsigned short ledMaskFail;     // physical GPIO pin mask for state failure
+    unsigned short ledActiveLowFail;// reset bit to turn on LED
+} LED_MAP_PAIR, *PLED_MAP_PAIR;
+
+typedef void (*HANDLE_LED_FUNC)(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState);
+
+/* Flash storage address information that is determined by the flash driver. */
+typedef struct flashaddrinfo
+{
+    int flash_persistent_start_blk;
+    int flash_persistent_number_blk;
+    int flash_persistent_length;
+    unsigned long flash_persistent_blk_offset;
+    int flash_scratch_pad_start_blk;         // start before psi (SP_BUF_LEN)
+    int flash_scratch_pad_number_blk;
+    int flash_scratch_pad_length;
+    unsigned long flash_scratch_pad_blk_offset;
+    int flash_nvram_start_blk;
+    int flash_nvram_number_blk;
+    int flash_nvram_length;
+    unsigned long flash_nvram_blk_offset;
+} FLASH_ADDR_INFO, *PFLASH_ADDR_INFO;
+
+// scratch pad defines
+/* SP - Persisten Scratch Pad format:
+       sp header        : 32 bytes
+       tokenId-1        : 8 bytes
+       tokenId-1 len    : 4 bytes
+       tokenId-1 data    
+       ....
+       tokenId-n        : 8 bytes
+       tokenId-n len    : 4 bytes
+       tokenId-n data    
+*/
+
+#define MAGIC_NUM_LEN       8
+#define MAGIC_NUMBER        "gOGoBrCm"
+#define TOKEN_NAME_LEN      16
+#define SP_VERSION          1
+#define SP_MAX_LEN          8 * 1024            // 8k buf before psi
+#define SP_RESERVERD        16
+
+typedef struct _SP_HEADER
+{
+    char SPMagicNum[MAGIC_NUM_LEN];             // 8 bytes of magic number
+    int SPVersion;                              // version number
+    int SPUsedLen;                              // used sp len   
+    char SPReserved[SP_RESERVERD];              // reservied, total 32 bytes
+} SP_HEADER, *PSP_HEADER;
+
+typedef struct _TOKEN_DEF
+{
+    char tokenName[TOKEN_NAME_LEN];
+    int tokenLen;
+} SP_TOKEN, *PSP_TOKEN;
+
+
+/*****************************************************************************/
+/*          Function Prototypes                                              */
+/*****************************************************************************/
+#if !defined(__ASM_ASM_H)
+void dumpaddr( unsigned char *pAddr, int nLen );
+
+void kerSysFlashAddrInfoGet(PFLASH_ADDR_INFO pflash_addr_info);
+int kerSysNvRamGet(char *string, int strLen, int offset);
+int kerSysNvRamSet(char *string, int strLen, int offset);
+int kerSysPersistentGet(char *string, int strLen, int offset);
+int kerSysPersistentSet(char *string, int strLen, int offset);
+int kerSysScratchPadGet(char *tokName, char *tokBuf, int tokLen);
+int kerSysScratchPadSet(char *tokName, char *tokBuf, int tokLen);
+int kerSysBcmImageSet( int flash_start_addr, char *string, int size);
+int kerSysGetMacAddress( unsigned char *pucaAddr, unsigned long ulId );
+int kerSysReleaseMacAddress( unsigned char *pucaAddr );
+int kerSysGetSdramSize( void );
+void kerSysGetBootline(char *string, int strLen);
+void kerSysSetBootline(char *string, int strLen);
+void kerSysMipsSoftReset(void);
+void kerSysLedCtrl(BOARD_LED_NAME, BOARD_LED_STATE);
+void kerSysLedRegisterHwHandler( BOARD_LED_NAME, HANDLE_LED_FUNC, int );
+int kerSysFlashSizeGet(void);
+void kerSysRegisterDyingGaspHandler(char *devname, void *cbfn, void *context);
+void kerSysDeregisterDyingGaspHandler(char *devname);    
+void kerSysWakeupMonitorTask( void );
+#endif
+
+#if __cplusplus
+}
+#endif
+
+#endif /* _BOARD_H */
+
