diff -Nur linux-2.6.15.1/Documentation/feature-removal-schedule.txt linux-2.6.15.1-owrt/Documentation/feature-removal-schedule.txt
--- linux-2.6.15.1/Documentation/feature-removal-schedule.txt	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/Documentation/feature-removal-schedule.txt	2006-01-27 15:03:21.000000000 +0100
@@ -143,6 +143,15 @@
 
 ---------------------------
 
+What:	CONFIG_FORCED_INLINING
+When:	June 2006
+Why:	Config option is there to see if gcc is good enough. (in january
+	2006). If it is, the behavior should just be the default. If it's not,
+	the option should just go away entirely.
+Who:	Arjan van de Ven
+
+---------------------------
+
 What:	START_ARRAY ioctl for md
 When:	July 2006
 Files:	drivers/md/md.c
diff -Nur linux-2.6.15.1/drivers/acpi/ec.c linux-2.6.15.1-owrt/drivers/acpi/ec.c
--- linux-2.6.15.1/drivers/acpi/ec.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/acpi/ec.c	2006-01-27 15:08:36.000000000 +0100
@@ -153,7 +153,7 @@
                              Transaction Management
    -------------------------------------------------------------------------- */
 
-static inline u32 acpi_ec_read_status(union acpi_ec *ec)
+static u32 acpi_ec_read_status(union acpi_ec *ec)
 {
 	u32 status = 0;
 
diff -Nur linux-2.6.15.1/drivers/base/firmware_class.c linux-2.6.15.1-owrt/drivers/base/firmware_class.c
--- linux-2.6.15.1/drivers/base/firmware_class.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/base/firmware_class.c	2006-01-27 15:08:36.000000000 +0100
@@ -47,7 +47,7 @@
 	struct timer_list timeout;
 };
 
-static inline void
+static void
 fw_load_abort(struct firmware_priv *fw_priv)
 {
 	set_bit(FW_STATUS_ABORT, &fw_priv->status);
diff -Nur linux-2.6.15.1/drivers/block/loop.c linux-2.6.15.1-owrt/drivers/block/loop.c
--- linux-2.6.15.1/drivers/block/loop.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/block/loop.c	2006-01-27 15:08:36.000000000 +0100
@@ -281,7 +281,7 @@
  * This helper just factors out common code between do_lo_send_direct_write()
  * and do_lo_send_write().
  */
-static inline int __do_lo_send_write(struct file *file,
+static int __do_lo_send_write(struct file *file,
 		u8 __user *buf, const int len, loff_t pos)
 {
 	ssize_t bw;
diff -Nur linux-2.6.15.1/drivers/bluetooth/hci_bcsp.c linux-2.6.15.1-owrt/drivers/bluetooth/hci_bcsp.c
--- linux-2.6.15.1/drivers/bluetooth/hci_bcsp.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/bluetooth/hci_bcsp.c	2006-01-27 15:08:36.000000000 +0100
@@ -494,7 +494,7 @@
 	}
 }
 
-static inline void bcsp_complete_rx_pkt(struct hci_uart *hu)
+static void bcsp_complete_rx_pkt(struct hci_uart *hu)
 {
 	struct bcsp_struct *bcsp = hu->priv;
 	int pass_up;
diff -Nur linux-2.6.15.1/drivers/char/drm/r128_state.c linux-2.6.15.1-owrt/drivers/char/drm/r128_state.c
--- linux-2.6.15.1/drivers/char/drm/r128_state.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/char/drm/r128_state.c	2006-01-27 15:08:36.000000000 +0100
@@ -220,7 +220,7 @@
 	ADVANCE_RING();
 }
 
-static __inline__ void r128_emit_state(drm_r128_private_t * dev_priv)
+static void r128_emit_state(drm_r128_private_t * dev_priv)
 {
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	unsigned int dirty = sarea_priv->dirty;
diff -Nur linux-2.6.15.1/drivers/cpufreq/cpufreq.c linux-2.6.15.1-owrt/drivers/cpufreq/cpufreq.c
--- linux-2.6.15.1/drivers/cpufreq/cpufreq.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/cpufreq/cpufreq.c	2006-01-27 15:08:36.000000000 +0100
@@ -41,7 +41,6 @@
 /* internal prototypes */
 static int __cpufreq_governor(struct cpufreq_policy *policy, unsigned int event);
 static void handle_update(void *data);
-static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci);
 
 /**
  * Two notifier lists: the "policy" list is involved in the 
@@ -127,7 +126,7 @@
 static unsigned int disable_ratelimit = 1;
 static DEFINE_SPINLOCK(disable_ratelimit_lock);
 
-static inline void cpufreq_debug_enable_ratelimit(void)
+static void cpufreq_debug_enable_ratelimit(void)
 {
 	unsigned long flags;
 
@@ -137,7 +136,7 @@
 	spin_unlock_irqrestore(&disable_ratelimit_lock, flags);
 }
 
-static inline void cpufreq_debug_disable_ratelimit(void)
+static void cpufreq_debug_disable_ratelimit(void)
 {
 	unsigned long flags;
 
@@ -206,7 +205,7 @@
 static unsigned long l_p_j_ref;
 static unsigned int  l_p_j_ref_freq;
 
-static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)
+static void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)
 {
 	if (ci->flags & CPUFREQ_CONST_LOOPS)
 		return;
diff -Nur linux-2.6.15.1/drivers/ide/ide-cd.c linux-2.6.15.1-owrt/drivers/ide/ide-cd.c
--- linux-2.6.15.1/drivers/ide/ide-cd.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/ide/ide-cd.c	2006-01-27 15:08:36.000000000 +0100
@@ -980,7 +980,7 @@
  * and attempt to recover if there are problems.  Returns  0 if everything's
  * ok; nonzero if the request has been terminated.
  */
-static inline
+static
 int cdrom_read_check_ireason (ide_drive_t *drive, int len, int ireason)
 {
 	if (ireason == 2)
@@ -1541,7 +1541,7 @@
 /*
  * Write handling
  */
-static inline int cdrom_write_check_ireason(ide_drive_t *drive, int len, int ireason)
+static int cdrom_write_check_ireason(ide_drive_t *drive, int len, int ireason)
 {
 	/* Two notes about IDE interrupt reason here - 0 means that
 	 * the drive wants to receive data from us, 2 means that
diff -Nur linux-2.6.15.1/drivers/ide/ide-disk.c linux-2.6.15.1-owrt/drivers/ide/ide-disk.c
--- linux-2.6.15.1/drivers/ide/ide-disk.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/ide/ide-disk.c	2006-01-27 15:08:36.000000000 +0100
@@ -477,7 +477,7 @@
 	       && id->lba_capacity_2;
 }
 
-static inline void idedisk_check_hpa(ide_drive_t *drive)
+static void idedisk_check_hpa(ide_drive_t *drive)
 {
 	unsigned long long capacity, set_max;
 	int lba48 = idedisk_supports_lba48(drive->id);
diff -Nur linux-2.6.15.1/drivers/ide/ide-taskfile.c linux-2.6.15.1-owrt/drivers/ide/ide-taskfile.c
--- linux-2.6.15.1/drivers/ide/ide-taskfile.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/ide/ide-taskfile.c	2006-01-27 15:08:36.000000000 +0100
@@ -308,7 +308,7 @@
 		ide_pio_sector(drive, write);
 }
 
-static inline void ide_pio_datablock(ide_drive_t *drive, struct request *rq,
+static void ide_pio_datablock(ide_drive_t *drive, struct request *rq,
 				     unsigned int write)
 {
 	if (rq->bio)	/* fs request */
diff -Nur linux-2.6.15.1/drivers/infiniband/core/cm.c linux-2.6.15.1-owrt/drivers/infiniband/core/cm.c
--- linux-2.6.15.1/drivers/infiniband/core/cm.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/infiniband/core/cm.c	2006-01-27 15:08:36.000000000 +0100
@@ -850,7 +850,7 @@
 		       param->private_data_len);
 }
 
-static inline int cm_validate_req_param(struct ib_cm_req_param *param)
+static int cm_validate_req_param(struct ib_cm_req_param *param)
 {
 	/* peer-to-peer not supported */
 	if (param->peer_to_peer)
@@ -999,7 +999,7 @@
 		 (be32_to_cpu(local_qpn) > be32_to_cpu(remote_qpn))));
 }
 
-static inline void cm_format_paths_from_req(struct cm_req_msg *req_msg,
+static void cm_format_paths_from_req(struct cm_req_msg *req_msg,
 					    struct ib_sa_path_rec *primary_path,
 					    struct ib_sa_path_rec *alt_path)
 {
diff -Nur linux-2.6.15.1/drivers/isdn/hisax/avm_pci.c linux-2.6.15.1-owrt/drivers/isdn/hisax/avm_pci.c
--- linux-2.6.15.1/drivers/isdn/hisax/avm_pci.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/isdn/hisax/avm_pci.c	2006-01-27 15:08:36.000000000 +0100
@@ -358,7 +358,7 @@
 	}
 }
 
-static inline void
+static void
 HDLC_irq(struct BCState *bcs, u_int stat) {
 	int len;
 	struct sk_buff *skb;
diff -Nur linux-2.6.15.1/drivers/isdn/hisax/diva.c linux-2.6.15.1-owrt/drivers/isdn/hisax/diva.c
--- linux-2.6.15.1/drivers/isdn/hisax/diva.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/isdn/hisax/diva.c	2006-01-27 15:08:36.000000000 +0100
@@ -476,7 +476,7 @@
 	}
 }
 
-static inline void
+static void
 Memhscx_interrupt(struct IsdnCardState *cs, u_char val, u_char hscx)
 {
 	u_char r;
diff -Nur linux-2.6.15.1/drivers/isdn/hisax/hscx_irq.c linux-2.6.15.1-owrt/drivers/isdn/hisax/hscx_irq.c
--- linux-2.6.15.1/drivers/isdn/hisax/hscx_irq.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/isdn/hisax/hscx_irq.c	2006-01-27 15:08:36.000000000 +0100
@@ -119,7 +119,7 @@
 	}
 }
 
-static inline void
+static void
 hscx_interrupt(struct IsdnCardState *cs, u_char val, u_char hscx)
 {
 	u_char r;
@@ -221,7 +221,7 @@
 	}
 }
 
-static inline void
+static void
 hscx_int_main(struct IsdnCardState *cs, u_char val)
 {
 
diff -Nur linux-2.6.15.1/drivers/isdn/hisax/jade_irq.c linux-2.6.15.1-owrt/drivers/isdn/hisax/jade_irq.c
--- linux-2.6.15.1/drivers/isdn/hisax/jade_irq.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/isdn/hisax/jade_irq.c	2006-01-27 15:08:36.000000000 +0100
@@ -110,7 +110,7 @@
 }
 
 
-static inline void
+static void
 jade_interrupt(struct IsdnCardState *cs, u_char val, u_char jade)
 {
 	u_char r;
diff -Nur linux-2.6.15.1/drivers/md/bitmap.c linux-2.6.15.1-owrt/drivers/md/bitmap.c
--- linux-2.6.15.1/drivers/md/bitmap.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/bitmap.c	2006-01-27 15:08:36.000000000 +0100
@@ -200,7 +200,7 @@
 /* if page is completely empty, put it back on the free list, or dealloc it */
 /* if page was hijacked, unmark the flag so it might get alloced next time */
 /* Note: lock should be held when calling this */
-static inline void bitmap_checkfree(struct bitmap *bitmap, unsigned long page)
+static void bitmap_checkfree(struct bitmap *bitmap, unsigned long page)
 {
 	char *ptr;
 
diff -Nur linux-2.6.15.1/drivers/md/dm.c linux-2.6.15.1-owrt/drivers/md/dm.c
--- linux-2.6.15.1/drivers/md/dm.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/dm.c	2006-01-27 15:08:36.000000000 +0100
@@ -292,7 +292,7 @@
  * Decrements the number of outstanding ios that a bio has been
  * cloned into, completing the original io if necc.
  */
-static inline void dec_pending(struct dm_io *io, int error)
+static void dec_pending(struct dm_io *io, int error)
 {
 	if (error)
 		io->error = error;
diff -Nur linux-2.6.15.1/drivers/md/dm-crypt.c linux-2.6.15.1-owrt/drivers/md/dm-crypt.c
--- linux-2.6.15.1/drivers/md/dm-crypt.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/dm-crypt.c	2006-01-27 15:08:36.000000000 +0100
@@ -228,7 +228,7 @@
 };
 
 
-static inline int
+static int
 crypt_convert_scatterlist(struct crypt_config *cc, struct scatterlist *out,
                           struct scatterlist *in, unsigned int length,
                           int write, sector_t sector)
diff -Nur linux-2.6.15.1/drivers/md/dm-ioctl.c linux-2.6.15.1-owrt/drivers/md/dm-ioctl.c
--- linux-2.6.15.1/drivers/md/dm-ioctl.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/dm-ioctl.c	2006-01-27 15:08:36.000000000 +0100
@@ -588,7 +588,7 @@
 /*
  * Always use UUID for lookups if it's present, otherwise use name or dev.
  */
-static inline struct hash_cell *__find_device_hash_cell(struct dm_ioctl *param)
+static struct hash_cell *__find_device_hash_cell(struct dm_ioctl *param)
 {
 	if (*param->uuid)
 		return __get_uuid_cell(param->uuid);
@@ -598,7 +598,7 @@
 		return dm_get_mdptr(huge_decode_dev(param->dev));
 }
 
-static inline struct mapped_device *find_device(struct dm_ioctl *param)
+static struct mapped_device *find_device(struct dm_ioctl *param)
 {
 	struct hash_cell *hc;
 	struct mapped_device *md = NULL;
diff -Nur linux-2.6.15.1/drivers/md/dm-snap.c linux-2.6.15.1-owrt/drivers/md/dm-snap.c
--- linux-2.6.15.1/drivers/md/dm-snap.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/dm-snap.c	2006-01-27 15:08:36.000000000 +0100
@@ -677,7 +677,7 @@
 /*
  * Dispatches the copy operation to kcopyd.
  */
-static inline void start_copy(struct pending_exception *pe)
+static void start_copy(struct pending_exception *pe)
 {
 	struct dm_snapshot *s = pe->snap;
 	struct io_region src, dest;
diff -Nur linux-2.6.15.1/drivers/md/raid10.c linux-2.6.15.1-owrt/drivers/md/raid10.c
--- linux-2.6.15.1/drivers/md/raid10.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/raid10.c	2006-01-27 15:08:36.000000000 +0100
@@ -173,7 +173,7 @@
 	}
 }
 
-static inline void free_r10bio(r10bio_t *r10_bio)
+static void free_r10bio(r10bio_t *r10_bio)
 {
 	unsigned long flags;
 
@@ -194,7 +194,7 @@
 	mempool_free(r10_bio, conf->r10bio_pool);
 }
 
-static inline void put_buf(r10bio_t *r10_bio)
+static void put_buf(r10bio_t *r10_bio)
 {
 	conf_t *conf = mddev_to_conf(r10_bio->mddev);
 	unsigned long flags;
diff -Nur linux-2.6.15.1/drivers/md/raid1.c linux-2.6.15.1-owrt/drivers/md/raid1.c
--- linux-2.6.15.1/drivers/md/raid1.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/raid1.c	2006-01-27 15:08:36.000000000 +0100
@@ -158,7 +158,7 @@
 	}
 }
 
-static inline void free_r1bio(r1bio_t *r1_bio)
+static void free_r1bio(r1bio_t *r1_bio)
 {
 	unsigned long flags;
 
@@ -179,7 +179,7 @@
 	mempool_free(r1_bio, conf->r1bio_pool);
 }
 
-static inline void put_buf(r1bio_t *r1_bio)
+static void put_buf(r1bio_t *r1_bio)
 {
 	conf_t *conf = mddev_to_conf(r1_bio->mddev);
 	unsigned long flags;
diff -Nur linux-2.6.15.1/drivers/md/raid5.c linux-2.6.15.1-owrt/drivers/md/raid5.c
--- linux-2.6.15.1/drivers/md/raid5.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/raid5.c	2006-01-27 15:08:36.000000000 +0100
@@ -71,7 +71,7 @@
 
 static void print_raid5_conf (raid5_conf_t *conf);
 
-static inline void __release_stripe(raid5_conf_t *conf, struct stripe_head *sh)
+static void __release_stripe(raid5_conf_t *conf, struct stripe_head *sh)
 {
 	if (atomic_dec_and_test(&sh->count)) {
 		if (!list_empty(&sh->lru))
@@ -188,7 +188,7 @@
 
 static void raid5_build_block (struct stripe_head *sh, int i);
 
-static inline void init_stripe(struct stripe_head *sh, sector_t sector, int pd_idx)
+static void init_stripe(struct stripe_head *sh, sector_t sector, int pd_idx)
 {
 	raid5_conf_t *conf = sh->raid_conf;
 	int disks = conf->raid_disks, i;
@@ -1421,7 +1421,7 @@
 	}
 }
 
-static inline void raid5_activate_delayed(raid5_conf_t *conf)
+static void raid5_activate_delayed(raid5_conf_t *conf)
 {
 	if (atomic_read(&conf->preread_active_stripes) < IO_THRESHOLD) {
 		while (!list_empty(&conf->delayed_list)) {
@@ -1437,7 +1437,7 @@
 	}
 }
 
-static inline void activate_bit_delay(raid5_conf_t *conf)
+static void activate_bit_delay(raid5_conf_t *conf)
 {
 	/* device_lock is held */
 	struct list_head head;
diff -Nur linux-2.6.15.1/drivers/md/raid6main.c linux-2.6.15.1-owrt/drivers/md/raid6main.c
--- linux-2.6.15.1/drivers/md/raid6main.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/md/raid6main.c	2006-01-27 15:08:36.000000000 +0100
@@ -90,7 +90,7 @@
 
 static void print_raid6_conf (raid6_conf_t *conf);
 
-static inline void __release_stripe(raid6_conf_t *conf, struct stripe_head *sh)
+static void __release_stripe(raid6_conf_t *conf, struct stripe_head *sh)
 {
 	if (atomic_dec_and_test(&sh->count)) {
 		if (!list_empty(&sh->lru))
@@ -207,7 +207,7 @@
 
 static void raid6_build_block (struct stripe_head *sh, int i);
 
-static inline void init_stripe(struct stripe_head *sh, sector_t sector, int pd_idx)
+static void init_stripe(struct stripe_head *sh, sector_t sector, int pd_idx)
 {
 	raid6_conf_t *conf = sh->raid_conf;
 	int disks = conf->raid_disks, i;
@@ -1501,7 +1501,7 @@
 	}
 }
 
-static inline void raid6_activate_delayed(raid6_conf_t *conf)
+static void raid6_activate_delayed(raid6_conf_t *conf)
 {
 	if (atomic_read(&conf->preread_active_stripes) < IO_THRESHOLD) {
 		while (!list_empty(&conf->delayed_list)) {
@@ -1517,7 +1517,7 @@
 	}
 }
 
-static inline void activate_bit_delay(raid6_conf_t *conf)
+static void activate_bit_delay(raid6_conf_t *conf)
 {
 	/* device_lock is held */
 	struct list_head head;
diff -Nur linux-2.6.15.1/drivers/media/video/tvp5150.c linux-2.6.15.1-owrt/drivers/media/video/tvp5150.c
--- linux-2.6.15.1/drivers/media/video/tvp5150.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/media/video/tvp5150.c	2006-01-27 15:08:36.000000000 +0100
@@ -87,7 +87,7 @@
 	int sat;
 };
 
-static inline int tvp5150_read(struct i2c_client *c, unsigned char addr)
+static int tvp5150_read(struct i2c_client *c, unsigned char addr)
 {
 	unsigned char buffer[1];
 	int rc;
diff -Nur linux-2.6.15.1/drivers/message/fusion/mptlan.c linux-2.6.15.1-owrt/drivers/message/fusion/mptlan.c
--- linux-2.6.15.1/drivers/message/fusion/mptlan.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/message/fusion/mptlan.c	2006-01-27 15:08:36.000000000 +0100
@@ -848,7 +848,7 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static inline void
+static void
 mpt_lan_wake_post_buckets_task(struct net_device *dev, int priority)
 /*
  * @priority: 0 = put it on the timer queue, 1 = put it on the immediate queue
@@ -870,7 +870,7 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static inline int
+static int
 mpt_lan_receive_skb(struct net_device *dev, struct sk_buff *skb)
 {
 	struct mpt_lan_priv *priv = dev->priv;
diff -Nur linux-2.6.15.1/drivers/mtd/devices/doc2000.c linux-2.6.15.1-owrt/drivers/mtd/devices/doc2000.c
--- linux-2.6.15.1/drivers/mtd/devices/doc2000.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/mtd/devices/doc2000.c	2006-01-27 15:08:36.000000000 +0100
@@ -138,7 +138,7 @@
    bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is
    required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
 
-static inline int DoC_Command(struct DiskOnChip *doc, unsigned char command,
+static int DoC_Command(struct DiskOnChip *doc, unsigned char command,
 			      unsigned char xtraflags)
 {
 	void __iomem *docptr = doc->virtadr;
diff -Nur linux-2.6.15.1/drivers/mtd/devices/doc2001.c linux-2.6.15.1-owrt/drivers/mtd/devices/doc2001.c
--- linux-2.6.15.1/drivers/mtd/devices/doc2001.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/mtd/devices/doc2001.c	2006-01-27 15:08:36.000000000 +0100
@@ -103,7 +103,7 @@
    with the internal pipeline. Each of 4 delay cycles (read from the NOP register) is
    required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
 
-static inline void DoC_Command(void __iomem * docptr, unsigned char command,
+static void DoC_Command(void __iomem * docptr, unsigned char command,
 			       unsigned char xtraflags)
 {
 	/* Assert the CLE (Command Latch Enable) line to the flash chip */
diff -Nur linux-2.6.15.1/drivers/mtd/devices/doc2001plus.c linux-2.6.15.1-owrt/drivers/mtd/devices/doc2001plus.c
--- linux-2.6.15.1/drivers/mtd/devices/doc2001plus.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/mtd/devices/doc2001plus.c	2006-01-27 15:08:36.000000000 +0100
@@ -118,7 +118,7 @@
 /* DoC_Command: Send a flash command to the flash chip through the Flash
  * command register. Need 2 Write Pipeline Terminates to complete send.
  */
-static inline void DoC_Command(void __iomem * docptr, unsigned char command,
+static void DoC_Command(void __iomem * docptr, unsigned char command,
 			       unsigned char xtraflags)
 {
 	WriteDOC(command, docptr, Mplus_FlashCmd);
diff -Nur linux-2.6.15.1/drivers/mtd/nand/diskonchip.c linux-2.6.15.1-owrt/drivers/mtd/nand/diskonchip.c
--- linux-2.6.15.1/drivers/mtd/nand/diskonchip.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/mtd/nand/diskonchip.c	2006-01-27 15:08:36.000000000 +0100
@@ -1506,7 +1506,7 @@
 	return 1;
 }
 
-static inline int __init doc_probe(unsigned long physadr)
+static int __init doc_probe(unsigned long physadr)
 {
 	unsigned char ChipID;
 	struct mtd_info *mtd;
diff -Nur linux-2.6.15.1/drivers/net/e100.c linux-2.6.15.1-owrt/drivers/net/e100.c
--- linux-2.6.15.1/drivers/net/e100.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/net/e100.c	2006-01-27 15:08:36.000000000 +0100
@@ -587,7 +587,7 @@
 	(void)readb(&nic->csr->scb.status);
 }
 
-static inline void e100_enable_irq(struct nic *nic)
+static void e100_enable_irq(struct nic *nic)
 {
 	unsigned long flags;
 
@@ -597,7 +597,7 @@
 	e100_write_flush(nic);
 }
 
-static inline void e100_disable_irq(struct nic *nic)
+static void e100_disable_irq(struct nic *nic)
 {
 	unsigned long flags;
 
@@ -786,7 +786,7 @@
 
 #define E100_WAIT_SCB_TIMEOUT 20000 /* we might have to wait 100ms!!! */
 #define E100_WAIT_SCB_FAST 20       /* delay like the old code */
-static inline int e100_exec_cmd(struct nic *nic, u8 cmd, dma_addr_t dma_addr)
+static int e100_exec_cmd(struct nic *nic, u8 cmd, dma_addr_t dma_addr)
 {
 	unsigned long flags;
 	unsigned int i;
@@ -817,7 +817,7 @@
 	return err;
 }
 
-static inline int e100_exec_cb(struct nic *nic, struct sk_buff *skb,
+static int e100_exec_cb(struct nic *nic, struct sk_buff *skb,
 	void (*cb_prepare)(struct nic *, struct cb *, struct sk_buff *))
 {
 	struct cb *cb;
@@ -1542,7 +1542,7 @@
 	mod_timer(&nic->watchdog, jiffies + E100_WATCHDOG_PERIOD);
 }
 
-static inline void e100_xmit_prepare(struct nic *nic, struct cb *cb,
+static void e100_xmit_prepare(struct nic *nic, struct cb *cb,
 	struct sk_buff *skb)
 {
 	cb->command = nic->tx_command;
@@ -1592,7 +1592,7 @@
 	return 0;
 }
 
-static inline int e100_tx_clean(struct nic *nic)
+static int e100_tx_clean(struct nic *nic)
 {
 	struct cb *cb;
 	int tx_cleaned = 0;
@@ -1703,7 +1703,7 @@
 }
 
 #define RFD_BUF_LEN (sizeof(struct rfd) + VLAN_ETH_FRAME_LEN)
-static inline int e100_rx_alloc_skb(struct nic *nic, struct rx *rx)
+static int e100_rx_alloc_skb(struct nic *nic, struct rx *rx)
 {
 	if(!(rx->skb = dev_alloc_skb(RFD_BUF_LEN + NET_IP_ALIGN)))
 		return -ENOMEM;
@@ -1737,7 +1737,7 @@
 	return 0;
 }
 
-static inline int e100_rx_indicate(struct nic *nic, struct rx *rx,
+static int e100_rx_indicate(struct nic *nic, struct rx *rx,
 	unsigned int *work_done, unsigned int work_to_do)
 {
 	struct sk_buff *skb = rx->skb;
@@ -1797,7 +1797,7 @@
 	return 0;
 }
 
-static inline void e100_rx_clean(struct nic *nic, unsigned int *work_done,
+static void e100_rx_clean(struct nic *nic, unsigned int *work_done,
 	unsigned int work_to_do)
 {
 	struct rx *rx;
diff -Nur linux-2.6.15.1/drivers/net/sb1000.c linux-2.6.15.1-owrt/drivers/net/sb1000.c
--- linux-2.6.15.1/drivers/net/sb1000.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/net/sb1000.c	2006-01-27 15:08:36.000000000 +0100
@@ -94,7 +94,7 @@
 	const char* name);
 static inline int card_wait_for_ready(const int ioaddr[], const char* name,
 	unsigned char in[]);
-static inline int card_send_command(const int ioaddr[], const char* name,
+static int card_send_command(const int ioaddr[], const char* name,
 	const unsigned char out[], unsigned char in[]);
 
 /* SB1000 hardware routines to be used during frame rx interrupt */
@@ -309,7 +309,7 @@
 }
 
 /* Card Send Command (cannot be used during an interrupt) */
-static inline int
+static int
 card_send_command(const int ioaddr[], const char* name,
 	const unsigned char out[], unsigned char in[])
 {
diff -Nur linux-2.6.15.1/drivers/net/wireless/hostap/hostap_80211_rx.c linux-2.6.15.1-owrt/drivers/net/wireless/hostap/hostap_80211_rx.c
--- linux-2.6.15.1/drivers/net/wireless/hostap/hostap_80211_rx.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/net/wireless/hostap/hostap_80211_rx.c	2006-01-27 15:08:36.000000000 +0100
@@ -435,7 +435,7 @@
 }
 
 
-static inline int
+static int
 hostap_rx_frame_mgmt(local_info_t *local, struct sk_buff *skb,
 		     struct hostap_80211_rx_status *rx_stats, u16 type,
 		     u16 stype)
@@ -499,7 +499,7 @@
 
 
 /* Called only as a tasklet (software IRQ) */
-static inline struct net_device *prism2_rx_get_wds(local_info_t *local,
+static struct net_device *prism2_rx_get_wds(local_info_t *local,
 						   u8 *addr)
 {
 	struct hostap_interface *iface = NULL;
@@ -519,7 +519,7 @@
 }
 
 
-static inline int
+static int
 hostap_rx_frame_wds(local_info_t *local, struct ieee80211_hdr_4addr *hdr,
 		    u16 fc, struct net_device **wds)
 {
@@ -615,7 +615,7 @@
 
 
 /* Called only as a tasklet (software IRQ) */
-static inline int
+static int
 hostap_rx_frame_decrypt(local_info_t *local, struct sk_buff *skb,
 			struct ieee80211_crypt_data *crypt)
 {
@@ -654,7 +654,7 @@
 
 
 /* Called only as a tasklet (software IRQ) */
-static inline int
+static int
 hostap_rx_frame_decrypt_msdu(local_info_t *local, struct sk_buff *skb,
 			     int keyidx, struct ieee80211_crypt_data *crypt)
 {
diff -Nur linux-2.6.15.1/drivers/net/wireless/hostap/hostap_hw.c linux-2.6.15.1-owrt/drivers/net/wireless/hostap/hostap_hw.c
--- linux-2.6.15.1/drivers/net/wireless/hostap/hostap_hw.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/net/wireless/hostap/hostap_hw.c	2006-01-27 15:08:36.000000000 +0100
@@ -253,7 +253,7 @@
  * @dev: pointer to net_device
  * @entry: Prism2 command queue entry to be issued
  */
-static inline int hfa384x_cmd_issue(struct net_device *dev,
+static int hfa384x_cmd_issue(struct net_device *dev,
 				    struct hostap_cmd_queue *entry)
 {
 	struct hostap_interface *iface;
@@ -743,7 +743,7 @@
 }
 
 
-static inline int hfa384x_wait_offset(struct net_device *dev, u16 o_off)
+static int hfa384x_wait_offset(struct net_device *dev, u16 o_off)
 {
 	int tries = HFA384X_BAP_BUSY_TIMEOUT;
 	int res = HFA384X_INW(o_off) & HFA384X_OFFSET_BUSY;
@@ -1904,7 +1904,7 @@
  * and will try to get the correct fid eventually. */
 #define EXTRA_FID_READ_TESTS
 
-static inline u16 prism2_read_fid_reg(struct net_device *dev, u16 reg)
+static u16 prism2_read_fid_reg(struct net_device *dev, u16 reg)
 {
 #ifdef EXTRA_FID_READ_TESTS
 	u16 val, val2, val3;
@@ -2581,7 +2581,7 @@
 
 
 /* Called only from hardware IRQ */
-static inline void prism2_check_magic(local_info_t *local)
+static void prism2_check_magic(local_info_t *local)
 {
 	/* at least PCI Prism2.5 with bus mastering seems to sometimes
 	 * return 0x0000 in SWSUPPORT0 for unknown reason, but re-reading the
diff -Nur linux-2.6.15.1/drivers/net/wireless/ipw2100.c linux-2.6.15.1-owrt/drivers/net/wireless/ipw2100.c
--- linux-2.6.15.1/drivers/net/wireless/ipw2100.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/net/wireless/ipw2100.c	2006-01-27 15:08:36.000000000 +0100
@@ -411,7 +411,7 @@
 	write_register(dev, IPW_REG_AUTOINCREMENT_DATA, val);
 }
 
-static inline void write_nic_memory(struct net_device *dev, u32 addr, u32 len,
+static void write_nic_memory(struct net_device *dev, u32 addr, u32 len,
 				    const u8 * buf)
 {
 	u32 aligned_addr;
@@ -449,7 +449,7 @@
 				    *buf);
 }
 
-static inline void read_nic_memory(struct net_device *dev, u32 addr, u32 len,
+static void read_nic_memory(struct net_device *dev, u32 addr, u32 len,
 				   u8 * buf)
 {
 	u32 aligned_addr;
@@ -657,7 +657,7 @@
 
 #define MAX_RESET_BACKOFF 10
 
-static inline void schedule_reset(struct ipw2100_priv *priv)
+static void schedule_reset(struct ipw2100_priv *priv)
 {
 	unsigned long now = get_seconds();
 
@@ -1130,7 +1130,7 @@
 	write_register(priv->net_dev, IPW_REG_GPIO, reg);
 }
 
-static inline int rf_kill_active(struct ipw2100_priv *priv)
+static int rf_kill_active(struct ipw2100_priv *priv)
 {
 #define MAX_RF_KILL_CHECKS 5
 #define RF_KILL_CHECK_DELAY 40
@@ -2177,7 +2177,7 @@
 };
 #endif
 
-static inline int ipw2100_alloc_skb(struct ipw2100_priv *priv,
+static int ipw2100_alloc_skb(struct ipw2100_priv *priv,
 				    struct ipw2100_rx_packet *packet)
 {
 	packet->skb = dev_alloc_skb(sizeof(struct ipw2100_rx));
@@ -2201,7 +2201,7 @@
 #define SEARCH_SNAPSHOT 1
 
 #define SNAPSHOT_ADDR(ofs) (priv->snapshot[((ofs) >> 12) & 0xff] + ((ofs) & 0xfff))
-static inline int ipw2100_snapshot_alloc(struct ipw2100_priv *priv)
+static int ipw2100_snapshot_alloc(struct ipw2100_priv *priv)
 {
 	int i;
 	if (priv->snapshot[0])
@@ -2221,7 +2221,7 @@
 	return 1;
 }
 
-static inline void ipw2100_snapshot_free(struct ipw2100_priv *priv)
+static void ipw2100_snapshot_free(struct ipw2100_priv *priv)
 {
 	int i;
 	if (!priv->snapshot[0])
@@ -2231,7 +2231,7 @@
 	priv->snapshot[0] = NULL;
 }
 
-static inline u32 ipw2100_match_buf(struct ipw2100_priv *priv, u8 * in_buf,
+static u32 ipw2100_match_buf(struct ipw2100_priv *priv, u8 * in_buf,
 				    size_t len, int mode)
 {
 	u32 i, j;
@@ -2288,7 +2288,7 @@
 static u8 packet_data[IPW_RX_NIC_BUFFER_LENGTH];
 #endif
 
-static inline void ipw2100_corruption_detected(struct ipw2100_priv *priv, int i)
+static void ipw2100_corruption_detected(struct ipw2100_priv *priv, int i)
 {
 #ifdef CONFIG_IPW_DEBUG_C3
 	struct ipw2100_status *status = &priv->status_queue.drv[i];
@@ -2346,7 +2346,7 @@
 	schedule_reset(priv);
 }
 
-static inline void isr_rx(struct ipw2100_priv *priv, int i,
+static void isr_rx(struct ipw2100_priv *priv, int i,
 			  struct ieee80211_rx_stats *stats)
 {
 	struct ipw2100_status *status = &priv->status_queue.drv[i];
@@ -2425,7 +2425,7 @@
 	priv->rx_queue.drv[i].host_addr = packet->dma_addr;
 }
 
-static inline int ipw2100_corruption_check(struct ipw2100_priv *priv, int i)
+static int ipw2100_corruption_check(struct ipw2100_priv *priv, int i)
 {
 	struct ipw2100_status *status = &priv->status_queue.drv[i];
 	struct ipw2100_rx *u = priv->rx_buffers[i].rxp;
@@ -2481,7 +2481,7 @@
  * The WRITE index is cached in the variable 'priv->rx_queue.next'.
  *
  */
-static inline void __ipw2100_rx_process(struct ipw2100_priv *priv)
+static void __ipw2100_rx_process(struct ipw2100_priv *priv)
 {
 	struct ipw2100_bd_queue *rxq = &priv->rx_queue;
 	struct ipw2100_status_queue *sq = &priv->status_queue;
@@ -2634,7 +2634,7 @@
  * for use by future command and data packets.
  *
  */
-static inline int __ipw2100_tx_process(struct ipw2100_priv *priv)
+static int __ipw2100_tx_process(struct ipw2100_priv *priv)
 {
 	struct ipw2100_bd_queue *txq = &priv->tx_queue;
 	struct ipw2100_bd *tbd;
diff -Nur linux-2.6.15.1/drivers/net/wireless/ipw2200.c linux-2.6.15.1-owrt/drivers/net/wireless/ipw2200.c
--- linux-2.6.15.1/drivers/net/wireless/ipw2200.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/net/wireless/ipw2200.c	2006-01-27 15:08:36.000000000 +0100
@@ -813,7 +813,7 @@
 	up(&priv->sem);
 }
 
-static inline void __ipw_led_activity_on(struct ipw_priv *priv)
+static void __ipw_led_activity_on(struct ipw_priv *priv)
 {
 	u32 led;
 
@@ -1508,7 +1508,7 @@
 static DEVICE_ATTR(direct_dword, S_IWUSR | S_IRUGO,
 		   show_direct_dword, store_direct_dword);
 
-static inline int rf_kill_active(struct ipw_priv *priv)
+static int rf_kill_active(struct ipw_priv *priv)
 {
 	if (0 == (ipw_read32(priv, 0x30) & 0x10000))
 		priv->status |= STATUS_RF_KILL_HW;
@@ -2359,7 +2359,7 @@
 }
 
 /* perform a chip select operation */
-static inline void eeprom_cs(struct ipw_priv *priv)
+static void eeprom_cs(struct ipw_priv *priv)
 {
 	eeprom_write_reg(priv, 0);
 	eeprom_write_reg(priv, EEPROM_BIT_CS);
@@ -2368,7 +2368,7 @@
 }
 
 /* perform a chip select operation */
-static inline void eeprom_disable_cs(struct ipw_priv *priv)
+static void eeprom_disable_cs(struct ipw_priv *priv)
 {
 	eeprom_write_reg(priv, EEPROM_BIT_CS);
 	eeprom_write_reg(priv, 0);
@@ -2475,7 +2475,7 @@
 	IPW_DEBUG_TRACE("<<\n");
 }
 
-static inline void ipw_zero_memory(struct ipw_priv *priv, u32 start, u32 count)
+static void ipw_zero_memory(struct ipw_priv *priv, u32 start, u32 count)
 {
 	count >>= 2;
 	if (!count)
@@ -2772,7 +2772,7 @@
 	return ipw_read32(priv, 0x90) == 0xd55555d5;
 }
 
-static inline int ipw_poll_bit(struct ipw_priv *priv, u32 addr, u32 mask,
+static int ipw_poll_bit(struct ipw_priv *priv, u32 addr, u32 mask,
 			       int timeout)
 {
 	int i = 0;
@@ -3150,7 +3150,7 @@
 
 #define IPW_RX_BUF_SIZE (3000)
 
-static inline void ipw_rx_queue_reset(struct ipw_priv *priv,
+static void ipw_rx_queue_reset(struct ipw_priv *priv,
 				      struct ipw_rx_queue *rxq)
 {
 	unsigned long flags;
@@ -3608,7 +3608,7 @@
 	ipw_queue_tx_free(priv, &priv->txq[3]);
 }
 
-static inline void ipw_create_bssid(struct ipw_priv *priv, u8 * bssid)
+static void ipw_create_bssid(struct ipw_priv *priv, u8 * bssid)
 {
 	/* First 3 bytes are manufacturer */
 	bssid[0] = priv->mac_addr[0];
@@ -3622,7 +3622,7 @@
 	bssid[0] |= 0x02;	/* set local assignment bit (IEEE802) */
 }
 
-static inline u8 ipw_add_station(struct ipw_priv *priv, u8 * bssid)
+static u8 ipw_add_station(struct ipw_priv *priv, u8 * bssid)
 {
 	struct ipw_station_entry entry;
 	int i;
@@ -3655,7 +3655,7 @@
 	return i;
 }
 
-static inline u8 ipw_find_station(struct ipw_priv *priv, u8 * bssid)
+static u8 ipw_find_station(struct ipw_priv *priv, u8 * bssid)
 {
 	int i;
 
@@ -3794,7 +3794,7 @@
 	memset(avg, 0, sizeof(*avg));
 }
 
-static void inline average_add(struct average *avg, s16 val)
+static void average_add(struct average *avg, s16 val)
 {
 	avg->sum -= avg->entries[avg->pos];
 	avg->sum += val;
@@ -3805,7 +3805,7 @@
 	}
 }
 
-static s16 inline average_value(struct average *avg)
+static s16 average_value(struct average *avg)
 {
 	if (!unlikely(avg->init)) {
 		if (avg->pos)
@@ -3847,7 +3847,7 @@
 
 }
 
-static inline u32 ipw_get_max_rate(struct ipw_priv *priv)
+static u32 ipw_get_max_rate(struct ipw_priv *priv)
 {
 	u32 i = 0x80000000;
 	u32 mask = priv->rates_mask;
@@ -4087,7 +4087,7 @@
  * roaming_threshold -> disassociate_threshold, scan and roam for better signal.
  * Above disassociate threshold, give up and stop scanning.
  * Roaming is disabled if disassociate_threshold <= roaming_threshold  */
-static inline void ipw_handle_missed_beacon(struct ipw_priv *priv,
+static void ipw_handle_missed_beacon(struct ipw_priv *priv,
 					    int missed_count)
 {
 	priv->notif_missed_beacons = missed_count;
@@ -4157,7 +4157,7 @@
  * Handle host notification packet.
  * Called from interrupt routine
  */
-static inline void ipw_rx_notification(struct ipw_priv *priv,
+static void ipw_rx_notification(struct ipw_priv *priv,
 				       struct ipw_rx_notification *notif)
 {
 	notif->size = le16_to_cpu(notif->size);
@@ -5096,7 +5096,7 @@
 	return 1;
 }
 
-static inline void ipw_copy_rates(struct ipw_supported_rates *dest,
+static void ipw_copy_rates(struct ipw_supported_rates *dest,
 				  const struct ipw_supported_rates *src)
 {
 	u8 i;
@@ -5857,7 +5857,7 @@
 #define ipw_debug_config(x) do {} while (0)
 #endif
 
-static inline void ipw_set_fixed_rate(struct ipw_priv *priv, int mode)
+static void ipw_set_fixed_rate(struct ipw_priv *priv, int mode)
 {
 	/* TODO: Verify that this works... */
 	struct ipw_fixed_rate fr = {
@@ -7636,7 +7636,7 @@
 }
 #endif
 
-static inline int is_network_packet(struct ipw_priv *priv,
+static int is_network_packet(struct ipw_priv *priv,
 				    struct ieee80211_hdr_4addr *header)
 {
 	/* Filter incoming packets to determine if they are targetted toward
@@ -7676,7 +7676,7 @@
 
 #define IPW_PACKET_RETRY_TIME HZ
 
-static inline int is_duplicate_packet(struct ipw_priv *priv,
+static  int is_duplicate_packet(struct ipw_priv *priv,
 				      struct ieee80211_hdr_4addr *header)
 {
 	u16 sc = le16_to_cpu(header->seq_ctl);
@@ -9585,7 +9585,7 @@
 
 /* net device stuff */
 
-static inline void init_sys_config(struct ipw_sys_config *sys_config)
+static  void init_sys_config(struct ipw_sys_config *sys_config)
 {
 	memset(sys_config, 0, sizeof(struct ipw_sys_config));
 	sys_config->bt_coexistence = 1;	/* We may need to look into prvStaBtConfig */
@@ -9631,7 +9631,7 @@
 we need to heavily modify the ieee80211_skb_to_txb.
 */
 
-static inline int ipw_tx_skb(struct ipw_priv *priv, struct ieee80211_txb *txb,
+static int ipw_tx_skb(struct ipw_priv *priv, struct ieee80211_txb *txb,
 			     int pri)
 {
 	struct ieee80211_hdr_3addr *hdr = (struct ieee80211_hdr_3addr *)
diff -Nur linux-2.6.15.1/drivers/net/wireless/wavelan.c linux-2.6.15.1-owrt/drivers/net/wireless/wavelan.c
--- linux-2.6.15.1/drivers/net/wireless/wavelan.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/net/wireless/wavelan.c	2006-01-27 15:08:36.000000000 +0100
@@ -102,7 +102,7 @@
  * Write to card's Host Adapter Command Register. Include a delay for
  * those times when it is needed.
  */
-static inline void hacr_write_slow(unsigned long ioaddr, u16 hacr)
+static void hacr_write_slow(unsigned long ioaddr, u16 hacr)
 {
 	hacr_write(ioaddr, hacr);
 	/* delay might only be needed sometimes */
@@ -242,7 +242,7 @@
  * The Windows drivers don't use the CRC, but the AP and the PtP tool
  * depend on it.
  */
-static inline u16 psa_crc(u8 * psa,	/* The PSA */
+static u16 psa_crc(u8 * psa,	/* The PSA */
 			      int size)
 {				/* Number of short for CRC */
 	int byte_cnt;		/* Loop on the PSA */
@@ -310,7 +310,7 @@
 /*
  * Write 1 byte to the MMC.
  */
-static inline void mmc_out(unsigned long ioaddr, u16 o, u8 d)
+static void mmc_out(unsigned long ioaddr, u16 o, u8 d)
 {
 	int count = 0;
 
@@ -326,7 +326,7 @@
  * Routine to write bytes to the Modem Management Controller.
  * We start at the end because it is the way it should be!
  */
-static inline void mmc_write(unsigned long ioaddr, u8 o, u8 * b, int n)
+static void mmc_write(unsigned long ioaddr, u8 o, u8 * b, int n)
 {
 	o += n;
 	b += n;
@@ -340,7 +340,7 @@
  * Read a byte from the MMC.
  * Optimised version for 1 byte, avoid using memory.
  */
-static inline u8 mmc_in(unsigned long ioaddr, u16 o)
+static u8 mmc_in(unsigned long ioaddr, u16 o)
 {
 	int count = 0;
 
@@ -587,7 +587,7 @@
  * Set channel attention bit and busy wait until command has
  * completed, then acknowledge completion of the command.
  */
-static inline int wv_synchronous_cmd(struct net_device * dev, const char *str)
+static int wv_synchronous_cmd(struct net_device * dev, const char *str)
 {
 	net_local *lp = (net_local *) dev->priv;
 	unsigned long ioaddr = dev->base_addr;
@@ -633,7 +633,7 @@
  * Configuration commands completion interrupt.
  * Check if done, and if OK.
  */
-static inline int
+static int
 wv_config_complete(struct net_device * dev, unsigned long ioaddr, net_local * lp)
 {
 	unsigned short mcs_addr;
@@ -843,7 +843,7 @@
  * wavelan_interrupt is not an option), so you may experience
  * delays sometimes.
  */
-static inline void wv_82586_reconfig(struct net_device * dev)
+static void wv_82586_reconfig(struct net_device * dev)
 {
 	net_local *lp = (net_local *) dev->priv;
 	unsigned long flags;
@@ -1281,7 +1281,7 @@
  * This is the information which is displayed by the driver at startup.
  * There are lots of flags for configuring it to your liking.
  */
-static inline void wv_init_info(struct net_device * dev)
+static void wv_init_info(struct net_device * dev)
 {
 	short ioaddr = dev->base_addr;
 	net_local *lp = (net_local *) dev->priv;
@@ -1502,7 +1502,7 @@
  * It's a bit complicated and you don't really want to look into it.
  * (called in wavelan_ioctl)
  */
-static inline int wv_set_frequency(unsigned long ioaddr,	/* I/O port of the card */
+static int wv_set_frequency(unsigned long ioaddr,	/* I/O port of the card */
 				   iw_freq * frequency)
 {
 	const int BAND_NUM = 10;	/* Number of bands */
@@ -1677,7 +1677,7 @@
 /*
  * Give the list of available frequencies.
  */
-static inline int wv_frequency_list(unsigned long ioaddr,	/* I/O port of the card */
+static int wv_frequency_list(unsigned long ioaddr,	/* I/O port of the card */
 				    iw_freq * list,	/* List of frequencies to fill */
 				    int max)
 {				/* Maximum number of frequencies */
@@ -2489,7 +2489,7 @@
  * Note: if any errors occur, the packet is "dropped on the floor".
  * (called by wv_packet_rcv())
  */
-static inline void
+static void
 wv_packet_read(struct net_device * dev, u16 buf_off, int sksize)
 {
 	net_local *lp = (net_local *) dev->priv;
@@ -2585,7 +2585,7 @@
  * (called in wavelan_interrupt()).
  * Note : the spinlock is already grabbed for us.
  */
-static inline void wv_receive(struct net_device * dev)
+static void wv_receive(struct net_device * dev)
 {
 	unsigned long ioaddr = dev->base_addr;
 	net_local *lp = (net_local *) dev->priv;
@@ -2768,7 +2768,7 @@
  *
  * (called in wavelan_packet_xmit())
  */
-static inline int wv_packet_write(struct net_device * dev, void *buf, short length)
+static int wv_packet_write(struct net_device * dev, void *buf, short length)
 {
 	net_local *lp = (net_local *) dev->priv;
 	unsigned long ioaddr = dev->base_addr;
@@ -2964,7 +2964,7 @@
  * Routine to initialize the Modem Management Controller.
  * (called by wv_hw_reset())
  */
-static inline int wv_mmc_init(struct net_device * dev)
+static int wv_mmc_init(struct net_device * dev)
 {
 	unsigned long ioaddr = dev->base_addr;
 	net_local *lp = (net_local *) dev->priv;
@@ -3136,7 +3136,7 @@
  * Start the receive unit.
  * (called by wv_hw_reset())
  */
-static inline int wv_ru_start(struct net_device * dev)
+static int wv_ru_start(struct net_device * dev)
 {
 	net_local *lp = (net_local *) dev->priv;
 	unsigned long ioaddr = dev->base_addr;
@@ -3228,7 +3228,7 @@
  *
  * (called by wv_hw_reset())
  */
-static inline int wv_cu_start(struct net_device * dev)
+static int wv_cu_start(struct net_device * dev)
 {
 	net_local *lp = (net_local *) dev->priv;
 	unsigned long ioaddr = dev->base_addr;
@@ -3329,7 +3329,7 @@
  *
  * (called by wv_hw_reset())
  */
-static inline int wv_82586_start(struct net_device * dev)
+static int wv_82586_start(struct net_device * dev)
 {
 	net_local *lp = (net_local *) dev->priv;
 	unsigned long ioaddr = dev->base_addr;
@@ -3641,7 +3641,7 @@
  * WaveLAN controller (i82586).
  * (called by wavelan_close())
  */
-static inline void wv_82586_stop(struct net_device * dev)
+static void wv_82586_stop(struct net_device * dev)
 {
 	net_local *lp = (net_local *) dev->priv;
 	unsigned long ioaddr = dev->base_addr;
diff -Nur linux-2.6.15.1/drivers/scsi/aic7xxx_old.c linux-2.6.15.1-owrt/drivers/scsi/aic7xxx_old.c
--- linux-2.6.15.1/drivers/scsi/aic7xxx_old.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/scsi/aic7xxx_old.c	2006-01-27 15:08:36.000000000 +0100
@@ -1290,7 +1290,7 @@
  *
  ***************************************************************************/
 
-static inline unsigned char
+static unsigned char
 aic_inb(struct aic7xxx_host *p, long port)
 {
 #ifdef MMAPIO
@@ -1309,7 +1309,7 @@
 #endif
 }
 
-static inline void
+static void
 aic_outb(struct aic7xxx_host *p, unsigned char val, long port)
 {
 #ifdef MMAPIO
diff -Nur linux-2.6.15.1/drivers/scsi/iscsi_tcp.c linux-2.6.15.1-owrt/drivers/scsi/iscsi_tcp.c
--- linux-2.6.15.1/drivers/scsi/iscsi_tcp.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/scsi/iscsi_tcp.c	2006-01-27 15:08:36.000000000 +0100
@@ -1437,7 +1437,7 @@
 	}
 }
 
-static inline int
+static int
 iscsi_digest_final_send(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 			struct iscsi_buf *buf, uint32_t *digest, int final)
 {
diff -Nur linux-2.6.15.1/drivers/scsi/libata-core.c linux-2.6.15.1-owrt/drivers/scsi/libata-core.c
--- linux-2.6.15.1/drivers/scsi/libata-core.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/scsi/libata-core.c	2006-01-27 15:08:36.000000000 +0100
@@ -1660,7 +1660,7 @@
 	{ ATA_SHIFT_PIO,	XFER_PIO_0 },
 };
 
-static inline u8 base_from_shift(unsigned int shift)
+static u8 base_from_shift(unsigned int shift)
 {
 	int i;
 
diff -Nur linux-2.6.15.1/drivers/scsi/megaraid/megaraid_mbox.c linux-2.6.15.1-owrt/drivers/scsi/megaraid/megaraid_mbox.c
--- linux-2.6.15.1/drivers/scsi/megaraid/megaraid_mbox.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/scsi/megaraid/megaraid_mbox.c	2006-01-27 15:08:36.000000000 +0100
@@ -1331,7 +1331,7 @@
  * return the scb from the head of the free list. NULL if there are none
  * available
  **/
-static inline scb_t *
+static scb_t *
 megaraid_alloc_scb(adapter_t *adapter, struct scsi_cmnd *scp)
 {
 	struct list_head	*head = &adapter->kscb_pool;
@@ -1394,7 +1394,7 @@
  *
  * prepare the scatter-gather list
  */
-static inline int
+static int
 megaraid_mbox_mksgl(adapter_t *adapter, scb_t *scb)
 {
 	struct scatterlist	*sgl;
@@ -1467,7 +1467,7 @@
  *
  * post the command to the controller if mailbox is availble.
  */
-static inline int
+static int
 mbox_post_cmd(adapter_t *adapter, scb_t *scb)
 {
 	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
@@ -2135,7 +2135,7 @@
  *
  * Returns:	1 if the interrupt is valid, 0 otherwise
  */
-static inline int
+static int
 megaraid_ack_sequence(adapter_t *adapter)
 {
 	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
@@ -2273,7 +2273,7 @@
  *
  * DMA sync if required.
  */
-static inline void
+static void
 megaraid_mbox_sync_scb(adapter_t *adapter, scb_t *scb)
 {
 	mbox_ccb_t	*ccb;
diff -Nur linux-2.6.15.1/drivers/scsi/megaraid/megaraid_sas.c linux-2.6.15.1-owrt/drivers/scsi/megaraid/megaraid_sas.c
--- linux-2.6.15.1/drivers/scsi/megaraid/megaraid_sas.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/scsi/megaraid/megaraid_sas.c	2006-01-27 15:08:36.000000000 +0100
@@ -80,7 +80,7 @@
  *
  * Returns a free command from the pool
  */
-static inline struct megasas_cmd *megasas_get_cmd(struct megasas_instance
+static struct megasas_cmd *megasas_get_cmd(struct megasas_instance
 						  *instance)
 {
 	unsigned long flags;
@@ -262,7 +262,7 @@
  * If successful, this function returns the number of SG elements. Otherwise,
  * it returnes -1.
  */
-static inline int
+static int
 megasas_make_sgl32(struct megasas_instance *instance, struct scsi_cmnd *scp,
 		   union megasas_sgl *mfi_sgl)
 {
@@ -310,7 +310,7 @@
  * If successful, this function returns the number of SG elements. Otherwise,
  * it returnes -1.
  */
-static inline int
+static int
 megasas_make_sgl64(struct megasas_instance *instance, struct scsi_cmnd *scp,
 		   union megasas_sgl *mfi_sgl)
 {
@@ -359,7 +359,7 @@
  * This function prepares CDB commands. These are typcially pass-through
  * commands to the devices.
  */
-static inline int
+static int
 megasas_build_dcdb(struct megasas_instance *instance, struct scsi_cmnd *scp,
 		   struct megasas_cmd *cmd)
 {
@@ -440,7 +440,7 @@
  *
  * Frames (and accompanying SGLs) for regular SCSI IOs use this function.
  */
-static inline int
+static int
 megasas_build_ldio(struct megasas_instance *instance, struct scsi_cmnd *scp,
 		   struct megasas_cmd *cmd)
 {
@@ -562,7 +562,7 @@
  * @scp:		SCSI command
  * @frame_count:	[OUT] Number of frames used to prepare this command
  */
-static inline struct megasas_cmd *megasas_build_cmd(struct megasas_instance
+static struct megasas_cmd *megasas_build_cmd(struct megasas_instance
 						    *instance,
 						    struct scsi_cmnd *scp,
 						    int *frame_count)
@@ -913,7 +913,7 @@
  * @instance:			Adapter soft state
  * @cmd:			Completed command
  */
-static inline void
+static void
 megasas_unmap_sgbuf(struct megasas_instance *instance, struct megasas_cmd *cmd)
 {
 	dma_addr_t buf_h;
@@ -957,7 +957,7 @@
  * 				an alternate status (as in the case of aborted
  * 				commands)
  */
-static inline void
+static void
 megasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,
 		     u8 alt_status)
 {
@@ -1104,7 +1104,7 @@
  * 					SCSI mid-layer instead of the status
  * 					returned by the FW
  */
-static inline int
+static int
 megasas_deplete_reply_queue(struct megasas_instance *instance, u8 alt_status)
 {
 	u32 status;
diff -Nur linux-2.6.15.1/drivers/scsi/sr.c linux-2.6.15.1-owrt/drivers/scsi/sr.c
--- linux-2.6.15.1/drivers/scsi/sr.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/scsi/sr.c	2006-01-27 15:08:36.000000000 +0100
@@ -150,7 +150,7 @@
 	return cd;
 }
 
-static inline void scsi_cd_put(struct scsi_cd *cd)
+static void scsi_cd_put(struct scsi_cd *cd)
 {
 	struct scsi_device *sdev = cd->device;
 
diff -Nur linux-2.6.15.1/drivers/usb/atm/usbatm.c linux-2.6.15.1-owrt/drivers/usb/atm/usbatm.c
--- linux-2.6.15.1/drivers/usb/atm/usbatm.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/usb/atm/usbatm.c	2006-01-27 15:08:36.000000000 +0100
@@ -207,7 +207,7 @@
 **  urbs  **
 ************/
 
-static inline struct urb *usbatm_pop_urb(struct usbatm_channel *channel)
+static struct urb *usbatm_pop_urb(struct usbatm_channel *channel)
 {
 	struct urb *urb;
 
@@ -224,7 +224,7 @@
 	return urb;
 }
 
-static inline int usbatm_submit_urb(struct urb *urb)
+static int usbatm_submit_urb(struct urb *urb)
 {
 	struct usbatm_channel *channel = urb->context;
 	int ret;
diff -Nur linux-2.6.15.1/drivers/video/matrox/matroxfb_maven.c linux-2.6.15.1-owrt/drivers/video/matrox/matroxfb_maven.c
--- linux-2.6.15.1/drivers/video/matrox/matroxfb_maven.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/drivers/video/matrox/matroxfb_maven.c	2006-01-27 15:08:36.000000000 +0100
@@ -968,7 +968,7 @@
 	return 0;
 }
 
-static inline int maven_program_timming(struct maven_data* md,
+static int maven_program_timming(struct maven_data* md,
 		const struct mavenregs* m) {
 	struct i2c_client* c = md->client;
 
diff -Nur linux-2.6.15.1/fs/9p/conv.c linux-2.6.15.1-owrt/fs/9p/conv.c
--- linux-2.6.15.1/fs/9p/conv.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/9p/conv.c	2006-01-27 15:08:36.000000000 +0100
@@ -56,7 +56,7 @@
 	return buf->p > buf->ep;
 }
 
-static inline int buf_check_size(struct cbuf *buf, int len)
+static int buf_check_size(struct cbuf *buf, int len)
 {
 	if (buf->p+len > buf->ep) {
 		if (buf->p < buf->ep) {
@@ -69,7 +69,7 @@
 	return 1;
 }
 
-static inline void *buf_alloc(struct cbuf *buf, int len)
+static void *buf_alloc(struct cbuf *buf, int len)
 {
 	void *ret = NULL;
 
@@ -81,7 +81,7 @@
 	return ret;
 }
 
-static inline void buf_put_int8(struct cbuf *buf, u8 val)
+static void buf_put_int8(struct cbuf *buf, u8 val)
 {
 	if (buf_check_size(buf, 1)) {
 		buf->p[0] = val;
@@ -89,7 +89,7 @@
 	}
 }
 
-static inline void buf_put_int16(struct cbuf *buf, u16 val)
+static void buf_put_int16(struct cbuf *buf, u16 val)
 {
 	if (buf_check_size(buf, 2)) {
 		*(__le16 *) buf->p = cpu_to_le16(val);
@@ -97,7 +97,7 @@
 	}
 }
 
-static inline void buf_put_int32(struct cbuf *buf, u32 val)
+static void buf_put_int32(struct cbuf *buf, u32 val)
 {
 	if (buf_check_size(buf, 4)) {
 		*(__le32 *)buf->p = cpu_to_le32(val);
@@ -105,7 +105,7 @@
 	}
 }
 
-static inline void buf_put_int64(struct cbuf *buf, u64 val)
+static void buf_put_int64(struct cbuf *buf, u64 val)
 {
 	if (buf_check_size(buf, 8)) {
 		*(__le64 *)buf->p = cpu_to_le64(val);
@@ -113,7 +113,7 @@
 	}
 }
 
-static inline void buf_put_stringn(struct cbuf *buf, const char *s, u16 slen)
+static void buf_put_stringn(struct cbuf *buf, const char *s, u16 slen)
 {
 	if (buf_check_size(buf, slen + 2)) {
 		buf_put_int16(buf, slen);
@@ -135,7 +135,7 @@
 	}
 }
 
-static inline u8 buf_get_int8(struct cbuf *buf)
+static u8 buf_get_int8(struct cbuf *buf)
 {
 	u8 ret = 0;
 
@@ -147,7 +147,7 @@
 	return ret;
 }
 
-static inline u16 buf_get_int16(struct cbuf *buf)
+static u16 buf_get_int16(struct cbuf *buf)
 {
 	u16 ret = 0;
 
@@ -159,7 +159,7 @@
 	return ret;
 }
 
-static inline u32 buf_get_int32(struct cbuf *buf)
+static u32 buf_get_int32(struct cbuf *buf)
 {
 	u32 ret = 0;
 
@@ -171,7 +171,7 @@
 	return ret;
 }
 
-static inline u64 buf_get_int64(struct cbuf *buf)
+static u64 buf_get_int64(struct cbuf *buf)
 {
 	u64 ret = 0;
 
diff -Nur linux-2.6.15.1/fs/binfmt_elf.c linux-2.6.15.1-owrt/fs/binfmt_elf.c
--- linux-2.6.15.1/fs/binfmt_elf.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/binfmt_elf.c	2006-01-27 15:08:36.000000000 +0100
@@ -1212,7 +1212,7 @@
 	if (!dump_seek(file, (off))) \
 		goto end_coredump;
 
-static inline void fill_elf_header(struct elfhdr *elf, int segs)
+static void fill_elf_header(struct elfhdr *elf, int segs)
 {
 	memcpy(elf->e_ident, ELFMAG, SELFMAG);
 	elf->e_ident[EI_CLASS] = ELF_CLASS;
@@ -1237,7 +1237,7 @@
 	return;
 }
 
-static inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, off_t offset)
+static void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, off_t offset)
 {
 	phdr->p_type = PT_NOTE;
 	phdr->p_offset = offset;
diff -Nur linux-2.6.15.1/fs/binfmt_misc.c linux-2.6.15.1-owrt/fs/binfmt_misc.c
--- linux-2.6.15.1/fs/binfmt_misc.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/binfmt_misc.c	2006-01-27 15:08:36.000000000 +0100
@@ -264,7 +264,7 @@
 	return p - from;
 }
 
-static inline char * check_special_flags (char * sfs, Node * e)
+static char * check_special_flags (char * sfs, Node * e)
 {
 	char * p = sfs;
 	int cont = 1;
diff -Nur linux-2.6.15.1/fs/bio.c linux-2.6.15.1-owrt/fs/bio.c
--- linux-2.6.15.1/fs/bio.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/bio.c	2006-01-27 15:08:36.000000000 +0100
@@ -123,7 +123,7 @@
 	bio_free(bio, fs_bio_set);
 }
 
-inline void bio_init(struct bio *bio)
+void bio_init(struct bio *bio)
 {
 	bio->bi_next = NULL;
 	bio->bi_flags = 1 << BIO_UPTODATE;
@@ -252,7 +252,7 @@
  *	the actual data it points to. Reference count of returned
  * 	bio will be one.
  */
-inline void __bio_clone(struct bio *bio, struct bio *bio_src)
+void __bio_clone(struct bio *bio, struct bio *bio_src)
 {
 	request_queue_t *q = bdev_get_queue(bio_src->bi_bdev);
 
diff -Nur linux-2.6.15.1/fs/buffer.c linux-2.6.15.1-owrt/fs/buffer.c
--- linux-2.6.15.1/fs/buffer.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/buffer.c	2006-01-27 15:08:36.000000000 +0100
@@ -1170,7 +1170,7 @@
  * some of those buffers may be aliases of filesystem data.
  * grow_dev_page() will go BUG() if this happens.
  */
-static inline int
+static int
 grow_buffers(struct block_device *bdev, sector_t block, int size)
 {
 	struct page *page;
@@ -1396,7 +1396,7 @@
 /*
  * Look up the bh in this cpu's LRU.  If it's there, move it to the head.
  */
-static inline struct buffer_head *
+static struct buffer_head *
 lookup_bh_lru(struct block_device *bdev, sector_t block, int size)
 {
 	struct buffer_head *ret = NULL;
@@ -1546,7 +1546,7 @@
 /*
  * Called when truncating a buffer on a page completely.
  */
-static inline void discard_buffer(struct buffer_head * bh)
+static void discard_buffer(struct buffer_head * bh)
 {
 	lock_buffer(bh);
 	clear_buffer_dirty(bh);
diff -Nur linux-2.6.15.1/fs/compat.c linux-2.6.15.1-owrt/fs/compat.c
--- linux-2.6.15.1/fs/compat.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/compat.c	2006-01-27 15:08:36.000000000 +0100
@@ -1523,7 +1523,7 @@
  * Ooo, nasty.  We need here to frob 32-bit unsigned longs to
  * 64-bit unsigned longs.
  */
-static inline
+static
 int compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,
 			unsigned long *fdset)
 {
@@ -1556,7 +1556,7 @@
 	return 0;
 }
 
-static inline
+static
 void compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,
 			unsigned long *fdset)
 {
diff -Nur linux-2.6.15.1/fs/dcache.c linux-2.6.15.1-owrt/fs/dcache.c
--- linux-2.6.15.1/fs/dcache.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/dcache.c	2006-01-27 15:08:36.000000000 +0100
@@ -94,7 +94,7 @@
  * d_iput() operation if defined.
  * Called with dcache_lock and per dentry lock held, drops both.
  */
-static inline void dentry_iput(struct dentry * dentry)
+static void dentry_iput(struct dentry * dentry)
 {
 	struct inode *inode = dentry->d_inode;
 	if (inode) {
diff -Nur linux-2.6.15.1/fs/exec.c linux-2.6.15.1-owrt/fs/exec.c
--- linux-2.6.15.1/fs/exec.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/exec.c	2006-01-27 15:08:36.000000000 +0100
@@ -575,7 +575,7 @@
  * disturbing other processes.  (Other processes might share the signal
  * table via the CLONE_SIGHAND option to clone().)
  */
-static inline int de_thread(struct task_struct *tsk)
+static int de_thread(struct task_struct *tsk)
 {
 	struct signal_struct *sig = tsk->signal;
 	struct sighand_struct *newsighand, *oldsighand = tsk->sighand;
@@ -780,7 +780,7 @@
  * so that a new one can be started
  */
 
-static inline void flush_old_files(struct files_struct * files)
+static void flush_old_files(struct files_struct * files)
 {
 	long j = -1;
 	struct fdtable *fdt;
@@ -964,7 +964,7 @@
 
 EXPORT_SYMBOL(prepare_binprm);
 
-static inline int unsafe_exec(struct task_struct *p)
+static int unsafe_exec(struct task_struct *p)
 {
 	int unsafe = 0;
 	if (p->ptrace & PT_PTRACED) {
diff -Nur linux-2.6.15.1/fs/fcntl.c linux-2.6.15.1-owrt/fs/fcntl.c
--- linux-2.6.15.1/fs/fcntl.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/fcntl.c	2006-01-27 15:08:36.000000000 +0100
@@ -35,7 +35,7 @@
 	spin_unlock(&files->file_lock);
 }
 
-static inline int get_close_on_exec(unsigned int fd)
+static int get_close_on_exec(unsigned int fd)
 {
 	struct files_struct *files = current->files;
 	struct fdtable *fdt;
diff -Nur linux-2.6.15.1/fs/inode.c linux-2.6.15.1-owrt/fs/inode.c
--- linux-2.6.15.1/fs/inode.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/inode.c	2006-01-27 15:03:56.000000000 +0100
@@ -770,7 +770,7 @@
  *
  * Note, @test is called with the inode_lock held, so can't sleep.
  */
-static inline struct inode *ifind(struct super_block *sb,
+static struct inode *ifind(struct super_block *sb,
 		struct hlist_head *head, int (*test)(struct inode *, void *),
 		void *data, const int wait)
 {
@@ -804,7 +804,7 @@
  *
  * Otherwise NULL is returned.
  */
-static inline struct inode *ifind_fast(struct super_block *sb,
+static struct inode *ifind_fast(struct super_block *sb,
 		struct hlist_head *head, unsigned long ino)
 {
 	struct inode *inode;
diff -Nur linux-2.6.15.1/fs/jffs2/build.c linux-2.6.15.1-owrt/fs/jffs2/build.c
--- linux-2.6.15.1/fs/jffs2/build.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/jffs2/build.c	2006-01-27 15:08:36.000000000 +0100
@@ -47,7 +47,7 @@
 	     ic = next_inode(&i, ic, (c)))
 
 
-static inline void jffs2_build_inode_pass1(struct jffs2_sb_info *c,
+static void jffs2_build_inode_pass1(struct jffs2_sb_info *c,
 					struct jffs2_inode_cache *ic)
 {
 	struct jffs2_full_dirent *fd;
diff -Nur linux-2.6.15.1/fs/jffs2/nodelist.c linux-2.6.15.1-owrt/fs/jffs2/nodelist.c
--- linux-2.6.15.1/fs/jffs2/nodelist.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/jffs2/nodelist.c	2006-01-27 15:08:36.000000000 +0100
@@ -134,7 +134,7 @@
 /*
  * Allocate and initializes a new fragment.
  */
-static inline struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)
+static struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)
 {
 	struct jffs2_node_frag *newfrag;
 
@@ -513,7 +513,7 @@
  *
  * Checks the node if we are in the checking stage.
  */
-static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn)
+static int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn)
 {
 	int ret;
 
diff -Nur linux-2.6.15.1/fs/lockd/xdr.c linux-2.6.15.1-owrt/fs/lockd/xdr.c
--- linux-2.6.15.1/fs/lockd/xdr.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/lockd/xdr.c	2006-01-27 15:08:36.000000000 +0100
@@ -44,7 +44,7 @@
 /*
  * XDR functions for basic NLM types
  */
-static inline u32 *nlm_decode_cookie(u32 *p, struct nlm_cookie *c)
+static u32 *nlm_decode_cookie(u32 *p, struct nlm_cookie *c)
 {
 	unsigned int	len;
 
@@ -79,7 +79,7 @@
 	return p;
 }
 
-static inline u32 *
+static u32 *
 nlm_decode_fh(u32 *p, struct nfs_fh *f)
 {
 	unsigned int	len;
@@ -119,7 +119,7 @@
 	return xdr_encode_netobj(p, oh);
 }
 
-static inline u32 *
+static u32 *
 nlm_decode_lock(u32 *p, struct nlm_lock *lock)
 {
 	struct file_lock	*fl = &lock->fl;
diff -Nur linux-2.6.15.1/fs/locks.c linux-2.6.15.1-owrt/fs/locks.c
--- linux-2.6.15.1/fs/locks.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/locks.c	2006-01-27 15:03:52.000000000 +0100
@@ -154,7 +154,7 @@
 }
 
 /* Free a lock which is not in use. */
-static inline void locks_free_lock(struct file_lock *fl)
+static void locks_free_lock(struct file_lock *fl)
 {
 	if (fl == NULL) {
 		BUG();
@@ -475,8 +475,7 @@
 /*
  * Check whether two locks have the same owner.
  */
-static inline int
-posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)
+static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)
 {
 	if (fl1->fl_lmops && fl1->fl_lmops->fl_compare_owner)
 		return fl2->fl_lmops == fl1->fl_lmops &&
@@ -487,7 +486,7 @@
 /* Remove waiter from blocker's block list.
  * When blocker ends up pointing to itself then the list is empty.
  */
-static inline void __locks_delete_block(struct file_lock *waiter)
+static void __locks_delete_block(struct file_lock *waiter)
 {
 	list_del_init(&waiter->fl_block);
 	list_del_init(&waiter->fl_link);
diff -Nur linux-2.6.15.1/fs/mbcache.c linux-2.6.15.1-owrt/fs/mbcache.c
--- linux-2.6.15.1/fs/mbcache.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/mbcache.c	2006-01-27 15:08:36.000000000 +0100
@@ -126,7 +126,7 @@
 }
 
 
-static inline void
+static void
 __mb_cache_entry_unhash(struct mb_cache_entry *ce)
 {
 	int n;
@@ -139,7 +139,7 @@
 }
 
 
-static inline void
+static void
 __mb_cache_entry_forget(struct mb_cache_entry *ce, gfp_t gfp_mask)
 {
 	struct mb_cache *cache = ce->e_cache;
@@ -158,7 +158,7 @@
 }
 
 
-static inline void
+static void
 __mb_cache_entry_release_unlock(struct mb_cache_entry *ce)
 {
 	/* Wake up all processes queuing for this cache entry. */
diff -Nur linux-2.6.15.1/fs/namei.c linux-2.6.15.1-owrt/fs/namei.c
--- linux-2.6.15.1/fs/namei.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/namei.c	2006-01-27 15:08:36.000000000 +0100
@@ -112,7 +112,7 @@
  * POSIX.1 2.4: an empty pathname is invalid (ENOENT).
  * PATH_MAX includes the nul terminator --RR.
  */
-static inline int do_getname(const char __user *filename, char *page)
+static int do_getname(const char __user *filename, char *page)
 {
 	int retval;
 	unsigned long len = PATH_MAX;
@@ -395,7 +395,7 @@
  * short-cut DAC fails, then call permission() to do more
  * complete permission check.
  */
-static inline int exec_permission_lite(struct inode *inode,
+static int exec_permission_lite(struct inode *inode,
 				       struct nameidata *nd)
 {
 	umode_t	mode = inode->i_mode;
@@ -485,7 +485,7 @@
 static int __emul_lookup_dentry(const char *, struct nameidata *);
 
 /* SMP-safe */
-static inline int
+static __always_inline int
 walk_init_root(const char *name, struct nameidata *nd)
 {
 	read_lock(&current->fs->lock);
@@ -503,7 +503,7 @@
 	return 1;
 }
 
-static inline int __vfs_follow_link(struct nameidata *nd, const char *link)
+static __always_inline int __vfs_follow_link(struct nameidata *nd, const char *link)
 {
 	int res = 0;
 	char *name;
@@ -543,7 +543,7 @@
 	struct dentry *dentry;
 };
 
-static inline int __do_follow_link(struct path *path, struct nameidata *nd)
+static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)
 {
 	int error;
 	void *cookie;
@@ -689,7 +689,7 @@
 	return 0;
 }
 
-static inline void follow_dotdot(struct nameidata *nd)
+static __always_inline void follow_dotdot(struct nameidata *nd)
 {
 	while(1) {
 		struct vfsmount *parent;
@@ -1293,7 +1293,7 @@
  * 10. We don't allow removal of NFS sillyrenamed files; it's handled by
  *     nfs_async_unlink().
  */
-static inline int may_delete(struct inode *dir,struct dentry *victim,int isdir)
+static int may_delete(struct inode *dir,struct dentry *victim,int isdir)
 {
 	int error;
 
@@ -2314,7 +2314,7 @@
 	return error;
 }
 
-static inline int do_rename(const char * oldname, const char * newname)
+static int do_rename(const char * oldname, const char * newname)
 {
 	int error = 0;
 	struct dentry * old_dir, * new_dir;
diff -Nur linux-2.6.15.1/fs/nfsd/nfsxdr.c linux-2.6.15.1-owrt/fs/nfsd/nfsxdr.c
--- linux-2.6.15.1/fs/nfsd/nfsxdr.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/nfsd/nfsxdr.c	2006-01-27 15:11:46.000000000 +0100
@@ -37,7 +37,7 @@
 /*
  * XDR functions for basic NFS types
  */
-static inline u32 *
+static u32 *
 decode_fh(u32 *p, struct svc_fh *fhp)
 {
 	fh_init(fhp, NFS_FHSIZE);
@@ -55,7 +55,7 @@
 	return decode_fh(p, fhp);
 }
 
-static inline u32 *
+static u32 *
 encode_fh(u32 *p, struct svc_fh *fhp)
 {
 	memcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);
diff -Nur linux-2.6.15.1/fs/open.c linux-2.6.15.1-owrt/fs/open.c
--- linux-2.6.15.1/fs/open.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/open.c	2006-01-27 15:04:00.000000000 +0100
@@ -216,7 +216,7 @@
 	return err;
 }
 
-static inline long do_sys_truncate(const char __user * path, loff_t length)
+static long do_sys_truncate(const char __user * path, loff_t length)
 {
 	struct nameidata nd;
 	struct inode * inode;
@@ -282,7 +282,7 @@
 	return do_sys_truncate(path, (long)length);
 }
 
-static inline long do_sys_ftruncate(unsigned int fd, loff_t length, int small)
+static long do_sys_ftruncate(unsigned int fd, loff_t length, int small)
 {
 	struct inode * inode;
 	struct dentry *dentry;
@@ -970,7 +970,7 @@
 
 EXPORT_SYMBOL(get_unused_fd);
 
-static inline void __put_unused_fd(struct files_struct *files, unsigned int fd)
+static void __put_unused_fd(struct files_struct *files, unsigned int fd)
 {
 	struct fdtable *fdt = files_fdtable(files);
 	__FD_CLR(fd, fdt->open_fds);
diff -Nur linux-2.6.15.1/fs/pipe.c linux-2.6.15.1-owrt/fs/pipe.c
--- linux-2.6.15.1/fs/pipe.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/fs/pipe.c	2006-01-27 15:08:36.000000000 +0100
@@ -50,7 +50,7 @@
 	down(PIPE_SEM(*inode));
 }
 
-static inline int
+static int
 pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len)
 {
 	unsigned long copy;
@@ -70,7 +70,7 @@
 	return 0;
 }
 
-static inline int
+static int
 pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len)
 {
 	unsigned long copy;
diff -Nur linux-2.6.15.1/include/asm-i386/bitops.h linux-2.6.15.1-owrt/include/asm-i386/bitops.h
--- linux-2.6.15.1/include/asm-i386/bitops.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/asm-i386/bitops.h	2006-01-27 15:03:37.000000000 +0100
@@ -247,7 +247,7 @@
 static int test_bit(int nr, const volatile void * addr);
 #endif
 
-static inline int constant_test_bit(int nr, const volatile unsigned long *addr)
+static __always_inline int constant_test_bit(int nr, const volatile unsigned long *addr)
 {
 	return ((1UL << (nr & 31)) & (addr[nr >> 5])) != 0;
 }
diff -Nur linux-2.6.15.1/include/asm-i386/current.h linux-2.6.15.1-owrt/include/asm-i386/current.h
--- linux-2.6.15.1/include/asm-i386/current.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/asm-i386/current.h	2006-01-27 15:03:37.000000000 +0100
@@ -5,7 +5,7 @@
 
 struct task_struct;
 
-static inline struct task_struct * get_current(void)
+static __always_inline struct task_struct * get_current(void)
 {
 	return current_thread_info()->task;
 }
diff -Nur linux-2.6.15.1/include/asm-i386/string.h linux-2.6.15.1-owrt/include/asm-i386/string.h
--- linux-2.6.15.1/include/asm-i386/string.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/asm-i386/string.h	2006-01-27 15:03:37.000000000 +0100
@@ -201,7 +201,7 @@
 return __res;
 }
 
-static inline void * __memcpy(void * to, const void * from, size_t n)
+static __always_inline void * __memcpy(void * to, const void * from, size_t n)
 {
 int d0, d1, d2;
 __asm__ __volatile__(
@@ -223,7 +223,7 @@
  * This looks ugly, but the compiler can optimize it totally,
  * as the count is constant.
  */
-static inline void * __constant_memcpy(void * to, const void * from, size_t n)
+static __always_inline void * __constant_memcpy(void * to, const void * from, size_t n)
 {
 	long esi, edi;
 	if (!n) return to;
@@ -367,7 +367,7 @@
  * things 32 bits at a time even when we don't know the size of the
  * area at compile-time..
  */
-static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
+static __always_inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
 {
 int d0, d1;
 __asm__ __volatile__(
@@ -416,7 +416,7 @@
  * This looks horribly ugly, but the compiler can optimize it totally,
  * as we by now know that both pattern and count is constant..
  */
-static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
+static __always_inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
 {
 	switch (count) {
 		case 0:
diff -Nur linux-2.6.15.1/include/asm-i386/uaccess.h linux-2.6.15.1-owrt/include/asm-i386/uaccess.h
--- linux-2.6.15.1/include/asm-i386/uaccess.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/asm-i386/uaccess.h	2006-01-27 15:03:37.000000000 +0100
@@ -411,7 +411,7 @@
  * Returns number of bytes that could not be copied.
  * On success, this will be zero.
  */
-static inline unsigned long __must_check
+static __always_inline unsigned long __must_check
 __copy_to_user_inatomic(void __user *to, const void *from, unsigned long n)
 {
 	if (__builtin_constant_p(n)) {
@@ -432,7 +432,7 @@
 	return __copy_to_user_ll(to, from, n);
 }
 
-static inline unsigned long __must_check
+static __always_inline unsigned long __must_check
 __copy_to_user(void __user *to, const void *from, unsigned long n)
 {
        might_sleep();
@@ -456,7 +456,7 @@
  * If some data could not be copied, this function will pad the copied
  * data to the requested size using zero bytes.
  */
-static inline unsigned long
+static __always_inline unsigned long
 __copy_from_user_inatomic(void *to, const void __user *from, unsigned long n)
 {
 	if (__builtin_constant_p(n)) {
@@ -477,7 +477,7 @@
 	return __copy_from_user_ll(to, from, n);
 }
 
-static inline unsigned long
+static __always_inline unsigned long
 __copy_from_user(void *to, const void __user *from, unsigned long n)
 {
        might_sleep();
diff -Nur linux-2.6.15.1/include/asm-x86_64/fixmap.h linux-2.6.15.1-owrt/include/asm-x86_64/fixmap.h
--- linux-2.6.15.1/include/asm-x86_64/fixmap.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/asm-x86_64/fixmap.h	2006-01-27 15:03:37.000000000 +0100
@@ -76,7 +76,7 @@
  * directly without translation, we catch the bug with a NULL-deference
  * kernel oops. Illegal ranges of incoming indices are caught too.
  */
-static inline unsigned long fix_to_virt(const unsigned int idx)
+static __always_inline unsigned long fix_to_virt(const unsigned int idx)
 {
 	/*
 	 * this branch gets completely eliminated after inlining,
diff -Nur linux-2.6.15.1/include/asm-x86_64/uaccess.h linux-2.6.15.1-owrt/include/asm-x86_64/uaccess.h
--- linux-2.6.15.1/include/asm-x86_64/uaccess.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/asm-x86_64/uaccess.h	2006-01-27 15:03:37.000000000 +0100
@@ -244,7 +244,7 @@
 extern unsigned long copy_from_user(void *to, const void __user *from, unsigned len); 
 extern unsigned long copy_in_user(void __user *to, const void __user *from, unsigned len); 
 
-static inline int __copy_from_user(void *dst, const void __user *src, unsigned size) 
+static __always_inline int __copy_from_user(void *dst, const void __user *src, unsigned size)
 { 
        int ret = 0;
 	if (!__builtin_constant_p(size))
@@ -273,7 +273,7 @@
 	}
 }	
 
-static inline int __copy_to_user(void __user *dst, const void *src, unsigned size) 
+static __always_inline int __copy_to_user(void __user *dst, const void *src, unsigned size)
 { 
        int ret = 0;
 	if (!__builtin_constant_p(size))
@@ -305,7 +305,7 @@
 }	
 
 
-static inline int __copy_in_user(void __user *dst, const void __user *src, unsigned size) 
+static __always_inline int __copy_in_user(void __user *dst, const void __user *src, unsigned size)
 { 
        int ret = 0;
 	if (!__builtin_constant_p(size))
diff -Nur linux-2.6.15.1/include/linux/compiler-gcc3.h linux-2.6.15.1-owrt/include/linux/compiler-gcc3.h
--- linux-2.6.15.1/include/linux/compiler-gcc3.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/linux/compiler-gcc3.h	2006-01-27 15:04:45.000000000 +0100
@@ -30,3 +30,4 @@
 #define __must_check		__attribute__((warn_unused_result))
 #endif
 
+#define __always_inline		inline __attribute__((always_inline))
diff -Nur linux-2.6.15.1/include/linux/compiler-gcc4.h linux-2.6.15.1-owrt/include/linux/compiler-gcc4.h
--- linux-2.6.15.1/include/linux/compiler-gcc4.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/linux/compiler-gcc4.h	2006-01-27 15:03:21.000000000 +0100
@@ -3,14 +3,16 @@
 /* These definitions are for GCC v4.x.  */
 #include <linux/compiler-gcc.h>
 
+#ifdef CONFIG_FORCED_INLINING
+# undef inline
+# undef __inline__
+# undef __inline
 #define inline			inline		__attribute__((always_inline))
 #define __inline__		__inline__	__attribute__((always_inline))
 #define __inline		__inline	__attribute__((always_inline))
-#define __deprecated		__attribute__((deprecated))
+#endif
+
 #define __attribute_used__	__attribute__((__used__))
-#define __attribute_pure__	__attribute__((pure))
-#define __attribute_const__	__attribute__((__const__))
-#define  noinline		__attribute__((noinline))
 #define __must_check 		__attribute__((warn_unused_result))
 #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
-
+#define __always_inline		inline __attribute__((always_inline))
diff -Nur linux-2.6.15.1/include/linux/mm.h linux-2.6.15.1-owrt/include/linux/mm.h
--- linux-2.6.15.1/include/linux/mm.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/linux/mm.h	2006-01-27 15:03:37.000000000 +0100
@@ -507,7 +507,7 @@
 extern struct page *mem_map;
 #endif
 
-static inline void *lowmem_page_address(struct page *page)
+static __always_inline void *lowmem_page_address(struct page *page)
 {
 	return __va(page_to_pfn(page) << PAGE_SHIFT);
 }
diff -Nur linux-2.6.15.1/include/linux/sched.h linux-2.6.15.1-owrt/include/linux/sched.h
--- linux-2.6.15.1/include/linux/sched.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/linux/sched.h	2006-01-27 15:03:45.000000000 +0100
@@ -1102,19 +1102,8 @@
 }
 
 
-#ifdef CONFIG_SECURITY
-/* code is in security.c */
+/* code is in security.c or kernel/sys.c if !SECURITY */
 extern int capable(int cap);
-#else
-static inline int capable(int cap)
-{
-	if (cap_raised(current->cap_effective, cap)) {
-		current->flags |= PF_SUPERPRIV;
-		return 1;
-	}
-	return 0;
-}
-#endif
 
 /*
  * Routines for handling mm_structs
diff -Nur linux-2.6.15.1/include/linux/time.h linux-2.6.15.1-owrt/include/linux/time.h
--- linux-2.6.15.1/include/linux/time.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/include/linux/time.h	2006-01-27 15:04:09.000000000 +0100
@@ -38,38 +38,9 @@
 	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
 } 
 
-/* Converts Gregorian date to seconds since 1970-01-01 00:00:00.
- * Assumes input in normal date format, i.e. 1980-12-31 23:59:59
- * => year=1980, mon=12, day=31, hour=23, min=59, sec=59.
- *
- * [For the Julian calendar (which was used in Russia before 1917,
- * Britain & colonies before 1752, anywhere else before 1582,
- * and is still in use by some communities) leave out the
- * -year/100+year/400 terms, and add 10.]
- *
- * This algorithm was first published by Gauss (I think).
- *
- * WARNING: this function will overflow on 2106-02-07 06:28:16 on
- * machines were long is 32-bit! (However, as time_t is signed, we
- * will already get problems at other places on 2038-01-19 03:14:08)
- */
-static inline unsigned long
-mktime (unsigned int year, unsigned int mon,
-	unsigned int day, unsigned int hour,
-	unsigned int min, unsigned int sec)
-{
-	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
-		mon += 12;		/* Puts Feb last since it has leap day */
-		year -= 1;
-	}
-
-	return (((
-		(unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
-			year*365 - 719499
-	    )*24 + hour /* now have hours */
-	  )*60 + min /* now have minutes */
-	)*60 + sec; /* finally seconds */
-}
+extern unsigned long mktime (unsigned int year, unsigned int mon,
+			     unsigned int day, unsigned int hour,
+			     unsigned int min, unsigned int sec);
 
 extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
@@ -80,6 +51,8 @@
 	return xtime.tv_sec;
 }
 
+extern void set_normalized_timespec (struct timespec *ts, time_t sec, long nsec);
+
 struct timespec current_kernel_time(void);
 
 #define CURRENT_TIME (current_kernel_time())
@@ -99,21 +72,6 @@
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
-static inline void
-set_normalized_timespec (struct timespec *ts, time_t sec, long nsec)
-{
-	while (nsec >= NSEC_PER_SEC) {
-		nsec -= NSEC_PER_SEC;
-		++sec;
-	}
-	while (nsec < 0) {
-		nsec += NSEC_PER_SEC;
-		--sec;
-	}
-	ts->tv_sec = sec;
-	ts->tv_nsec = nsec;
-}
-
 #endif /* __KERNEL__ */
 
 #define NFDBITS			__NFDBITS
diff -Nur linux-2.6.15.1/kernel/cpuset.c linux-2.6.15.1-owrt/kernel/cpuset.c
--- linux-2.6.15.1/kernel/cpuset.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/kernel/cpuset.c	2006-01-27 15:08:36.000000000 +0100
@@ -1252,7 +1252,7 @@
  * when reading out p->cpuset, as we don't really care if it changes
  * on the next cycle, and we are not going to try to dereference it.
  */
-static inline int pid_array_load(pid_t *pidarray, int npids, struct cpuset *cs)
+static int pid_array_load(pid_t *pidarray, int npids, struct cpuset *cs)
 {
 	int n = 0;
 	struct task_struct *g, *p;
diff -Nur linux-2.6.15.1/kernel/exit.c linux-2.6.15.1-owrt/kernel/exit.c
--- linux-2.6.15.1/kernel/exit.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/kernel/exit.c	2006-01-27 15:08:36.000000000 +0100
@@ -192,7 +192,7 @@
 	return retval;
 }
 
-static inline int has_stopped_jobs(int pgrp)
+static int has_stopped_jobs(int pgrp)
 {
 	int retval = 0;
 	struct task_struct *p;
@@ -229,7 +229,7 @@
  *
  * NOTE that reparent_to_init() gives the caller full capabilities.
  */
-static inline void reparent_to_init(void)
+static void reparent_to_init(void)
 {
 	write_lock_irq(&tasklist_lock);
 
@@ -366,7 +366,7 @@
 
 EXPORT_SYMBOL(daemonize);
 
-static inline void close_files(struct files_struct * files)
+static void close_files(struct files_struct * files)
 {
 	int i, j;
 	struct fdtable *fdt;
@@ -540,7 +540,7 @@
 	p->real_parent = reaper;
 }
 
-static inline void reparent_thread(task_t *p, task_t *father, int traced)
+static void reparent_thread(task_t *p, task_t *father, int traced)
 {
 	/* We don't want people slaying init.  */
 	if (p->exit_signal != -1)
@@ -604,7 +604,7 @@
  * group, and if no such member exists, give it to
  * the global child reaper process (ie "init")
  */
-static inline void forget_original_parent(struct task_struct * father,
+static void forget_original_parent(struct task_struct * father,
 					  struct list_head *to_release)
 {
 	struct task_struct *p, *reaper = father;
diff -Nur linux-2.6.15.1/kernel/posix-timers.c linux-2.6.15.1-owrt/kernel/posix-timers.c
--- linux-2.6.15.1/kernel/posix-timers.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/kernel/posix-timers.c	2006-01-27 15:08:36.000000000 +0100
@@ -203,7 +203,7 @@
 	return do_sys_settimeofday(tp, NULL);
 }
 
-static inline int common_timer_create(struct k_itimer *new_timer)
+static int common_timer_create(struct k_itimer *new_timer)
 {
 	INIT_LIST_HEAD(&new_timer->it.real.abs_timer_entry);
 	init_timer(&new_timer->it.real.timer);
@@ -513,7 +513,7 @@
 }
 
 
-static inline struct task_struct * good_sigevent(sigevent_t * event)
+static struct task_struct * good_sigevent(sigevent_t * event)
 {
 	struct task_struct *rtn = current->group_leader;
 
@@ -939,7 +939,7 @@
 
 /* Set a POSIX.1b interval timer. */
 /* timr->it_lock is taken. */
-static inline int
+static int
 common_timer_set(struct k_itimer *timr, int flags,
 		 struct itimerspec *new_setting, struct itimerspec *old_setting)
 {
@@ -1122,7 +1122,7 @@
 /*
  * return timer owned by the process, used by exit_itimers
  */
-static inline void itimer_delete(struct k_itimer *timer)
+static void itimer_delete(struct k_itimer *timer)
 {
 	unsigned long flags;
 
diff -Nur linux-2.6.15.1/kernel/sched.c linux-2.6.15.1-owrt/kernel/sched.c
--- linux-2.6.15.1/kernel/sched.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/kernel/sched.c	2006-01-27 15:08:36.000000000 +0100
@@ -512,7 +512,7 @@
  * long it was waiting to run.  We also note when it began so that we
  * can keep stats on how long its timeslice is.
  */
-static inline void sched_info_arrive(task_t *t)
+static void sched_info_arrive(task_t *t)
 {
 	unsigned long now = jiffies, diff = 0;
 	struct runqueue *rq = task_rq(t);
@@ -994,7 +994,7 @@
  * We want to under-estimate the load of migration sources, to
  * balance conservatively.
  */
-static inline unsigned long __source_load(int cpu, int type, enum idle_type idle)
+static unsigned long __source_load(int cpu, int type, enum idle_type idle)
 {
 	runqueue_t *rq = cpu_rq(cpu);
 	unsigned long running = rq->nr_running;
@@ -1849,7 +1849,7 @@
  * pull_task - move a task from a remote runqueue to the local runqueue.
  * Both runqueues must be locked.
  */
-static inline
+static
 void pull_task(runqueue_t *src_rq, prio_array_t *src_array, task_t *p,
 	       runqueue_t *this_rq, prio_array_t *this_array, int this_cpu)
 {
@@ -1871,7 +1871,7 @@
 /*
  * can_migrate_task - may task p from runqueue rq be migrated to this_cpu?
  */
-static inline
+static
 int can_migrate_task(task_t *p, runqueue_t *rq, int this_cpu,
 		     struct sched_domain *sd, enum idle_type idle,
 		     int *all_pinned)
@@ -2357,7 +2357,7 @@
  * idle_balance is called by schedule() if this_cpu is about to become
  * idle. Attempts to pull tasks from other CPUs.
  */
-static inline void idle_balance(int this_cpu, runqueue_t *this_rq)
+static void idle_balance(int this_cpu, runqueue_t *this_rq)
 {
 	struct sched_domain *sd;
 
@@ -2741,7 +2741,7 @@
 		resched_task(rq->idle);
 }
 
-static inline void wake_sleeping_dependent(int this_cpu, runqueue_t *this_rq)
+static void wake_sleeping_dependent(int this_cpu, runqueue_t *this_rq)
 {
 	struct sched_domain *tmp, *sd = NULL;
 	cpumask_t sibling_map;
@@ -2795,7 +2795,7 @@
 	return p->time_slice * (100 - sd->per_cpu_gain) / 100;
 }
 
-static inline int dependent_sleeper(int this_cpu, runqueue_t *this_rq)
+static int dependent_sleeper(int this_cpu, runqueue_t *this_rq)
 {
 	struct sched_domain *tmp, *sd = NULL;
 	cpumask_t sibling_map;
@@ -5505,7 +5505,7 @@
  * Detach sched domains from a group of cpus specified in cpu_map
  * These cpus will now be attached to the NULL domain
  */
-static inline void detach_destroy_domains(const cpumask_t *cpu_map)
+static void detach_destroy_domains(const cpumask_t *cpu_map)
 {
 	int i;
 
diff -Nur linux-2.6.15.1/kernel/signal.c linux-2.6.15.1-owrt/kernel/signal.c
--- linux-2.6.15.1/kernel/signal.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/kernel/signal.c	2006-01-27 15:08:36.000000000 +0100
@@ -465,7 +465,7 @@
 	spin_unlock_irqrestore(&current->sighand->siglock, flags);
 }
 
-static inline int collect_signal(int sig, struct sigpending *list, siginfo_t *info)
+static int collect_signal(int sig, struct sigpending *list, siginfo_t *info)
 {
 	struct sigqueue *q, *first = NULL;
 	int still_pending = 0;
@@ -1786,7 +1786,7 @@
  * We return zero if we still hold the siglock and should look
  * for another signal without checking group_stop_count again.
  */
-static inline int handle_group_stop(void)
+static int handle_group_stop(void)
 {
 	int stop_count;
 
diff -Nur linux-2.6.15.1/kernel/sys.c linux-2.6.15.1-owrt/kernel/sys.c
--- linux-2.6.15.1/kernel/sys.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/kernel/sys.c	2006-01-27 15:03:45.000000000 +0100
@@ -223,6 +223,18 @@
 
 EXPORT_SYMBOL(unregister_reboot_notifier);
 
+#ifndef CONFIG_SECURITY
+int capable(int cap)
+{
+        if (cap_raised(current->cap_effective, cap)) {
+	       current->flags |= PF_SUPERPRIV;
+	       return 1;
+        }
+        return 0;
+}
+EXPORT_SYMBOL(capable);
+#endif
+
 static int set_one_prio(struct task_struct *p, int niceval, int error)
 {
 	int no_nice;
diff -Nur linux-2.6.15.1/kernel/time.c linux-2.6.15.1-owrt/kernel/time.c
--- linux-2.6.15.1/kernel/time.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/kernel/time.c	2006-01-27 15:04:09.000000000 +0100
@@ -583,6 +583,67 @@
 }
 EXPORT_SYMBOL_GPL(getnstimestamp);
 
+/* Converts Gregorian date to seconds since 1970-01-01 00:00:00.
+ * Assumes input in normal date format, i.e. 1980-12-31 23:59:59
+ * => year=1980, mon=12, day=31, hour=23, min=59, sec=59.
+ *
+ * [For the Julian calendar (which was used in Russia before 1917,
+ * Britain & colonies before 1752, anywhere else before 1582,
+ * and is still in use by some communities) leave out the
+ * -year/100+year/400 terms, and add 10.]
+ *
+ * This algorithm was first published by Gauss (I think).
+ *
+ * WARNING: this function will overflow on 2106-02-07 06:28:16 on
+ * machines were long is 32-bit! (However, as time_t is signed, we
+ * will already get problems at other places on 2038-01-19 03:14:08)
+ */
+unsigned long
+mktime (unsigned int year, unsigned int mon,
+	unsigned int day, unsigned int hour,
+	unsigned int min, unsigned int sec)
+{
+	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
+		mon += 12;		/* Puts Feb last since it has leap day */
+		year -= 1;
+	}
+
+	return ((((unsigned long)
+		  (year/4 - year/100 + year/400 + 367*mon/12 + day) +
+		  year*365 - 719499
+	    )*24 + hour /* now have hours */
+	  )*60 + min /* now have minutes */
+	)*60 + sec; /* finally seconds */
+}
+
+/**
+ * set_normalized_timespec - set timespec sec and nsec parts and normalize
+ *
+ * @ts:		pointer to timespec variable to be set
+ * @sec:	seconds to set
+ * @nsec:	nanoseconds to set
+ *
+ * Set seconds and nanoseconds field of a timespec variable and
+ * normalize to the timespec storage format
+ *
+ * Note: The tv_nsec part is always in the range of
+ * 	0 <= tv_nsec < NSEC_PER_SEC
+ * For negative values only the tv_sec field is negative !
+ */
+void set_normalized_timespec (struct timespec *ts, time_t sec, long nsec)
+{
+	while (nsec >= NSEC_PER_SEC) {
+		nsec -= NSEC_PER_SEC;
+		++sec;
+	}
+	while (nsec < 0) {
+		nsec += NSEC_PER_SEC;
+		--sec;
+	}
+	ts->tv_sec = sec;
+	ts->tv_nsec = nsec;
+}
+
 #if (BITS_PER_LONG < 64)
 u64 get_jiffies_64(void)
 {
diff -Nur linux-2.6.15.1/kernel/workqueue.c linux-2.6.15.1-owrt/kernel/workqueue.c
--- linux-2.6.15.1/kernel/workqueue.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/kernel/workqueue.c	2006-01-27 15:08:36.000000000 +0100
@@ -147,7 +147,7 @@
 	return ret;
 }
 
-static inline void run_workqueue(struct cpu_workqueue_struct *cwq)
+static void run_workqueue(struct cpu_workqueue_struct *cwq)
 {
 	unsigned long flags;
 
diff -Nur linux-2.6.15.1/lib/Kconfig.debug linux-2.6.15.1-owrt/lib/Kconfig.debug
--- linux-2.6.15.1/lib/Kconfig.debug	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/lib/Kconfig.debug	2006-01-27 15:03:21.000000000 +0100
@@ -186,6 +186,20 @@
 	  some architectures or if you use external debuggers.
 	  If you don't debug the kernel, you can say N.
 
+config FORCED_INLINING
+	bool "Force gcc to inline functions marked 'inline'"
+	depends on DEBUG_KERNEL
+	default y
+	help
+	  This option determines if the kernel forces gcc to inline the functions
+	  developers have marked 'inline'. Doing so takes away freedom from gcc to
+	  do what it thinks is best, which is desirable for the gcc 3.x series of
+	  compilers. The gcc 4.x series have a rewritten inlining algorithm and
+	  disabling this option will generate a smaller kernel there. Hopefully
+	  this algorithm is so good that allowing gcc4 to make the decision can
+	  become the default in the future, until then this option is there to
+	  test gcc for this.
+
 config RCU_TORTURE_TEST
 	tristate "torture tests for RCU"
 	depends on DEBUG_KERNEL
diff -Nur linux-2.6.15.1/mm/internal.h linux-2.6.15.1-owrt/mm/internal.h
--- linux-2.6.15.1/mm/internal.h	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/mm/internal.h	2006-01-27 15:04:04.000000000 +0100
@@ -9,5 +9,20 @@
  * 2 of the License, or (at your option) any later version.
  */
 
-/* page_alloc.c */
-extern void set_page_refs(struct page *page, int order);
+static inline void set_page_refs(struct page *page, int order)
+{
+#ifdef CONFIG_MMU
+	set_page_count(page, 1);
+#else
+	int i;
+
+	/*
+	 * We need to reference all the pages for this order, otherwise if
+	 * anyone accesses one of the pages with (get/put) it will be freed.
+	 * - eg: access_process_vm()
+	 */
+	for (i = 0; i < (1 << order); i++)
+		set_page_count(page + i, 1);
+#endif /* CONFIG_MMU */
+}
+
diff -Nur linux-2.6.15.1/mm/page_alloc.c linux-2.6.15.1-owrt/mm/page_alloc.c
--- linux-2.6.15.1/mm/page_alloc.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/mm/page_alloc.c	2006-01-27 15:04:04.000000000 +0100
@@ -451,23 +451,6 @@
 	return page;
 }
 
-void set_page_refs(struct page *page, int order)
-{
-#ifdef CONFIG_MMU
-	set_page_count(page, 1);
-#else
-	int i;
-
-	/*
-	 * We need to reference all the pages for this order, otherwise if
-	 * anyone accesses one of the pages with (get/put) it will be freed.
-	 * - eg: access_process_vm()
-	 */
-	for (i = 0; i < (1 << order); i++)
-		set_page_count(page + i, 1);
-#endif /* CONFIG_MMU */
-}
-
 /*
  * This page is about to be returned from the page allocator
  */
diff -Nur linux-2.6.15.1/net/ieee80211/ieee80211_module.c linux-2.6.15.1-owrt/net/ieee80211/ieee80211_module.c
--- linux-2.6.15.1/net/ieee80211/ieee80211_module.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/net/ieee80211/ieee80211_module.c	2006-01-27 15:08:36.000000000 +0100
@@ -62,7 +62,7 @@
 MODULE_AUTHOR(DRV_COPYRIGHT);
 MODULE_LICENSE("GPL");
 
-static inline int ieee80211_networks_allocate(struct ieee80211_device *ieee)
+static int ieee80211_networks_allocate(struct ieee80211_device *ieee)
 {
 	if (ieee->networks)
 		return 0;
@@ -90,7 +90,7 @@
 	ieee->networks = NULL;
 }
 
-static inline void ieee80211_networks_initialize(struct ieee80211_device *ieee)
+static void ieee80211_networks_initialize(struct ieee80211_device *ieee)
 {
 	int i;
 
diff -Nur linux-2.6.15.1/net/ieee80211/ieee80211_rx.c linux-2.6.15.1-owrt/net/ieee80211/ieee80211_rx.c
--- linux-2.6.15.1/net/ieee80211/ieee80211_rx.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/net/ieee80211/ieee80211_rx.c	2006-01-27 15:08:36.000000000 +0100
@@ -35,7 +35,7 @@
 
 #include <net/ieee80211.h>
 
-static inline void ieee80211_monitor_rx(struct ieee80211_device *ieee,
+static void ieee80211_monitor_rx(struct ieee80211_device *ieee,
 					struct sk_buff *skb,
 					struct ieee80211_rx_stats *rx_stats)
 {
@@ -165,7 +165,7 @@
  * Responsible for handling management control frames
  *
  * Called by ieee80211_rx */
-static inline int
+static int
 ieee80211_rx_frame_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats, u16 type,
 			u16 stype)
@@ -266,7 +266,7 @@
 }
 
 /* Called only as a tasklet (software IRQ), by ieee80211_rx */
-static inline int
+static int
 ieee80211_rx_frame_decrypt(struct ieee80211_device *ieee, struct sk_buff *skb,
 			   struct ieee80211_crypt_data *crypt)
 {
@@ -297,7 +297,7 @@
 }
 
 /* Called only as a tasklet (software IRQ), by ieee80211_rx */
-static inline int
+static int
 ieee80211_rx_frame_decrypt_msdu(struct ieee80211_device *ieee,
 				struct sk_buff *skb, int keyidx,
 				struct ieee80211_crypt_data *crypt)
@@ -1157,7 +1157,7 @@
 
 /***************************************************/
 
-static inline int ieee80211_network_init(struct ieee80211_device *ieee, struct ieee80211_probe_response
+static int ieee80211_network_init(struct ieee80211_device *ieee, struct ieee80211_probe_response
 					 *beacon,
 					 struct ieee80211_network *network,
 					 struct ieee80211_rx_stats *stats)
@@ -1236,7 +1236,7 @@
 		!memcmp(src->ssid, dst->ssid, src->ssid_len));
 }
 
-static inline void update_network(struct ieee80211_network *dst,
+static void update_network(struct ieee80211_network *dst,
 				  struct ieee80211_network *src)
 {
 	int qos_active;
@@ -1295,7 +1295,7 @@
 	return (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == IEEE80211_STYPE_BEACON);
 }
 
-static inline void ieee80211_process_probe_response(struct ieee80211_device
+static void ieee80211_process_probe_response(struct ieee80211_device
 						    *ieee, struct
 						    ieee80211_probe_response
 						    *beacon, struct ieee80211_rx_stats
diff -Nur linux-2.6.15.1/net/ieee80211/ieee80211_tx.c linux-2.6.15.1-owrt/net/ieee80211/ieee80211_tx.c
--- linux-2.6.15.1/net/ieee80211/ieee80211_tx.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/net/ieee80211/ieee80211_tx.c	2006-01-27 15:08:36.000000000 +0100
@@ -127,7 +127,7 @@
 static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
 static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
 
-static inline int ieee80211_copy_snap(u8 * data, u16 h_proto)
+static int ieee80211_copy_snap(u8 * data, u16 h_proto)
 {
 	struct ieee80211_snap_hdr *snap;
 	u8 *oui;
@@ -150,7 +150,7 @@
 	return SNAP_SIZE + sizeof(u16);
 }
 
-static inline int ieee80211_encrypt_fragment(struct ieee80211_device *ieee,
+static int ieee80211_encrypt_fragment(struct ieee80211_device *ieee,
 					     struct sk_buff *frag, int hdr_len)
 {
 	struct ieee80211_crypt_data *crypt = ieee->crypt[ieee->tx_keyidx];
diff -Nur linux-2.6.15.1/net/ieee80211/ieee80211_wx.c linux-2.6.15.1-owrt/net/ieee80211/ieee80211_wx.c
--- linux-2.6.15.1/net/ieee80211/ieee80211_wx.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/net/ieee80211/ieee80211_wx.c	2006-01-27 15:08:36.000000000 +0100
@@ -42,7 +42,7 @@
 };
 
 #define MAX_CUSTOM_LEN 64
-static inline char *ipw2100_translate_scan(struct ieee80211_device *ieee,
+static char *ipw2100_translate_scan(struct ieee80211_device *ieee,
 					   char *start, char *stop,
 					   struct ieee80211_network *network)
 {
diff -Nur linux-2.6.15.1/net/netfilter/nfnetlink.c linux-2.6.15.1-owrt/net/netfilter/nfnetlink.c
--- linux-2.6.15.1/net/netfilter/nfnetlink.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/net/netfilter/nfnetlink.c	2006-01-27 15:08:36.000000000 +0100
@@ -212,7 +212,7 @@
 }
 
 /* Process one complete nfnetlink message. */
-static inline int nfnetlink_rcv_msg(struct sk_buff *skb,
+static int nfnetlink_rcv_msg(struct sk_buff *skb,
 				    struct nlmsghdr *nlh, int *errp)
 {
 	struct nfnl_callback *nc;
diff -Nur linux-2.6.15.1/security/selinux/hooks.c linux-2.6.15.1-owrt/security/selinux/hooks.c
--- linux-2.6.15.1/security/selinux/hooks.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/security/selinux/hooks.c	2006-01-27 15:08:36.000000000 +0100
@@ -1018,7 +1018,7 @@
    has the same SID as the process.  If av is zero, then
    access to the file is not checked, e.g. for cases
    where only the descriptor is affected like seek. */
-static inline int file_has_perm(struct task_struct *tsk,
+static int file_has_perm(struct task_struct *tsk,
 				struct file *file,
 				u32 av)
 {
diff -Nur linux-2.6.15.1/sound/oss/esssolo1.c linux-2.6.15.1-owrt/sound/oss/esssolo1.c
--- linux-2.6.15.1/sound/oss/esssolo1.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/sound/oss/esssolo1.c	2006-01-27 15:08:36.000000000 +0100
@@ -515,7 +515,7 @@
 	return 0;
 }
 
-static inline int prog_dmabuf_dac(struct solo1_state *s)
+static int prog_dmabuf_dac(struct solo1_state *s)
 {
 	unsigned long va;
 	int c;
diff -Nur linux-2.6.15.1/sound/pci/es1968.c linux-2.6.15.1-owrt/sound/pci/es1968.c
--- linux-2.6.15.1/sound/pci/es1968.c	2006-01-15 07:16:02.000000000 +0100
+++ linux-2.6.15.1-owrt/sound/pci/es1968.c	2006-01-27 15:13:39.000000000 +0100
@@ -731,7 +731,7 @@
 	apu_data_set(chip, data);
 }
 
-static inline void apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
+static void apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&chip->reg_lock, flags);
diff -Nur linux-2.6.15.1/arch/mips/Makefile linux-2.6.15.1-owrt/arch/mips/Makefile
--- linux-2.6.15.1/arch/mips/Makefile	2006-01-21 17:13:20.000000000 +0100
+++ linux-2.6.15.1-owrt/arch/mips/Makefile	2006-01-28 11:37:25.000000000 +0100
@@ -93,7 +93,6 @@
 #
 cflags-y			+= -I $(TOPDIR)/include/asm/gcc
 cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
-cflags-y			+= $(call cc-option, -finline-limit=100000)
 LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
 MODFLAGS			+= -mlong-calls
 
--- linux-2.6.15.1.old/include/asm-mips/system.h	2006-01-28 15:02:54.481032280 +0100
+++ linux-2.6.15.1.dev/include/asm-mips/system.h	2006-01-28 14:47:51.634285848 +0100
@@ -273,7 +273,7 @@
    if something tries to do an invalid xchg().  */
 extern void __xchg_called_with_bad_pointer(void);
 
-static inline unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
+static __always_inline unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
 {
 	switch (size) {
 		case 4:
