This patch fixes the network driver cpmac.c for compilation with
configuration option CONFIG_NETDEVICES_MULTIQUEUE.

These compiler warnings are fixed by the patch:
drivers/net/cpmac.c: In function 'cpmac_end_xmit':
drivers/net/cpmac.c:630: warning: passing argument 2 of 'netif_subqueue_stopped' makes pointer from integer without a cast
drivers/net/cpmac.c:641: warning: passing argument 2 of 'netif_subqueue_stopped' makes pointer from integer without a cast
drivers/net/cpmac.c: In function 'cpmac_probe':
drivers/net/cpmac.c:1128: warning: unused variable 'i'

During runtime, the unpatched driver raises a fatal runtime exception.
This is fixed by calling __netif_subqueue_stopped instead
of netif_subqueue_stopped, too.

Two additional code parts were modified for CONFIG_NETDEVICES_MULTIQUEUE
because other drivers do it in the same way.

        Signed-off-by: Stefan Weil <weil@mail.berlios.de>

--- a/drivers/net/cpmac.c
+++ b/drivers/net/cpmac.c
@@ -557,6 +557,7 @@ fatal_error:
 static int cpmac_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	int queue, len;
+	unsigned long flags;
 	struct cpmac_desc *desc;
 	struct cpmac_priv *priv = netdev_priv(dev);
 
@@ -566,7 +567,10 @@ static int cpmac_start_xmit(struct sk_bu
 	if (unlikely(skb_padto(skb, ETH_ZLEN)))
 		return NETDEV_TX_OK;
 
-	len = max(skb->len, ETH_ZLEN);
+	len = skb->len;
+	if (len < ETH_ZLEN)
+		len = ETH_ZLEN;
+
 	queue = skb_get_queue_mapping(skb);
 	netif_stop_subqueue(dev, queue);
 
@@ -578,9 +582,9 @@ static int cpmac_start_xmit(struct sk_bu
 		return NETDEV_TX_BUSY;
 	}
 
-	spin_lock(&priv->lock);
+	spin_lock_irqsave(&priv->lock, flags);
 	dev->trans_start = jiffies;
-	spin_unlock(&priv->lock);
+	spin_unlock_irqrestore(&priv->lock, flags);
 	desc->dataflags = CPMAC_SOP | CPMAC_EOP | CPMAC_OWN;
 	desc->skb = skb;
 	desc->data_mapping = dma_map_single(&dev->dev, skb->data, len,
@@ -621,13 +621,13 @@ static void cpmac_end_xmit(struct net_de
 
 		dev_kfree_skb_irq(desc->skb);
 		desc->skb = NULL;
-		if (netif_subqueue_stopped(dev, queue))
+		if (__netif_subqueue_stopped(dev, queue))
 			netif_wake_subqueue(dev, queue);
 	} else {
 		if (netif_msg_tx_err(priv) && net_ratelimit())
 			printk(KERN_WARNING
 			       "%s: end_xmit: spurious interrupt\n", dev->name);
-		if (netif_subqueue_stopped(dev, queue))
+		if (__netif_subqueue_stopped(dev, queue))
 			netif_wake_subqueue(dev, queue);
 	}
 }
@@ -737,7 +737,6 @@ static void cpmac_clear_tx(struct net_de
 
 static void cpmac_hw_error(struct work_struct *work)
 {
-	int i;
 	struct cpmac_priv *priv =
 		container_of(work, struct cpmac_priv, reset_work);
 
@@ -824,7 +823,6 @@ static irqreturn_t cpmac_irq(int irq, vo
 
 static void cpmac_tx_timeout(struct net_device *dev)
 {
-	int i;
 	struct cpmac_priv *priv = netdev_priv(dev);
 
 	spin_lock(&priv->lock);
@@ -927,8 +929,9 @@ static void cpmac_adjust_link(struct net
 {
 	struct cpmac_priv *priv = netdev_priv(dev);
 	int new_state = 0;
+	unsigned long flags;
 
-	spin_lock(&priv->lock);
+	spin_lock_irqsave(&priv->lock, flags);
 	if (priv->phy->link) {
 		netif_tx_start_all_queues(dev);
 		if (priv->phy->duplex != priv->oldduplex) {
@@ -955,7 +958,8 @@ static void cpmac_adjust_link(struct net
 	if (new_state && netif_msg_link(priv) && net_ratelimit())
 		phy_print_status(priv->phy);
 
-	spin_unlock(&priv->lock);
+	// TODO: call unlock earlier?
+	spin_unlock_irqrestore(&priv->lock, flags);
 }
 
 static int cpmac_open(struct net_device *dev)
@@ -1103,7 +1101,7 @@ static int external_switch;
 
 static int __devinit cpmac_probe(struct platform_device *pdev)
 {
-	int rc, phy_id, i;
+	int rc, phy_id;
 	char *mdio_bus_id = "0";
 	struct resource *mem;
 	struct cpmac_priv *priv;
@@ -1132,6 +1130,7 @@ static int __devinit cpmac_probe(struct 
 	}
 
 	dev = alloc_etherdev_mq(sizeof(*priv), CPMAC_QUEUES);
+	//~ dev = alloc_etherdev(sizeof(*priv));
 
 	if (!dev) {
 		printk(KERN_ERR "cpmac: Unable to allocate net_device\n");
